"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["7376"],{60332:function(e,n,r){e.exports=r.p+"static/image/wechat-official-accounts-mini.44481959.png"},98314:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var c=r(52676),d=r(40453),s=r(20713),i=r(60332);function l(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",strong:"strong",ol:"ol",li:"li",h4:"h4",img:"img"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"面试官问js的this指向",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#面试官问js的this指向",children:"#"}),"面试官问：JS的this指向"]}),"\n",(0,c.jsx)(s.Z,{defaultLocale:"zh-CN"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"写于2018年12月25日"})}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"}),"前言"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["大家好，我是",(0,c.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,c.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,c.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,c.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,c.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["这是面试官问系列的第四篇，旨在帮助读者提升",(0,c.jsx)(n.code,{children:"JS"}),"基础知识，包含",(0,c.jsx)(n.code,{children:"new、call、apply、this、继承"}),"相关知识。","\n",(0,c.jsx)(n.code,{children:"面试官问系列"}),"文章如下：感兴趣的读者可以点击阅读。","\n1.",(0,c.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n2.",(0,c.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n3.",(0,c.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n4.",(0,c.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n5.",(0,c.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["面试官出很多考题，基本都会变着方式来考察",(0,c.jsx)(n.code,{children:"this"}),"指向，看候选人对",(0,c.jsx)(n.code,{children:"JS"}),"基础知识是否扎实。\n读者可以先拉到底部看总结，再谷歌（或各技术平台）搜索几篇类似文章，看笔者写的文章和别人有什么不同（欢迎在评论区评论不同之处），对比来看，验证与自己现有知识是否有盲点，多看几篇，自然就会完善自身知识。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["附上之前写文章写过的一段话：已经有很多关于",(0,c.jsx)(n.code,{children:"this"}),"的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["函数的",(0,c.jsx)(n.code,{children:"this"}),"在调用时绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。为了搞清楚",(0,c.jsx)(n.code,{children:"this"}),"的指向是什么，必须知道相关函数是如何调用的。"]}),"\n",(0,c.jsxs)(n.h2,{id:"全局上下文",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局上下文",children:"#"}),"全局上下文"]}),"\n",(0,c.jsxs)(n.p,{children:["非严格模式和严格模式中this都是指向顶层对象（浏览器中是",(0,c.jsx)(n.code,{children:"window"}),"）。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"this === window // true\n'use strict'\nthis === window;\nthis.name = '若川';\nconsole.log(this.name); // 若川\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"函数上下文",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数上下文",children:"#"}),"函数上下文"]}),"\n",(0,c.jsxs)(n.h3,{id:"普通函数调用模式",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#普通函数调用模式",children:"#"}),"普通函数调用模式"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 非严格模式\nvar name = 'window';\nvar doSth = function(){\n    console.log(this.name);\n}\ndoSth(); // 'window'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["你可能会误以为",(0,c.jsx)(n.code,{children:"window.doSth()"}),"是调用的，所以是指向",(0,c.jsx)(n.code,{children:"window"}),"。虽然本例中",(0,c.jsx)(n.code,{children:"window.doSth"}),"确实等于",(0,c.jsx)(n.code,{children:"doSth"}),"。",(0,c.jsx)(n.code,{children:"name"}),"等于",(0,c.jsx)(n.code,{children:"window.name"}),"。上面代码中这是因为在",(0,c.jsx)(n.code,{children:"ES5"}),"中，全局变量是挂载在顶层对象（浏览器是",(0,c.jsx)(n.code,{children:"window"}),"）中。\n事实上，并不是如此。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 非严格模式\nlet name2 = 'window2';\nlet doSth2 = function(){\n    console.log(this === window);\n    console.log(this.name2);\n}\ndoSth2() // true, undefined\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这个例子中",(0,c.jsx)(n.code,{children:"let"}),"没有给顶层对象中（浏览器是window）添加属性，",(0,c.jsx)(n.code,{children:"window.name2和window.doSth"}),"都是",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["严格模式中，普通函数中的",(0,c.jsx)(n.code,{children:"this"}),"则表现不同，表现为",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 严格模式\n'use strict'\nvar name = 'window';\nvar doSth = function(){\n    console.log(typeof this === 'undefined');\n    console.log(this.name);\n}\ndoSth(); // true，// 报错，因为this是undefined\n"})}),"\n",(0,c.jsxs)(n.p,{children:["看过的《你不知道的",(0,c.jsx)(n.code,{children:"JavaScript"}),"》上卷的读者，应该知道书上将这种叫做默认绑定。\n对",(0,c.jsx)(n.code,{children:"call"}),"，",(0,c.jsx)(n.code,{children:"apply"}),"熟悉的读者会类比为："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"doSth.call(undefined);\ndoSth.apply(undefined);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["效果是一样的，",(0,c.jsx)(n.code,{children:"call"}),"，",(0,c.jsx)(n.code,{children:"apply"}),"作用之一就是用来修改函数中的",(0,c.jsx)(n.code,{children:"this"}),"指向为第一个参数的。\n第一个参数是",(0,c.jsx)(n.code,{children:"undefined"}),"或者",(0,c.jsx)(n.code,{children:"null"}),"，非严格模式下，是指向",(0,c.jsx)(n.code,{children:"window"}),"。严格模式下，就是指向第一个参数。后文详细解释。","\n经常有这类代码（回调函数），其实也是普通函数调用模式。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var name = '若川';\nsetTimeout(function(){\n    console.log(this.name);\n}, 0);\n// 语法\nsetTimeout(fn | code, 0, arg1, arg2, ...)\n// 也可以是一串代码。也可以传递其他函数\n// 类比 setTimeout函数内部调用fn或者执行代码`code`。\nfn.call(undefined, arg1, arg2, ...);\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"对象中的函数方法调用模式",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象中的函数方法调用模式",children:"#"}),"对象中的函数（方法）调用模式"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var name = 'window';\nvar doSth = function(){\n    console.log(this.name);\n}\nvar student = {\n    name: '若川',\n    doSth: doSth,\n    other: {\n        name: 'other',\n        doSth: doSth,\n    }\n}\nstudent.doSth(); // '若川'\nstudent.other.doSth(); // 'other'\n// 用call类比则为：\nstudent.doSth.call(student);\n// 用call类比则为：\nstudent.other.doSth.call(student.other);\n"})}),"\n",(0,c.jsx)(n.p,{children:"但往往会有以下场景，把对象中的函数赋值成一个变量了。\n这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var studentDoSth = student.doSth;\nstudentDoSth(); // 'window'\n// 用call类比则为：\nstudentDoSth.call(undefined);\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"callapplybind-调用模式",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#callapplybind-调用模式",children:"#"}),(0,c.jsx)(n.code,{children:"call、apply、bind"})," 调用模式"]}),"\n",(0,c.jsxs)(n.p,{children:["上文提到",(0,c.jsx)(n.code,{children:"call"}),"、",(0,c.jsx)(n.code,{children:"apply"}),"，这里详细解读一下。先通过",(0,c.jsx)(n.code,{children:"MDN"}),"认识下",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"\n",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call",rel:"noopener noreferrer",target:"_blank",children:"MDN 文档：Function.prototype.call()"}),"\n",(0,c.jsx)(n.strong,{children:"语法"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"fun.call(thisArg, arg1, arg2, ...)\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"thisArg"}),"\n在",(0,c.jsx)(n.code,{children:"fun"}),"函数运行时指定的",(0,c.jsx)(n.code,{children:"this"}),"值。需要注意的是，指定的",(0,c.jsx)(n.code,{children:"this"}),"值并不一定是该函数执行时真正的",(0,c.jsx)(n.code,{children:"this"}),"值，如果这个函数处于",(0,c.jsx)(n.strong,{children:"非严格模式"}),"下，则指定为",(0,c.jsx)(n.code,{children:"null"}),"和",(0,c.jsx)(n.code,{children:"undefined"}),"的",(0,c.jsx)(n.code,{children:"this"}),"值会自动指向全局对象(浏览器中就是",(0,c.jsx)(n.code,{children:"window"}),"对象)，同时值为原始值(数字，字符串，布尔值)的",(0,c.jsx)(n.code,{children:"this"}),"会指向该原始值的自动包装对象。","\n",(0,c.jsx)(n.strong,{children:"arg1, arg2, ..."}),"\n指定的参数列表","\n",(0,c.jsx)(n.strong,{children:"返回值"}),"\n返回值是你调用的方法的返回值，若该方法没有返回值，则返回",(0,c.jsx)(n.code,{children:"undefined"}),"。","\n",(0,c.jsx)(n.code,{children:"apply"}),"和",(0,c.jsx)(n.code,{children:"call"}),"类似。只是参数不一样。它的参数是数组（或者类数组）。"]}),"\n",(0,c.jsxs)(n.p,{children:["根据参数",(0,c.jsx)(n.code,{children:"thisArg"}),"的描述，可以知道，",(0,c.jsx)(n.code,{children:"call"}),"就是改变函数中的",(0,c.jsx)(n.code,{children:"this"}),"指向为",(0,c.jsx)(n.code,{children:"thisArg"}),"，并且执行这个函数，这也就使",(0,c.jsx)(n.code,{children:"JS"}),"灵活很多。严格模式下，",(0,c.jsx)(n.code,{children:"thisArg"}),"是原始值是值类型，也就是原始值。不会被包装成对象。举个例子："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var doSth = function(name){\n    console.log(this);\n    console.log(name);\n}\ndoSth.call(2, '若川'); // Number{2}, '若川'\nvar doSth2 = function(name){\n    'use strict';\n    console.log(this);\n    console.log(name);\n}\ndoSth2.call(2, '若川'); // 2, '若川'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["虽然一般不会把",(0,c.jsx)(n.code,{children:"thisArg"}),"参数写成值类型。但还是需要知道这个知识。\n之前写过一篇文章：",(0,c.jsxs)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:["面试官问：能否模拟实现",(0,c.jsx)(n.code,{children:"JS"}),"的",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"方法"]}),"\n就是利用对象上的函数",(0,c.jsx)(n.code,{children:"this"}),"指向这个对象，来模拟实现",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"的。感兴趣的读者思考如何实现，再去看看笔者的实现。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"bind"}),"和",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"类似，第一个参数也是修改",(0,c.jsx)(n.code,{children:"this"}),"指向，只不过返回值是新函数，新函数也能当做构造函数（",(0,c.jsx)(n.code,{children:"new"}),"）调用。\n",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind",rel:"noopener noreferrer",target:"_blank",children:"MDN Function.prototype.bind"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"bind()"}),"方法创建一个新的函数， 当这个新函数被调用时",(0,c.jsx)(n.code,{children:"this"}),"键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。","\n",(0,c.jsx)(n.strong,{children:"语法："}),"\nfun.bind(thisArg[, arg1[, arg2[, ...]]])","\n",(0,c.jsx)(n.strong,{children:"参数："}),"\n",(0,c.jsx)(n.strong,{children:"thisArg"}),"\n调用绑定函数时作为this参数传递给目标函数的值。 如果使用",(0,c.jsx)(n.code,{children:"new"}),"运算符构造绑定函数，则忽略该值。当使用",(0,c.jsx)(n.code,{children:"bind"}),"在",(0,c.jsx)(n.code,{children:"setTimeout"}),"中创建一个函数（作为回调提供）时，作为",(0,c.jsx)(n.code,{children:"thisArg"}),"传递的任何原始值都将转换为",(0,c.jsx)(n.code,{children:"object"}),"。如果没有提供绑定的参数，则执行作用域的",(0,c.jsx)(n.code,{children:"this"}),"被视为新函数的",(0,c.jsx)(n.code,{children:"thisArg"}),"。\n",(0,c.jsx)(n.strong,{children:"arg1, arg2, ..."}),"\n当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。\n",(0,c.jsx)(n.strong,{children:"返回值"}),"\n返回由指定的",(0,c.jsx)(n.code,{children:"this"}),"值和初始化参数改造的原函数拷贝。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["之前也写过一篇文章：",(0,c.jsxs)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:["面试官问：能否模拟实现",(0,c.jsx)(n.code,{children:"JS"}),"的",(0,c.jsx)(n.code,{children:"bind"}),"方法"]}),"\n就是利用",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"指向这个",(0,c.jsx)(n.code,{children:"thisArg"}),"参数，来模拟实现",(0,c.jsx)(n.code,{children:"bind"}),"的。感兴趣的读者思考如何实现，再去看看笔者的实现。"]}),"\n",(0,c.jsxs)(n.h3,{id:"构造函数调用模式",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构造函数调用模式",children:"#"}),"构造函数调用模式"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Student(name){\n    this.name = name;\n    console.log(this); // {name: '若川'}\n    // 相当于返回了\n    // return this;\n}\nvar result = new Student('若川');\n"})}),"\n",(0,c.jsxs)(n.p,{children:["使用",(0,c.jsx)(n.code,{children:"new"}),"操作符调用函数，会自动执行以下步骤。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"创建了一个全新的对象。"}),"\n",(0,c.jsxs)(n.li,{children:["这个对象会被执行",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,c.jsx)(n.code,{children:"__proto__"}),"）链接。"]}),"\n",(0,c.jsxs)(n.li,{children:["生成的新对象会绑定到函数调用的",(0,c.jsx)(n.code,{children:"this"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:["通过",(0,c.jsx)(n.code,{children:"new"}),"创建的每个对象将最终被",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"链接到这个函数的",(0,c.jsx)(n.code,{children:"prototype"}),"对象上。"]}),"\n",(0,c.jsxs)(n.li,{children:["如果函数没有返回对象类型",(0,c.jsx)(n.code,{children:"Object"}),"(包含",(0,c.jsx)(n.code,{children:"Functoin"}),", ",(0,c.jsx)(n.code,{children:"Array"}),", ",(0,c.jsx)(n.code,{children:"Date"}),", ",(0,c.jsx)(n.code,{children:"RegExg"}),", ",(0,c.jsx)(n.code,{children:"Error"}),")，那么",(0,c.jsx)(n.code,{children:"new"}),"表达式中的函数调用会自动返回这个新的对象。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["由此可以知道：",(0,c.jsx)(n.code,{children:"new"}),"操作符调用时，",(0,c.jsx)(n.code,{children:"this"}),"指向生成的新对象。\n",(0,c.jsxs)(n.strong,{children:["特别提醒一下，",(0,c.jsx)(n.code,{children:"new"}),"调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象"]}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Student(name){\n    this.name = name;\n    // return function f(){};\n    // return {};\n}\nvar result = new Student('若川');\nconsole.log(result); {name: '若川'}\n// 如果返回函数f，则result是函数f，如果是对象{}，则result是对象{}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["很多人或者文章都忽略了这一点，直接简单用",(0,c.jsx)(n.code,{children:"typeof"}),"判断对象。虽然实际使用时不会显示返回，但面试官会问到。"]}),"\n",(0,c.jsxs)(n.p,{children:["之前也写了一篇文章",(0,c.jsxs)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:["面试官问：能否模拟实现",(0,c.jsx)(n.code,{children:"JS"}),"的",(0,c.jsx)(n.code,{children:"new"}),"操作符"]}),"，是使用apply来把this指向到生成的新生成的对象上。感兴趣的读者思考如何实现，再去看看笔者的实现。"]}),"\n",(0,c.jsxs)(n.h3,{id:"原型链中的调用模式",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链中的调用模式",children:"#"}),"原型链中的调用模式"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Student(name){\n    this.name = name;\n}\nvar s1 = new Student('若川');\nStudent.prototype.doSth = function(){\n    console.log(this.name);\n}\ns1.doSth(); // '若川'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["会发现这个似曾相识。这就是对象上的方法调用模式。自然是指向生成的新对象。\n如果该对象继承自其它对象。同样会通过原型链查找。\n上面代码使用\n",(0,c.jsx)(n.code,{children:"ES6"}),"中",(0,c.jsx)(n.code,{children:"class"}),"写法则是："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class Student{\n    constructor(name){\n        this.name = name;\n    }\n    doSth(){\n        console.log(this.name);\n    }\n}\nlet s1 = new Student('若川');\ns1.doSth();\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"babel"})," ",(0,c.jsx)(n.code,{children:"es6"}),"转换成",(0,c.jsx)(n.code,{children:"es5"}),"的结果，可以去",(0,c.jsx)(n.a,{href:"https://babeljs.io/",rel:"noopener noreferrer",target:"_blank",children:(0,c.jsx)(n.code,{children:"babeljs网站转换测试"})}),"自行试试。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Student = function () {\n    function Student(name) {\n        _classCallCheck(this, Student);\n\n        this.name = name;\n    }\n\n    _createClass(Student, [{\n        key: 'doSth',\n        value: function doSth() {\n            console.log(this.name);\n        }\n    }]);\n\n    return Student;\n}();\n\nvar s1 = new Student('若川');\ns1.doSth();\n"})}),"\n",(0,c.jsxs)(n.p,{children:["由此看出，",(0,c.jsx)(n.code,{children:"ES6"}),"的",(0,c.jsx)(n.code,{children:"class"}),"也是通过构造函数模拟实现的，是一种语法糖。"]}),"\n",(0,c.jsxs)(n.h3,{id:"箭头函数调用模式",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#箭头函数调用模式",children:"#"}),"箭头函数调用模式"]}),"\n",(0,c.jsx)(n.p,{children:"先看箭头函数和普通函数的重要区别："}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["1、没有自己的",(0,c.jsx)(n.code,{children:"this"}),"、",(0,c.jsx)(n.code,{children:"super"}),"、",(0,c.jsx)(n.code,{children:"arguments"}),"和",(0,c.jsx)(n.code,{children:"new.target"}),"绑定。\n2、不能使用",(0,c.jsx)(n.code,{children:"new"}),"来调用。\n3、没有原型对象。\n4、不可以改变",(0,c.jsx)(n.code,{children:"this"}),"的绑定。\n5、形参名称不能重复。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["箭头函数中没有",(0,c.jsx)(n.code,{children:"this"}),"绑定，必须通过查找作用域链来决定其值。\n如果箭头函数被非箭头函数包含，则",(0,c.jsx)(n.code,{children:"this"}),"绑定的是最近一层非箭头函数的",(0,c.jsx)(n.code,{children:"this"}),"，否则",(0,c.jsx)(n.code,{children:"this"}),"的值则被设置为全局对象。\n比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var name = 'window';\nvar student = {\n    name: '若川',\n    doSth: function(){\n        // var self = this;\n        var arrowDoSth = () => {\n            // console.log(self.name);\n            console.log(this.name);\n        }\n        arrowDoSth();\n    },\n    arrowDoSth2: () => {\n        console.log(this.name);\n    }\n}\nstudent.doSth(); // '若川'\nstudent.arrowDoSth2(); // 'window'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["其实就是相当于箭头函数外的",(0,c.jsx)(n.code,{children:"this"}),"是缓存的该箭头函数上层的普通函数的",(0,c.jsx)(n.code,{children:"this"}),"。如果没有普通函数，则是全局对象（浏览器中则是",(0,c.jsx)(n.code,{children:"window"}),"）。\n也就是说无法通过",(0,c.jsx)(n.code,{children:"call"}),"、",(0,c.jsx)(n.code,{children:"apply"}),"、",(0,c.jsx)(n.code,{children:"bind"}),"绑定箭头函数的",(0,c.jsx)(n.code,{children:"this"}),"(它自身没有",(0,c.jsx)(n.code,{children:"this"}),")。而",(0,c.jsx)(n.code,{children:"call"}),"、",(0,c.jsx)(n.code,{children:"apply"}),"、",(0,c.jsx)(n.code,{children:"bind"}),"可以绑定缓存箭头函数上层的普通函数的",(0,c.jsx)(n.code,{children:"this"}),"。\n比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var student = {\n    name: '若川',\n    doSth: function(){\n        console.log(this.name);\n        return () => {\n            console.log('arrowFn:', this.name);\n        }\n    }\n}\nvar person = {\n    name: 'person',\n}\nstudent.doSth().call(person); // '若川'  'arrowFn:' '若川'\nstudent.doSth.call(person)(); // 'person' 'arrowFn:' 'person'\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"dom事件处理函数调用",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dom事件处理函数调用",children:"#"}),(0,c.jsx)(n.code,{children:"DOM"}),"事件处理函数调用"]}),"\n",(0,c.jsxs)(n.h4,{id:"addeventerlistenerattacheventonclick",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#addeventerlistenerattacheventonclick",children:"#"}),"addEventerListener、attachEvent、onclick"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"<button class=\"button\">onclick</button>\n<ul class=\"list\">\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n</ul>\n<script>\n    var button = document.querySelector('button');\n    button.onclick = function(ev){\n        console.log(this);\n        console.log(this === ev.currentTarget); // true\n    }\n    var list = document.querySelector('.list');\n    list.addEventListener('click', function(ev){\n        console.log(this === list); // true\n        console.log(this === ev.currentTarget); // true\n        console.log(this);\n        console.log(ev.target);\n    }, false);\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"onclick"}),"和",(0,c.jsx)(n.code,{children:"addEventerListener"}),"是指向绑定事件的元素。\n一些浏览器，比如",(0,c.jsx)(n.code,{children:"IE6~IE8"}),"下使用",(0,c.jsx)(n.code,{children:"attachEvent"}),"，",(0,c.jsx)(n.code,{children:"this"}),"指向是",(0,c.jsx)(n.code,{children:"window"}),"。\n顺便提下：面试官也经常考察",(0,c.jsx)(n.code,{children:"ev.currentTarget"}),"和",(0,c.jsx)(n.code,{children:"ev.target"}),"的区别。\n",(0,c.jsx)(n.code,{children:"ev.currentTarget"}),"是绑定事件的元素，而",(0,c.jsx)(n.code,{children:"ev.target"}),"是当前触发事件的元素。比如这里的分别是",(0,c.jsx)(n.code,{children:"ul"}),"和",(0,c.jsx)(n.code,{children:"li"}),"。\n但也可能点击的是",(0,c.jsx)(n.code,{children:"ul"}),"，这时",(0,c.jsx)(n.code,{children:"ev.currentTarget"}),"和",(0,c.jsx)(n.code,{children:"ev.target"}),"就相等了。"]}),"\n",(0,c.jsxs)(n.h4,{id:"内联事件处理函数调用",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内联事件处理函数调用",children:"#"}),"内联事件处理函数调用"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'<button class="btn1" onclick="console.log(this === document.querySelector(\'.btn1\'))">点我呀</button>\n<button onclick="console.log((function(){return this})());">再点我呀</button>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["第一个是",(0,c.jsx)(n.code,{children:"button"}),"本身，所以是",(0,c.jsx)(n.code,{children:"true"}),"，第二个是",(0,c.jsx)(n.code,{children:"window"}),"。这里跟严格模式没有关系。\n当然我们现在不会这样用了，但有时不小心写成了这样，也需要了解。"]}),"\n",(0,c.jsxs)(n.p,{children:["其实",(0,c.jsx)(n.code,{children:"this"}),"的使用场景还有挺多，比如对象",(0,c.jsx)(n.code,{children:"object"}),"中的",(0,c.jsx)(n.code,{children:"getter"}),"、",(0,c.jsx)(n.code,{children:"setter"}),"的",(0,c.jsx)(n.code,{children:"this"}),"，",(0,c.jsx)(n.code,{children:"new Function()"}),"、",(0,c.jsx)(n.code,{children:"eval"}),"。\n但掌握以上几种，去分析其他的，就自然迎刃而解了。\n使用比较多的还是普通函数调用、对象的函数调用、",(0,c.jsx)(n.code,{children:"new"}),"调用、",(0,c.jsx)(n.code,{children:"call、apply、bind"}),"调用、箭头函数调用。\n那么他们的优先级是怎样的呢。"]}),"\n",(0,c.jsxs)(n.h3,{id:"优先级",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优先级",children:"#"}),"优先级"]}),"\n",(0,c.jsxs)(n.p,{children:["而箭头函数的",(0,c.jsx)(n.code,{children:"this"}),"是上层普通函数的",(0,c.jsx)(n.code,{children:"this"}),"或者是全局对象（浏览器中是",(0,c.jsx)(n.code,{children:"window"}),"），所以排除，不算优先级。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var name = 'window';\nvar person = {\n    name: 'person',\n}\nvar doSth = function(){\n    console.log(this.name);\n    return function(){\n        console.log('return:', this.name);\n    }\n}\nvar Student = {\n    name: '若川',\n    doSth: doSth,\n}\n// 普通函数调用\ndoSth(); // window\n// 对象上的函数调用\nStudent.doSth(); // '若川'\n// call、apply 调用\nStudent.doSth.call(person); // 'person'\nnew Student.doSth.call(person);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["试想一下，如果是",(0,c.jsx)(n.code,{children:"Student.doSth.call(person)"}),"先执行的情况下，那",(0,c.jsx)(n.code,{children:"new"}),"执行一个函数。是没有问题的。\n然而事实上，这代码是报错的。",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence",rel:"noopener noreferrer",target:"_blank",children:"运算符优先级"}),"是",(0,c.jsx)(n.code,{children:"new"}),"比点号低，所以是执行",(0,c.jsx)(n.code,{children:"new (Student.doSth.call)(person)"}),"\n而",(0,c.jsx)(n.code,{children:"Function.prototype.call"}),"，虽然是一个函数（",(0,c.jsx)(n.code,{children:"apply"}),"、",(0,c.jsx)(n.code,{children:"bind"}),"也是函数），跟箭头函数一样，不能用",(0,c.jsx)(n.code,{children:"new"}),"调用。所以报错了。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Uncaught TypeError: Student.doSth.call is not a constructor\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这是因为函数内部有两个不同的方法：",(0,c.jsx)(n.code,{children:"[[Call]]"}),"和",(0,c.jsx)(n.code,{children:"[[Constructor]]"}),"。\n当使用普通函数调用时，",(0,c.jsx)(n.code,{children:"[[Call]]"}),"会被执行。当使用构造函数调用时，",(0,c.jsx)(n.code,{children:"[[Constructor]]"}),"会被执行。",(0,c.jsx)(n.code,{children:"call"}),"、",(0,c.jsx)(n.code,{children:"apply"}),"、",(0,c.jsx)(n.code,{children:"bind"}),"和箭头函数内部没有",(0,c.jsx)(n.code,{children:"[[Constructor]]"}),"方法。"]}),"\n",(0,c.jsxs)(n.p,{children:["从上面的例子可以看出普通函数调用优先级最低，其次是对象上的函数。\n",(0,c.jsx)(n.code,{children:"call（apply、bind）"}),"调用方式和",(0,c.jsx)(n.code,{children:"new"}),"调用方式的优先级，在《你不知道的JavaScript》是对比",(0,c.jsx)(n.code,{children:"bind"}),"和",(0,c.jsx)(n.code,{children:"new"}),"，引用了",(0,c.jsx)(n.code,{children:"mdn"}),"的",(0,c.jsx)(n.code,{children:"bind"}),"的",(0,c.jsx)(n.code,{children:"ployfill"}),"实现，",(0,c.jsx)(n.code,{children:"new"}),"调用时bind之后的函数，会忽略",(0,c.jsx)(n.code,{children:"bind"}),"绑定的第一个参数，(",(0,c.jsx)(n.code,{children:"mdn"}),"的实现其实还有一些问题，感兴趣的读者，可以看我之前的文章：",(0,c.jsxs)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:["面试官问：能否模拟实现",(0,c.jsx)(n.code,{children:"JS"}),"的",(0,c.jsx)(n.code,{children:"bind"}),"方法"]}),")，说明",(0,c.jsx)(n.code,{children:"new"}),"的调用的优先级最高。\n所以它们的优先级是",(0,c.jsx)(n.code,{children:"new"})," 调用 > ",(0,c.jsx)(n.code,{children:"call、apply、bind"})," 调用 > 对象上的函数调用 > 普通函数调用。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,c.jsxs)(n.p,{children:["如果要判断一个运行中函数的 ",(0,c.jsx)(n.code,{children:"this"})," 绑定， 就需要找到这个函数的直接调用位置。 找到之后\n就可以顺序应用下面这四条规则来判断 ",(0,c.jsx)(n.code,{children:"this"})," 的绑定对象。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"new"})," 调用：绑定到新创建的对象，注意：显示",(0,c.jsx)(n.code,{children:"return"}),"函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"call"})," 或者 ",(0,c.jsx)(n.code,{children:"apply"}),"（ 或者 ",(0,c.jsx)(n.code,{children:"bind"}),"） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，",(0,c.jsx)(n.code,{children:"null"}),"和",(0,c.jsx)(n.code,{children:"undefined"}),"，指向全局对象（浏览器中是",(0,c.jsx)(n.code,{children:"window"}),"），其余值指向被",(0,c.jsx)(n.code,{children:"new Object()"}),"包装的对象。"]}),"\n",(0,c.jsx)(n.li,{children:"对象上的函数调用：绑定到那个对象。"}),"\n",(0,c.jsxs)(n.li,{children:["普通函数调用： 在严格模式下绑定到 ",(0,c.jsx)(n.code,{children:"undefined"}),"，否则绑定到全局对象。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ES6"})," 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定",(0,c.jsx)(n.code,{children:"this"}),"， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是",(0,c.jsx)(n.code,{children:"window"}),"）。 这其实和 ",(0,c.jsx)(n.code,{children:"ES6"})," 之前代码中的 ",(0,c.jsx)(n.code,{children:"self = this"})," 机制一样。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"DOM"}),"事件函数：一般指向绑定事件的",(0,c.jsx)(n.code,{children:"DOM"}),"元素，但有些情况绑定到全局对象（比如",(0,c.jsx)(n.code,{children:"IE6~IE8"}),"的",(0,c.jsx)(n.code,{children:"attachEvent"}),"）。"]}),"\n",(0,c.jsxs)(n.p,{children:["一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 ",(0,c.jsx)(n.code,{children:"this"})," 绑\n定， 你可以使用一个对象， 比如",(0,c.jsx)(n.code,{children:" \xf8 = Object.create(null)"}),"， 以保护全局对象。"]}),"\n",(0,c.jsxs)(n.p,{children:["面试官考察",(0,c.jsx)(n.code,{children:"this"}),"指向就可以考察",(0,c.jsx)(n.code,{children:"new、call、apply、bind"}),"，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的原因。"]}),"\n",(0,c.jsx)(n.p,{children:"读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。"}),"\n",(0,c.jsxs)(n.h2,{id:"考题",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#考题",children:"#"}),"考题"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"this"}),"指向考题经常结合一些运算符等来考察。看完本文，不妨通过以下两篇面试题测试一下。","\n",(0,c.jsx)(n.a,{href:"https://www.cnblogs.com/xxcanghai/p/5189353.html",rel:"noopener noreferrer",target:"_blank",children:"小小沧海：一道常被人轻视的前端JS面试题"}),"\n",(0,c.jsx)(n.a,{href:"https://segmentfault.com/a/1190000010981003",rel:"noopener noreferrer",target:"_blank",children:"从这两套题，重新认识JS的this、作用域、闭包、对象"})]}),"\n",(0,c.jsxs)(n.h2,{id:"扩展阅读",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"}),"扩展阅读"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md",rel:"noopener noreferrer",target:"_blank",children:"你不知道的JavaScript 上卷"}),"\n",(0,c.jsx)(n.a,{href:"https://github.com/mqyqingfeng/Blog/issues/7",rel:"noopener noreferrer",target:"_blank",children:"冴羽：JavaScript深入之从ECMAScript规范解读this"}),"\n",(0,c.jsx)(n.a,{href:"https://www.jianshu.com/p/d647aa6d1ae6",rel:"noopener noreferrer",target:"_blank",children:"这波能反杀：前端基础进阶（五）：全方位解读this"})]}),"\n",(0,c.jsxs)(n.h2,{id:"关于",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,c.jsxs)(n.p,{children:["作者：常以",(0,c.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,c.jsx)(n.a,{href:"https://ruochuan12.github.io/",rel:"noopener noreferrer",target:"_blank",children:"个人博客"}),"\n",(0,c.jsx)(n.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,c.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,c.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，开通了",(0,c.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,c.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，开通了",(0,c.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,c.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,c.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,c.jsxs)(n.h2,{id:"微信公众号--若川视野",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,c.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ",(0,c.jsx)(n.code,{children:"ruochuan12"}),"，注明来源，拉您进【前端视野交流群】。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{alt:"若川视野",src:i})})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,Object.assign({},e,{children:(0,c.jsx)(l,e)})):l(e)}let t=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["js-this%2Findex.md"]={toc:[{id:"前言",text:"前言",depth:2},{id:"全局上下文",text:"全局上下文",depth:2},{id:"函数上下文",text:"函数上下文",depth:2},{id:"普通函数调用模式",text:"普通函数调用模式",depth:3},{id:"对象中的函数方法调用模式",text:"对象中的函数（方法）调用模式",depth:3},{id:"callapplybind-调用模式",text:"`call、apply、bind` 调用模式",depth:3},{id:"构造函数调用模式",text:"构造函数调用模式",depth:3},{id:"原型链中的调用模式",text:"原型链中的调用模式",depth:3},{id:"箭头函数调用模式",text:"箭头函数调用模式",depth:3},{id:"dom事件处理函数调用",text:"`DOM`事件处理函数调用",depth:3},{id:"addeventerlistenerattacheventonclick",text:"addEventerListener、attachEvent、onclick",depth:4},{id:"内联事件处理函数调用",text:"内联事件处理函数调用",depth:4},{id:"优先级",text:"优先级",depth:3},{id:"总结",text:"总结",depth:2},{id:"考题",text:"考题",depth:2},{id:"扩展阅读",text:"扩展阅读",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"面试官问：JS的this指向",headingTitle:"面试官问：JS的this指向",frontmatter:{}}},20713:function(e,n,r){r.d(n,{Z:()=>o});var c=r(52676),d=r(75271),s=r(92815);r(18544);let i={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function l(e,n,r){let c=Object.keys(i).includes(n)?n:r;return i[c](e)}let o=e=>{let{defaultLocale:n="en-US"}=e,r=(0,s.Vi)().page.readingTimeData,i=(0,s.Jr)(),o=(0,s.e7)(),[t,h]=(0,d.useState)(l(r,i,n));return(0,d.useEffect)(()=>{h(l(r,i,n))},[i,r]),(0,c.jsx)("span",{"data-dark":String(o),className:"rp-reading-time",children:t})}}}]);