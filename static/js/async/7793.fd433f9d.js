"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["7793"],{69761:function(e,n,t){t.r(n),t.d(n,{default:()=>h});var s=t(52676),r=t(40453),a=t(20713);let c=t.p+"static/image/vuex-object.c0077c0e.png",o=t.p+"static/image/vuex-store.instance.b8b738ec.png",i=t.p+"static/image/vuex-store-module-collection-instance.41d9b178.png";function l(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",code:"code",strong:"strong",pre:"pre",h3:"h3",img:"img",h4:"h4"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"学习-vuex-源码整体架构打造属于自己的状态管理库",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#学习-vuex-源码整体架构打造属于自己的状态管理库",children:"#"}),"学习 vuex 源码整体架构，打造属于自己的状态管理库"]}),"\n",(0,s.jsx)(a.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这是",(0,s.jsx)(n.code,{children:"学习源码整体架构"}),"第五篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章学习的是实际仓库的代码。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis.git",rel:"noopener noreferrer",target:"_blank",children:"本文仓库地址"}),"：",(0,s.jsx)(n.code,{children:"git clone https://github.com/ruochuan12/vuex-analysis.git"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"文章如下："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d39d2cbf265da1bc23fbd42",rel:"noopener noreferrer",target:"_blank",children:"学习 jQuery 源码整体架构，打造属于自己的 js 类库"}),"\n2.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d4bf94de51d453bb13b65dc",rel:"noopener noreferrer",target:"_blank",children:"学习 underscore 源码整体架构，打造属于自己的函数式编程类库"}),"\n3.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d767e1d6fb9a06b032025ea",rel:"noopener noreferrer",target:"_blank",children:"学习 lodash 源码整体架构，打造属于自己的函数式编程类库"}),"\n4.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dba5a39e51d452a2378348a",rel:"noopener noreferrer",target:"_blank",children:"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK"}),"\n5.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dd4e61a6fb9a05a5c010af0",rel:"noopener noreferrer",target:"_blank",children:"学习 vuex 源码整体架构，打造属于自己的状态管理库"}),"\n6.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5df349b5518825123751ba66",rel:"noopener noreferrer",target:"_blank",children:"学习 axios 源码整体架构，打造属于自己的请求库"}),"\n7.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5e69925cf265da571e262fe6",rel:"noopener noreferrer",target:"_blank",children:"学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理"}),"\n8.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5ee63b7d51882542fc6265ad",rel:"noopener noreferrer",target:"_blank",children:"学习 redux 源码整体架构，深入理解 redux 及其中间件原理"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["感兴趣的读者可以点击阅读。","\n其他源码计划中的有：",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/express-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"express"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vue-router-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-rotuer"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/react-redux-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"react-redux"})})," 等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。"]}),"\n",(0,s.jsxs)(n.p,{children:["源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。","\n所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"导读"}),"\n文章比较详细的介绍了",(0,s.jsx)(n.code,{children:"vuex"}),"、",(0,s.jsx)(n.code,{children:"vue"}),"源码调试方法和 ",(0,s.jsx)(n.code,{children:"Vuex"})," 原理。并且详细介绍了 ",(0,s.jsx)(n.code,{children:"Vuex.use"})," 安装和 ",(0,s.jsx)(n.code,{children:"new Vuex.Store"})," 初始化、",(0,s.jsx)(n.code,{children:"Vuex.Store"})," 的全部",(0,s.jsx)(n.code,{children:"API"}),"（如",(0,s.jsx)(n.code,{children:"dispatch"}),"、",(0,s.jsx)(n.code,{children:"commit"}),"等）的实现和辅助函数 ",(0,s.jsx)(n.code,{children:"mapState"}),"、",(0,s.jsx)(n.code,{children:"mapGetters"}),"、 ",(0,s.jsx)(n.code,{children:"mapActions"}),"、",(0,s.jsx)(n.code,{children:"mapMutations"}),"\n",(0,s.jsx)(n.code,{children:"createNamespacedHelpers"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-chrome-浏览器调试-vuex-源码方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-chrome-浏览器调试-vuex-源码方法",children:"#"}),"2. chrome 浏览器调试 vuex 源码方法"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html",rel:"noopener noreferrer",target:"_blank",children:"Vue文档：在 VS Code 中调试 Vue 项目"}),"\n从上文中同理可得调试 ",(0,s.jsx)(n.code,{children:"vuex"})," 方法，这里详细说下，便于帮助到可能不知道如何调试源码的读者。","\n可以把笔者的这个 ",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis",rel:"noopener noreferrer",target:"_blank",children:"vuex-analysis"})," 源码分析仓库",(0,s.jsx)(n.code,{children:"fork"}),"一份或者直接克隆下来，\n",(0,s.jsx)(n.code,{children:"git clone https://github.com/ruochuan12/vuex-analysis.git"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["其中文件夹",(0,s.jsx)(n.code,{children:"vuex"}),"，是克隆官方的",(0,s.jsx)(n.code,{children:"vuex"}),"仓库 ",(0,s.jsx)(n.code,{children:"dev"}),"分支。","\n截至目前（2019年11月），版本是",(0,s.jsx)(n.code,{children:"v3.1.2"}),"，最后一次",(0,s.jsx)(n.code,{children:"commit"}),"是",(0,s.jsx)(n.code,{children:"ba2ff3a3"}),"，",(0,s.jsx)(n.code,{children:"2019-11-11 11:51 Ben Hutton"}),"。","\n包含笔者的注释，便于理解。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["克隆完成后， 在",(0,s.jsx)(n.code,{children:"vuex/examples/webpack.config.js"})," 中添加",(0,s.jsx)(n.code,{children:"devtool"}),"配置。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 新增devtool配置，便于调试\ndevtool: 'source-map',\noutput: {}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/ruochuan12/vuex-analysis.git\ncd vuex\nnpm i\nnpm run dev\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["打开 ",(0,s.jsx)(n.a,{href:"http://localhost:8080/",rel:"noopener noreferrer",target:"_blank",children:"http://localhost:8080/"}),"\n点击你想打开的例子，例如：Shopping Cart => ",(0,s.jsx)(n.a,{href:"http://localhost:8080/shopping-cart/",rel:"noopener noreferrer",target:"_blank",children:"http://localhost:8080/shopping-cart/"}),"\n打开控制面板 source 在左侧找到 webapck//  .  src 目录 store 文件 根据自己需求断点调试即可。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["本文主要就是通过",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis/blob/master/vuex/examples/shopping-cart/app.js",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"Shopping Cart"})}),"，(路径",(0,s.jsx)(n.code,{children:"vuex/examples/shopping-cart"}),")例子调试代码的。"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-顺便提一下调试-vue-源码v2610的方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-顺便提一下调试-vue-源码v2610的方法",children:"#"}),"2.1 顺便提一下调试 vue 源码（v2.6.10）的方法"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/vuejs/vue.git\n"})}),"\n",(0,s.jsxs)(n.p,{children:["克隆下来后将",(0,s.jsx)(n.code,{children:"package.json"})," 文件中的",(0,s.jsx)(n.code,{children:"script"})," ",(0,s.jsx)(n.code,{children:"dev"}),"命令后面添加这个 ",(0,s.jsx)(n.code,{children:"--sourcemap"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev --sourcemap"\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/vuejs/vue.git\ncd vue\nnpm i\n# 在 dist/vue.js 最后一行追加一行 //# sourceMappingURL=vue.js.map\nnpm run dev\n# 新终端窗口\n# 根目录下 全局安装http-server(一行命令启动服务的工具)\nnpm i -g http-server\nhs -p 8100\n\n# 在examples 文件夹中把引用的vuejs的index.html 文件 vue.min.js 改为 vue.js\n# 或者把dist文件夹的 vue.min.js ，替换成npm run dev编译后的dist/vue.js\n\n# 浏览器打开 open http://localhost:8100/examples/\n\n# 打开控制面板 source 在左侧找到  src 目录 即vue.js源码文件 根据自己需求断点调试即可。\n"})}),"\n",(0,s.jsxs)(n.p,{children:["本小节大篇幅介绍调试方法。是因为真的很重要。会调试代码，看源码就比较简单了。关注主线调试代码，很容易看懂。","\n",(0,s.jsx)(n.strong,{children:"强烈建议克隆笔者的这个仓库，自己调试代码，对着注释看，不调试代码，只看文章不容易吸收消化"}),"。","\n笔者也看了文章末尾笔者推荐阅读的文章，但还是需要自己看源代码，才知道这些文章哪里写到了，哪里没有细写。 "]}),"\n",(0,s.jsx)(n.p,{children:"正文开始～"}),"\n",(0,s.jsxs)(n.h2,{id:"3-vuex-原理",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-vuex-原理",children:"#"}),"3. vuex 原理"]}),"\n",(0,s.jsxs)(n.p,{children:["简单说明下 ",(0,s.jsx)(n.code,{children:"vuex"})," 原理"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"<template>\n<div>\n  count {{$store.state.count}}\n</div>\n</template>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["每个组件（也就是",(0,s.jsx)(n.code,{children:"Vue实例"}),"）在",(0,s.jsx)(n.code,{children:"beforeCreate"}),"的生命周期中都混入（Vue.mixin）同一个",(0,s.jsx)(n.code,{children:"Store实例"})," 作为属性 ",(0,s.jsx)(n.code,{children:"$store"}),"，\n也就是为啥可以通过 ",(0,s.jsx)(n.code,{children:"this.$store.dispatch"})," 等调用方法的原因。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后显示在模板里的\n",(0,s.jsx)(n.code,{children:"$store.state.count"}),"\n源码是这样的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Store{\n  get state () {\n    return this._vm._data.$$state\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其实就是：\n",(0,s.jsx)(n.code,{children:"vm.$store._vm._data.$$state.count"}),"\n其中",(0,s.jsx)(n.code,{children:"vm.$store._vm._data.$$state"})," 是 响应式的。\n怎么实现响应式的？其实就是",(0,s.jsx)(n.code,{children:"new Vue()"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function resetStoreVM (store, state, hot) {\n  //  省略若干代码\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  //  省略若干代码\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里的 ",(0,s.jsx)(n.code,{children:"state"})," 就是 用户定义的 ",(0,s.jsx)(n.code,{children:"state"}),"。\n这里的 ",(0,s.jsx)(n.code,{children:"computed"})," 就是处理后的用户定义的 ",(0,s.jsx)(n.code,{children:"getters"}),"。\n而 ",(0,s.jsx)(n.code,{children:"class Store"}),"上的一些函数（API）主要都是围绕修改",(0,s.jsx)(n.code,{children:"vm.$store._vm._data.$$state"}),"和",(0,s.jsx)(n.code,{children:"computed(getter)"}),"服务的。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-vueuse-安装",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-vueuse-安装",children:"#"}),"3. Vue.use 安装"]}),"\n",(0,s.jsxs)(n.p,{children:["笔者画了一张图表示下",(0,s.jsx)(n.code,{children:"Vuex"}),"对象，是",(0,s.jsx)(n.code,{children:"Vue"}),"的一个插件。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Vuex 对象关系图",src:c})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["看到这里，恭喜你已经了解了",(0,s.jsx)(n.code,{children:"Vuex"}),"原理。文章比较长，如果暂时不想关注源码细节，可以克隆一下本仓库代码",(0,s.jsx)(n.code,{children:"git clone https://github.com/ruochuan12/vuex-analysis.git"}),"，后续调试代码，点赞收藏到时想看了再看。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://cn.vuejs.org/v2/api/#Vue-use",rel:"noopener noreferrer",target:"_blank",children:"文档 Vue.use"}),"\n",(0,s.jsx)(n.code,{children:"Vue.use(Vuex)"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["参数：\n{Object | Function} plugin\n用法：","\n安装 Vue.js 插件。如果插件是一个对象，必须提供 ",(0,s.jsx)(n.code,{children:"install"})," 方法。如果插件是一个函数，它会被作为 ",(0,s.jsx)(n.code,{children:"install"})," 方法。",(0,s.jsx)(n.code,{children:"install"})," 方法调用时，会将 Vue 作为参数传入。","\n该方法需要在调用 ",(0,s.jsx)(n.code,{children:"new Vue()"})," 之前被调用。","\n当 ",(0,s.jsx)(n.code,{children:"install"})," 方法被同一个插件多次调用，插件将只会被安装一次。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["根据断点调试，来看下",(0,s.jsx)(n.code,{children:"Vue.use"}),"的源码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    // 如果已经存在，则直接返回this也就是Vue\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    // 把 this（也就是Vue）作为数组的第一项\n    args.unshift(this);\n    // 如果插件的install属性是函数,调用它\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      // 如果插件是函数,则调用它\n      // apply(null) 严格模式下 plugin 插件函数的 this 就是 null\n      plugin.apply(null, args);\n    }\n    // 添加到已安装的插件\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"31-install-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-install-函数",children:"#"}),"3.1 install 函数"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"vuex/src/store.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function install (_Vue) {\n  // Vue 已经存在并且相等，说明已经Vuex.use过\n  if (Vue && _Vue === Vue) {\n    // 省略代码：非生产环境报错，vuex已经安装\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来看 ",(0,s.jsx)(n.code,{children:"applyMixin"})," 函数"]}),"\n",(0,s.jsxs)(n.h3,{id:"32-applymixin-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-applymixin-函数",children:"#"}),"3.2 applyMixin 函数"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"vuex/src/mixin.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default function (Vue) {\n  // Vue 版本号\n  const version = Number(Vue.version.split('.')[0])\n  if (version >= 2) {\n    // 合并选项后 beforeCreate 是数组里函数的形式  [ƒ,  ƒ]\n    // 最后调用循环遍历这个数组，调用这些函数，这是一种函数与函数合并的解决方案。\n    // 假设是我们自己来设计，会是什么方案呢。\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // 省略1.x的版本代码 ...\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    // store 注入到每一个Vue的实例中\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最终每个",(0,s.jsx)(n.code,{children:"Vue"}),"的实例对象，都有一个",(0,s.jsx)(n.code,{children:"$store"}),"属性。且是同一个",(0,s.jsx)(n.code,{children:"Store"}),"实例。","\n用购物车的例子来举例就是："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const vm = new Vue({\n  el: '#app',\n  store,\n  render: h => h(App)\n})\nconsole.log('vm.$store === vm.$children[0].$store', vm.$store === vm.$children[0].$store)\n// true\nconsole.log('vm.$store === vm.$children[0].$children[0].$store', vm.$store === vm.$children[0].$children[0].$store)\n// true\nconsole.log('vm.$store === vm.$children[0].$children[1].$store', vm.$store === vm.$children[0].$children[1].$store)\n// true\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"4-vuexstore-构造函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-vuexstore-构造函数",children:"#"}),"4. Vuex.Store 构造函数"]}),"\n",(0,s.jsxs)(n.p,{children:["先看最终 ",(0,s.jsx)(n.code,{children:"new Vuex.Store"})," 之后的 ",(0,s.jsx)(n.code,{children:"Store"})," 实例对象关系图：先大致有个印象。\n",(0,s.jsx)(n.img,{alt:"new Vuex.Store之后的 Store 实例对象关系图",src:o})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export class Store {\n  constructor (options = {}) {\n    // 这个构造函数比较长，这里省略，后文分开细述\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (!Vue && typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果是 ",(0,s.jsx)(n.code,{children:"cdn script"})," 方式引入",(0,s.jsx)(n.code,{children:"vuex"}),"插件，则自动安装",(0,s.jsx)(n.code,{children:"vuex"}),"插件，不需要用",(0,s.jsx)(n.code,{children:"Vue.use(Vuex)"}),"来安装。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// asset 函数实现\nexport function assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (process.env.NODE_ENV !== 'production') {\n  // 可能有读者会问：为啥不用 console.assert，console.assert 函数报错不会阻止后续代码执行\n  assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n  assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n  assert(this instanceof Store, `store must be called with the new operator.`)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"条件断言：不满足直接抛出错误"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.必须使用 ",(0,s.jsx)(n.code,{children:"Vue.use(Vuex)"})," 创建 ",(0,s.jsx)(n.code,{children:"store"})," 实例。","\n2.当前环境不支持",(0,s.jsx)(n.code,{children:"Promise"}),"，报错：",(0,s.jsx)(n.code,{children:"vuex"})," 需要 ",(0,s.jsx)(n.code,{children:"Promise polyfill"}),"。","\n3.",(0,s.jsx)(n.code,{children:"Store"})," 函数必须使用 ",(0,s.jsx)(n.code,{children:"new"})," 操作符调用。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  // 插件默认是空数组\n  plugins = [],\n  // 严格模式默认是false\n  strict = false\n} = options\n"})}),"\n",(0,s.jsxs)(n.p,{children:["从用户定义的",(0,s.jsx)(n.code,{children:"new Vuex.Store(options)"}),"\n取出",(0,s.jsx)(n.code,{children:"plugins"}),"和",(0,s.jsx)(n.code,{children:"strict"}),"参数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// store internal state\n// store 实例对象 内部的 state\nthis._committing = false\n// 用来存放处理后的用户自定义的actoins\nthis._actions = Object.create(null)\n// 用来存放 actions 订阅\nthis._actionSubscribers = []\n// 用来存放处理后的用户自定义的mutations\nthis._mutations = Object.create(null)\n// 用来存放处理后的用户自定义的 getters\nthis._wrappedGetters = Object.create(null)\n// 模块收集器，构造模块树形结构\nthis._modules = new ModuleCollection(options)\n// 用于存储模块命名空间的关系\nthis._modulesNamespaceMap = Object.create(null)\n// 订阅\nthis._subscribers = []\n// 用于使用 $watch 观测 getters\nthis._watcherVM = new Vue()\n// 用来存放生成的本地 getters 的缓存\nthis._makeLocalGettersCache = Object.create(null)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["声明",(0,s.jsx)(n.code,{children:"Store"}),"实例对象一些内部变量。用于存放处理后用户自定义的",(0,s.jsx)(n.code,{children:"actions"}),"、",(0,s.jsx)(n.code,{children:"mutations"}),"、",(0,s.jsx)(n.code,{children:"getters"}),"等变量。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提一下 ",(0,s.jsx)(n.code,{children:"Object.create(null)"})," 和 ",(0,s.jsx)(n.code,{children:"{}"})," 的区别。前者没有原型链，后者有。\n即 ",(0,s.jsx)(n.code,{children:"Object.create(null).__proto__"}),"是 ",(0,s.jsx)(n.code,{children:"undefined"}),"\n",(0,s.jsx)(n.code,{children:"({}).__proto__"})," 是 ",(0,s.jsx)(n.code,{children:"Object.prototype"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["给自己 绑定 ",(0,s.jsx)(n.code,{children:"commit"})," 和 ",(0,s.jsx)(n.code,{children:"dispatch"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["为何要这样绑定 ?","\n说明调用 ",(0,s.jsx)(n.code,{children:"commit"})," 和 ",(0,s.jsx)(n.code,{children:"dispach"})," 的 ",(0,s.jsx)(n.code,{children:"this"})," 不一定是 ",(0,s.jsx)(n.code,{children:"store"})," 实例","\n这是确保这两个函数里的 ",(0,s.jsx)(n.code,{children:"this"})," 是 ",(0,s.jsx)(n.code,{children:"store"})," 实例"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 严格模式，默认是false\nthis.strict = strict\n// 根模块的state\nconst state = this._modules.root.state\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述这段代码\n",(0,s.jsx)(n.code,{children:"installModule(this, state, [], this._modules.root)"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["初始化 根模块。","\n并且也递归的注册所有子模块。","\n并且收集所有模块的 ",(0,s.jsx)(n.code,{children:"getters"})," 放在 ",(0,s.jsx)(n.code,{children:"this._wrappedGetters"})," 里面。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"resetStoreVM(this, state)"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["初始化 ",(0,s.jsx)(n.code,{children:"store._vm"})," 响应式的","\n并且注册 ",(0,s.jsx)(n.code,{children:"_wrappedGetters"})," 作为 ",(0,s.jsx)(n.code,{children:"computed"})," 的属性"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"plugins.forEach(plugin => plugin(this))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["插件：把实例对象 ",(0,s.jsx)(n.code,{children:"store"})," 传给插件函数，执行所有插件。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools\nif (useDevtools) {\n  devtoolPlugin(this)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["初始化 ",(0,s.jsx)(n.code,{children:"vue-devtool"})," 开发工具。","\n参数 ",(0,s.jsx)(n.code,{children:"devtools"})," 传递了取 ",(0,s.jsx)(n.code,{children:"devtools"})," 否则取",(0,s.jsx)(n.code,{children:"Vue.config.devtools"})," 配置。"]}),"\n",(0,s.jsx)(n.p,{children:"初读这个构造函数的全部源代码。会发现有三个地方需要重点看。分别是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this._modules = new ModuleCollection(options)\ninstallModule(this, state, [], this._modules.root)\nresetStoreVM(this, state)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["阅读时可以断点调试，赋值语句",(0,s.jsx)(n.code,{children:"this._modules = new ModuleCollection(options)"}),"，如果暂时不想看，可以直接看返回结果。",(0,s.jsx)(n.code,{children:"installModule"}),"，",(0,s.jsx)(n.code,{children:"resetStoreVM"}),"函数则可以断点调试。"]}),"\n",(0,s.jsxs)(n.h3,{id:"41-class-modulecollection",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-class-modulecollection",children:"#"}),"4.1 class ModuleCollection"]}),"\n",(0,s.jsx)(n.p,{children:"收集模块，构造模块树结构。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注册根模块 参数 ",(0,s.jsx)(n.code,{children:"rawRootModule"})," 也就是 ",(0,s.jsx)(n.code,{children:"Vuex.Store"})," 的 ",(0,s.jsx)(n.code,{children:"options"})," 参数","\n未加工过的模块（用户自定义的），根模块"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default class ModuleCollection {\n  constructor (rawRootModule) {\n    // register root module (Vuex.Store options)\n    this.register([], rawRootModule, false)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n  * 注册模块\n  * @param {Array} path 路径\n  * @param {Object} rawModule 原始未加工的模块\n  * @param {Boolean} runtime runtime 默认是 true\n  */\nregister (path, rawModule, runtime = true) {\n  // 非生产环境 断言判断用户自定义的模块是否符合要求\n  if (process.env.NODE_ENV !== 'production') {\n    assertRawModule(path, rawModule)\n  }\n\n  const newModule = new Module(rawModule, runtime)\n  if (path.length === 0) {\n    this.root = newModule\n  } else {\n    const parent = this.get(path.slice(0, -1))\n    parent.addChild(path[path.length - 1], newModule)\n  }\n\n  // register nested modules\n  // 递归注册子模块\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, (rawChildModule, key) => {\n      this.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"411-class-module",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#411-class-module",children:"#"}),"4.1.1 class Module"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Base data struct for store's module, package with some attribute and method\n// store 的模块 基础数据结构，包括一些属性和方法\nexport default class Module {\n  constructor (rawModule, runtime) {\n    // 接收参数 runtime\n    this.runtime = runtime\n    // Store some children item\n    // 存储子模块\n    this._children = Object.create(null)\n    // Store the origin module object which passed by programmer\n    // 存储原始未加工的模块\n    this._rawModule = rawModule\n    // 模块 state\n    const rawState = rawModule.state\n\n    // Store the origin module's state\n    // 原始Store 可能是函数，也可能是是对象，是假值，则赋值空对象。\n    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["经过一系列的注册后，最后\n",(0,s.jsx)(n.code,{children:"this._modules = new ModuleCollection(options)"}),"\n",(0,s.jsx)(n.code,{children:"this._modules"})," 的值是这样的。\n笔者画了一张图表示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"ModuleCollection",src:i})}),"\n",(0,s.jsxs)(n.h3,{id:"42-installmodule-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-installmodule-函数",children:"#"}),"4.2 installModule 函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function installModule (store, rootState, path, module, hot) {\n  // 是根模块\n  const isRoot = !path.length\n  // 命名空间 字符串\n  const namespace = store._modules.getNamespace(path)\n  if (module.namespaced) {\n    // 省略代码： 模块命名空间map对象中已经有了，开发环境报错提示重复\n    // module 赋值给 _modulesNamespaceMap[namespace]\n    store._modulesNamespaceMap[namespace] = module\n  }\n  // ... 后续代码 移出来 待读解释\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"421-注册-state",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#421-注册-state",children:"#"}),"4.2.1 注册 state"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// set state\n// 不是根模块且不是热重载\nif (!isRoot && !hot) {\n  // 获取父级的state\n  const parentState = getNestedState(rootState, path.slice(0, -1))\n  // 模块名称\n  // 比如 cart\n  const moduleName = path[path.length - 1]\n  // state 注册\n  store._withCommit(() => {\n    // 省略代码：非生产环境 报错 模块 state 重复设置\n    Vue.set(parentState, moduleName, module.state)\n  })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"最后得到的是类似这样的结构且是响应式的数据 实例 Store.state 比如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  // 省略若干属性和方法\n  // 这里的 state 是只读属性 可搜索 get state 查看，上文写过\n  state: {\n    cart: {\n      checkoutStatus: null,\n      items: []\n    }\n }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const local = module.context = makeLocalContext(store, namespace, path)\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"module.context"})," 这个赋值主要是给 ",(0,s.jsx)(n.code,{children:"helpers"})," 中 ",(0,s.jsx)(n.code,{children:"mapState"}),"、",(0,s.jsx)(n.code,{children:"mapGetters"}),"、",(0,s.jsx)(n.code,{children:"mapMutations"}),"、",(0,s.jsx)(n.code,{children:"mapActions"}),"四个辅助函数使用的。","\n生成本地的dispatch、commit、getters和state。","\n主要作用就是抹平差异化，不需要用户再传模块参数。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"422-遍历注册-mutation",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#422-遍历注册-mutation",children:"#"}),"4.2.2 遍历注册 mutation"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.forEachMutation((mutation, key) => {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * 注册 mutation\n * @param {Object} store 对象\n * @param {String} type 类型\n * @param {Function} handler 用户自定义的函数\n * @param {Object} local local 对象\n */\nfunction registerMutation (store, type, handler, local) {\n  // 收集的所有的mutations找对应的mutation函数，没有就赋值空数组\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  // 最后 mutation\n  entry.push(function wrappedMutationHandler (payload) {\n    /**\n     * mutations: {\n     *    pushProductToCart (state, { id }) {\n     *        console.log(state);\n     *    }\n     * }\n     * 也就是为什么用户定义的 mutation 第一个参数是state的原因，第二个参数是payload参数\n     */\n    handler.call(store, local.state, payload)\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"423-遍历注册-action",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#423-遍历注册-action",children:"#"}),"4.2.3 遍历注册 action"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.forEachAction((action, key) => {\n  const type = action.root ? key : namespace + key\n  const handler = action.handler || action\n  registerAction(store, type, handler, local)\n})\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n* 注册 mutation\n* @param {Object} store 对象\n* @param {String} type 类型\n* @param {Function} handler 用户自定义的函数\n* @param {Object} local local 对象\n*/\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  // payload 是actions函数的第二个参数\n  entry.push(function wrappedActionHandler (payload) {\n    /**\n     * 也就是为什么用户定义的actions中的函数第一个参数有\n     *  { dispatch, commit, getters, state, rootGetters, rootState } 的原因\n     * actions: {\n     *    checkout ({ commit, state }, products) {\n     *        console.log(commit, state);\n     *    }\n     * }\n     */\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload)\n    /**\n     * export function isPromise (val) {\n        return val && typeof val.then === 'function'\n      }\n     * 判断如果不是Promise Promise 化，也就是为啥 actions 中处理异步函数\n        也就是为什么构造函数中断言不支持promise报错的原因\n        vuex需要Promise polyfill\n        assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n     */\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    // devtool 工具触发 vuex:error\n    if (store._devtoolHook) {\n      // catch 捕获错误\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        // 抛出错误\n        throw err\n      })\n    } else {\n      // 然后函数执行结果\n      return res\n    }\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"424-遍历注册-getter",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#424-遍历注册-getter",children:"#"}),"4.2.4 遍历注册 getter"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.forEachGetter((getter, key) => {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * 注册 getter\n * @param {Object} store  Store实例\n * @param {String} type 类型\n * @param {Object} rawGetter  原始未加工的 getter 也就是用户定义的 getter 函数\n * @examples  比如 cartProducts: (state, getters, rootState, rootGetters) => {}\n * @param {Object} local 本地 local 对象\n */\nfunction registerGetter (store, type, rawGetter, local) {\n  // 类型如果已经存在，报错：已经存在\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`[vuex] duplicate getter key: ${type}`)\n    }\n    return\n  }\n  // 否则：赋值\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    /**\n     * 这也就是为啥 getters 中能获取到  (state, getters, rootState, rootGetters)  这些值的原因\n     * getters = {\n     *      cartProducts: (state, getters, rootState, rootGetters) => {\n     *        console.log(state, getters, rootState, rootGetters);\n     *      }\n     * }\n     */\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"425-遍历注册-子模块",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#425-遍历注册-子模块",children:"#"}),"4.2.5 遍历注册 子模块"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.forEachChild((child, key) => {\n  installModule(store, rootState, path.concat(key), child, hot)\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"43-resetstorevm-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-resetstorevm-函数",children:"#"}),"4.3 resetStoreVM 函数"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"resetStoreVM(this, state, hot)"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["初始化 ",(0,s.jsx)(n.code,{children:"store._vm"})," 响应式的","\n并且注册 ",(0,s.jsx)(n.code,{children:"_wrappedGetters"})," 作为 ",(0,s.jsx)(n.code,{children:"computed"})," 的属性"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function resetStoreVM (store, state, hot) {\n\n  // 存储一份老的Vue实例对象 _vm\n  const oldVm = store._vm\n\n  // bind store public getters\n  // 绑定 store.getter\n  store.getters = {}\n  // reset local getters cache\n  // 重置 本地getters的缓存\n  store._makeLocalGettersCache = Object.create(null)\n  // 注册时收集的处理后的用户自定义的 wrappedGetters\n  const wrappedGetters = store._wrappedGetters\n  // 声明 计算属性 computed 对象\n  const computed = {}\n  // 遍历 wrappedGetters 赋值到 computed 上\n  forEachValue(wrappedGetters, (fn, key) => {\n    // use computed to leverage its lazy-caching mechanism\n    // direct inline function use will lead to closure preserving oldVm.\n    // using partial to return function with only arguments preserved in closure environment.\n    /**\n     * partial 函数\n     * 执行函数 返回一个新函数\n        export function partial (fn, arg) {\n          return function () {\n            return fn(arg)\n          }\n        }\n     */\n    computed[key] = partial(fn, store)\n    // getter 赋值 keys\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      // 可以枚举\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  // 使用一个 Vue 实例对象存储 state 树\n  // 阻止警告 用户添加的一些全局mixins\n\n  // 声明变量 silent 存储用户设置的静默模式配置\n  const silent = Vue.config.silent\n  // 静默模式开启\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  // 把存储的静默模式配置赋值回来\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  // 开启严格模式 执行这句\n  // 用 $watch 观测 state，只能使用 mutation 修改 也就是 _withCommit 函数\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  // 如果存在老的 _vm 实例\n  if (oldVm) {\n    // 热加载为 true\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      // 设置  oldVm._data.$$state = null\n      store._withCommit(() => {\n        oldVm._data.$$state = null\n      })\n    }\n    // 实例销毁\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["到此，构造函数源代码看完了，接下来看 ",(0,s.jsx)(n.code,{children:"Vuex.Store"})," 的 一些 ",(0,s.jsx)(n.code,{children:"API"})," 实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"5-vuexstore-实例方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-vuexstore-实例方法",children:"#"}),"5. Vuex.Store 实例方法"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://vuex.vuejs.org/zh/api/",rel:"noopener noreferrer",target:"_blank",children:"Vuex API 文档"})}),"\n",(0,s.jsxs)(n.h3,{id:"51-commit",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-commit",children:"#"}),"5.1 commit"]}),"\n",(0,s.jsxs)(n.p,{children:["提交 ",(0,s.jsx)(n.code,{children:"mutation"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"commit (_type, _payload, _options) {\n  // check object-style commit\n  // 统一成对象风格\n  const {\n    type,\n    payload,\n    options\n  } = unifyObjectStyle(_type, _payload, _options)\n\n  const mutation = { type, payload }\n  // 取出处理后的用户定义 mutation\n  const entry = this._mutations[type]\n  // 省略 非生产环境的警告代码 ...\n  this._withCommit(() => {\n    // 遍历执行\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n  // 订阅 mutation 执行\n  this._subscribers.forEach(sub => sub(mutation, this.state))\n\n  // 省略 非生产环境的警告代码 ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"commit"})," 支持多种方式。比如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"store.commit('increment', {\n  count: 10\n})\n// 对象提交方式\nstore.commit({\n  type: 'increment',\n  count: 10\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"unifyObjectStyle"}),"函数将参数统一，返回 ",(0,s.jsx)(n.code,{children:"{ type, payload, options }"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"52-dispatch",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-dispatch",children:"#"}),"5.2 dispatch"]}),"\n",(0,s.jsxs)(n.p,{children:["分发 ",(0,s.jsx)(n.code,{children:"action"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"dispatch (_type, _payload) {\n  // check object-style dispatch\n  // 获取到type和payload参数\n  const {\n    type,\n    payload\n  } = unifyObjectStyle(_type, _payload)\n\n  // 声明 action 变量 等于 type和payload参数\n  const action = { type, payload }\n  // 入口，也就是 _actions 集合\n  const entry = this._actions[type]\n  // 省略 非生产环境的警告代码 ...\n  try {\n    this._actionSubscribers\n      .filter(sub => sub.before)\n      .forEach(sub => sub.before(action, this.state))\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`[vuex] error in before action subscribers: `)\n      console.error(e)\n    }\n  }\n\n  const result = entry.length > 1\n    ? Promise.all(entry.map(handler => handler(payload)))\n    : entry[0](payload)\n\n  return result.then(res => {\n    try {\n      this._actionSubscribers\n        .filter(sub => sub.after)\n        .forEach(sub => sub.after(action, this.state))\n    } catch (e) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`[vuex] error in after action subscribers: `)\n        console.error(e)\n      }\n    }\n    return res\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"53-replacestate",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53-replacestate",children:"#"}),"5.3 replaceState"]}),"\n",(0,s.jsxs)(n.p,{children:["替换 ",(0,s.jsx)(n.code,{children:"store"})," 的根状态，仅用状态合并或时光旅行调试。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"replaceState (state) {\n  this._withCommit(() => {\n    this._vm._data.$$state = state\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"54-watch",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#54-watch",children:"#"}),"5.4 watch"]}),"\n",(0,s.jsx)(n.p,{children:"响应式地侦听 fn 的返回值，当值改变时调用回调函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * 观测某个值\n * @param {Function} getter 函数\n * @param {Function} cb 回调\n * @param {Object} options 参数对象\n */\nwatch (getter, cb, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof getter === 'function', `store.watch only accepts a function.`)\n  }\n  return this._watcherVM.$watch(() => getter(this.state, this.getters), cb, options)\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"55-subscribe",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#55-subscribe",children:"#"}),"5.5 subscribe"]}),"\n",(0,s.jsxs)(n.p,{children:["订阅 ",(0,s.jsx)(n.code,{children:"store"})," 的 ",(0,s.jsx)(n.code,{children:"mutation"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"subscribe (fn) {\n  return genericSubscribe(fn, this._subscribers)\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 收集订阅者\nfunction genericSubscribe (fn, subs) {\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn)\n  }\n  return () => {\n    const i = subs.indexOf(fn)\n    if (i > -1) {\n      subs.splice(i, 1)\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"56-subscribeaction",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#56-subscribeaction",children:"#"}),"5.6 subscribeAction"]}),"\n",(0,s.jsxs)(n.p,{children:["订阅 ",(0,s.jsx)(n.code,{children:"store"})," 的 ",(0,s.jsx)(n.code,{children:"action"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"subscribeAction (fn) {\n  const subs = typeof fn === 'function' ? { before: fn } : fn\n  return genericSubscribe(subs, this._actionSubscribers)\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"57-registermodule",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#57-registermodule",children:"#"}),"5.7 registerModule"]}),"\n",(0,s.jsx)(n.p,{children:"注册一个动态模块。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * 动态注册模块\n * @param {Array|String} path 路径\n * @param {Object} rawModule 原始未加工的模块\n * @param {Object} options 参数选项\n */\nregisterModule (path, rawModule, options = {}) {\n  // 如果 path 是字符串，转成数组\n  if (typeof path === 'string') path = [path]\n\n  // 省略 非生产环境 报错代码\n\n  // 手动调用 模块注册的方法\n  this._modules.register(path, rawModule)\n  // 安装模块\n  installModule(this, this.state, path, this._modules.get(path), options.preserveState)\n  // reset store to update getters...\n  // 设置 resetStoreVM\n  resetStoreVM(this, this.state)\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"58-unregistermodule",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#58-unregistermodule",children:"#"}),"5.8 unregisterModule"]}),"\n",(0,s.jsx)(n.p,{children:"卸载一个动态模块。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * 注销模块\n * @param {Array|String} path 路径\n */\nunregisterModule (path) {\n  // 如果 path 是字符串，转成数组\n  if (typeof path === 'string') path = [path]\n\n  // 省略 非生产环境 报错代码 ...\n\n  // 手动调用模块注销\n  this._modules.unregister(path)\n  this._withCommit(() => {\n    // 注销这个模块\n    const parentState = getNestedState(this.state, path.slice(0, -1))\n    Vue.delete(parentState, path[path.length - 1])\n  })\n  // 重置 Store\n  resetStore(this)\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"59-hotupdate",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#59-hotupdate",children:"#"}),"5.9 hotUpdate"]}),"\n",(0,s.jsxs)(n.p,{children:["热替换新的 ",(0,s.jsx)(n.code,{children:"action"})," 和 ",(0,s.jsx)(n.code,{children:"mutation"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 热加载\nhotUpdate (newOptions) {\n  // 调用的是 ModuleCollection 的 update 方法，最终调用对应的是每个 Module 的 update\n  this._modules.update(newOptions)\n  // 重置 Store\n  resetStore(this, true)\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"6-组件绑定的辅助函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-组件绑定的辅助函数",children:"#"}),"6. 组件绑定的辅助函数"]}),"\n",(0,s.jsxs)(n.p,{children:["文件路径：",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis/blob/master/vuex/src/helpers.js",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vuex/src/helpers.js"})})]}),"\n",(0,s.jsxs)(n.h3,{id:"61-mapstate",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-mapstate",children:"#"}),"6.1 mapState"]}),"\n",(0,s.jsxs)(n.p,{children:["为组件创建计算属性以返回 ",(0,s.jsx)(n.code,{children:"Vuex store"})," 中的状态。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const mapState = normalizeNamespace((namespace, states) => {\n  const res = {}\n  // 非生产环境 判断参数 states  必须是数组或者是对象\n  if (process.env.NODE_ENV !== 'production' && !isValidMap(states)) {\n    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object')\n  }\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = function mappedState () {\n      let state = this.$store.state\n      let getters = this.$store.getters\n      // 传了参数 namespace\n      if (namespace) {\n        // 用 namespace 从 store 中找一个模块。\n        const module = getModuleByNamespace(this.$store, 'mapState', namespace)\n        if (!module) {\n          return\n        }\n        state = module.context.state\n        getters = module.context.getters\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    }\n    // 标记为 vuex 方便在 devtools 显示\n    // mark vuex getter for devtools\n    res[key].vuex = true\n  })\n  return res\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"normalizeNamespace 标准化统一命名空间"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function normalizeNamespace (fn) {\n  return (namespace, map) => {\n    // 命名空间没传，交换参数，namespace 为空字符串\n    if (typeof namespace !== 'string') {\n      map = namespace\n      namespace = ''\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      // 如果是字符串，最后一个字符不是 / 添加 /\n      // 因为 _modulesNamespaceMap 存储的是这样的结构。\n      /**\n       * _modulesNamespaceMap:\n          cart/: {}\n          products/: {}\n        }\n       * */\n      namespace += '/'\n    }\n    return fn(namespace, map)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 校验是否是map 是数组或者是对象。\nfunction isValidMap (map) {\n  return Array.isArray(map) || isObject(map)\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Normalize the map\n * 标准化统一 map，最终返回的是数组\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Object}\n */\nfunction normalizeMap (map) {\n  if (!isValidMap(map)) {\n    return []\n  }\n  return Array.isArray(map)\n    ? map.map(key => ({ key, val: key }))\n    : Object.keys(map).map(key => ({ key, val: map[key] }))\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"module.context"}),"  这个赋值主要是给 ",(0,s.jsx)(n.code,{children:"helpers"})," 中 ",(0,s.jsx)(n.code,{children:"mapState"}),"、",(0,s.jsx)(n.code,{children:"mapGetters"}),"、",(0,s.jsx)(n.code,{children:"mapMutations"}),"、",(0,s.jsx)(n.code,{children:"mapActions"}),"四个辅助函数使用的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 在构造函数中 installModule 中\nconst local = module.context = makeLocalContext(store, namespace, path)\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里就是抹平差异，不用用户传递命名空间，获取到对应的 commit、dispatch、state、和 getters"}),"\n",(0,s.jsx)(n.p,{children:"getModuleByNamespace"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getModuleByNamespace (store, helper, namespace) {\n  // _modulesNamespaceMap 这个变量在 class Store installModule 函数中赋值的\n  const module = store._modulesNamespaceMap[namespace]\n  if (process.env.NODE_ENV !== 'production' && !module) {\n    console.error(`[vuex] module namespace not found in ${helper}(): ${namespace}`)\n  }\n  return module\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["看完这些，最后举个例子：\n",(0,s.jsx)(n.code,{children:"vuex/examples/shopping-cart/components/ShoppingCart.vue"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"computed: {\n    ...mapState({\n      checkoutStatus: state => state.cart.checkoutStatus\n    }),\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"没有命名空间的情况下，最终会转换成这样"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"computed: {\n    checkoutStatus: this.$store.state.checkoutStatus\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"假设有命名空间'ruochuan'，"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"computed: {\n    ...mapState('ruochuan', {\n      checkoutStatus: state => state.cart.checkoutStatus\n    }),\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"则会转换成："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"computed: {\n    checkoutStatus: this.$store._modulesNamespaceMap.['ruochuan/'].context.checkoutStatus\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"62-mapgetters",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-mapgetters",children:"#"}),"6.2 mapGetters"]}),"\n",(0,s.jsxs)(n.p,{children:["为组件创建计算属性以返回 ",(0,s.jsx)(n.code,{children:"getter"})," 的返回值。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const mapGetters = normalizeNamespace((namespace, getters) => {\n  const res = {}\n  // 省略代码：非生产环境 判断参数 getters 必须是数组或者是对象\n  normalizeMap(getters).forEach(({ key, val }) => {\n    // The namespace has been mutated by normalizeNamespace\n    val = namespace + val\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      // 省略代码：匹配不到 getter\n      return this.$store.getters[val]\n    }\n    // mark vuex getter for devtools\n    res[key].vuex = true\n  })\n  return res\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"举例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"computed: {\n  ...mapGetters('cart', {\n    products: 'cartProducts',\n    total: 'cartTotalPrice'\n  })\n},\n"})}),"\n",(0,s.jsx)(n.p,{children:"最终转换成："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"computed: {\n  products: this.$store.getters['cart/cartProducts'],\n  total: this.$store.getters['cart/cartTotalPrice'],\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"63-mapactions",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#63-mapactions",children:"#"}),"6.3 mapActions"]}),"\n",(0,s.jsxs)(n.p,{children:["创建组件方法分发 ",(0,s.jsx)(n.code,{children:"action"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const mapActions = normalizeNamespace((namespace, actions) => {\n  const res = {}\n  // 省略代码： 非生产环境 判断参数 actions  必须是数组或者是对象\n  normalizeMap(actions).forEach(({ key, val }) => {\n    res[key] = function mappedAction (...args) {\n      // get dispatch function from store\n      let dispatch = this.$store.dispatch\n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, 'mapActions', namespace)\n        if (!module) {\n          return\n        }\n        dispatch = module.context.dispatch\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [dispatch].concat(args))\n        : dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"64-mapmutations",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#64-mapmutations",children:"#"}),"6.4 mapMutations"]}),"\n",(0,s.jsxs)(n.p,{children:["创建组件方法提交 ",(0,s.jsx)(n.code,{children:"mutation"}),"。\nmapMutations 和 mapActions 类似，只是 dispatch 换成了 commit。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let commit = this.$store.commit\ncommit = module.context.commit\nreturn typeof val === 'function'\n        ? val.apply(this, [commit].concat(args))\n        : commit.apply(this.$store, [val].concat(args))\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis/blob/master/vuex/src/helpers.js",rel:"noopener noreferrer",target:"_blank",children:"vuex/src/helpers"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mapMutations"}),"、",(0,s.jsx)(n.code,{children:"mapActions"})," 举例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  methods: {\n    ...mapMutations(['inc']),\n    ...mapMutations('ruochuan', ['dec']),\n    ...mapActions(['actionA'])\n    ...mapActions('ruochuan', ['actionB'])\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"最终转换成"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  methods: {\n    inc(...args){\n      return this.$store.dispatch.apply(this.$store, ['inc'].concat(args))\n    },\n    dec(...args){\n      return this.$store._modulesNamespaceMap.['ruochuan/'].context.dispatch.apply(this.$store, ['dec'].concat(args))\n    },\n    actionA(...args){\n      return this.$store.commit.apply(this.$store, ['actionA'].concat(args))\n    }\n    actionB(...args){\n      return this.$store._modulesNamespaceMap.['ruochuan/'].context.commit.apply(this.$store, ['actionB'].concat(args))\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"由此可见：这些辅助函数极大地方便了开发者。"}),"\n",(0,s.jsxs)(n.h3,{id:"65-createnamespacedhelpers",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#65-createnamespacedhelpers",children:"#"}),"6.5 createNamespacedHelpers"]}),"\n",(0,s.jsx)(n.p,{children:"创建基于命名空间的组件绑定辅助函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const createNamespacedHelpers = (namespace) => ({\n  // bind(null) 严格模式下，napState等的函数 this 指向就是 null\n  mapState: mapState.bind(null, namespace),\n  mapGetters: mapGetters.bind(null, namespace),\n  mapMutations: mapMutations.bind(null, namespace),\n  mapActions: mapActions.bind(null, namespace)\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"就是把这些辅助函数放在一个对象中。"}),"\n",(0,s.jsxs)(n.h2,{id:"7-插件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-插件",children:"#"}),"7. 插件"]}),"\n",(0,s.jsxs)(n.p,{children:["插件部分文件路径是：","\n",(0,s.jsx)(n.code,{children:"vuex/src/plugins/devtool"}),"\n",(0,s.jsx)(n.code,{children:"vuex/src/plugins/logger"})]}),"\n",(0,s.jsxs)(n.p,{children:["文章比较长了，这部分就不再叙述。具体可以看笔者的仓库 ",(0,s.jsxs)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis/blob/master/vuex/src/plugins/logger.js",rel:"noopener noreferrer",target:"_blank",children:["vuex-analysis ",(0,s.jsx)(n.code,{children:"vuex/src/plugins/"})]})," 的源码注释。"]}),"\n",(0,s.jsxs)(n.h2,{id:"8-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-总结",children:"#"}),"8. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["文章比较详细的介绍了",(0,s.jsx)(n.code,{children:"vuex"}),"、",(0,s.jsx)(n.code,{children:"vue"}),"源码调试方法和 ",(0,s.jsx)(n.code,{children:"Vuex"})," 原理。并且详细介绍了 ",(0,s.jsx)(n.code,{children:"Vuex.use"})," 安装和 ",(0,s.jsx)(n.code,{children:"new Vuex.Store"})," 初始化、",(0,s.jsx)(n.code,{children:"Vuex.Store"})," 的全部",(0,s.jsx)(n.code,{children:"API"}),"（如",(0,s.jsx)(n.code,{children:"dispatch"}),"、",(0,s.jsx)(n.code,{children:"commit"}),"等）的实现和辅助函数 ",(0,s.jsx)(n.code,{children:"mapState"}),"、",(0,s.jsx)(n.code,{children:"mapGetters"}),"、 ",(0,s.jsx)(n.code,{children:"mapActions"}),"、",(0,s.jsx)(n.code,{children:"mapMutations"}),"\n",(0,s.jsx)(n.code,{children:"createNamespacedHelpers"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["文章注释，在",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vuex-analysis",rel:"noopener noreferrer",target:"_blank",children:"vuex-analysis"}),"源码仓库里基本都有注释分析，求个",(0,s.jsx)(n.code,{children:"star"}),"。再次强烈建议要克隆代码下来。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/ruochuan12/vuex-analysis.git\n"})}),"\n",(0,s.jsxs)(n.p,{children:["先把 ",(0,s.jsx)(n.code,{children:"Store"})," 实例打印出来，看具体结构，再结合实例断点调试，事半功倍。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Vuex"})," 源码相对不多，打包后一千多行，非常值得学习，也比较容易看完。"]}),"\n",(0,s.jsx)(n.p,{children:"如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持，万分感谢。"}),"\n",(0,s.jsxs)(n.h2,{id:"9-推荐阅读",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-推荐阅读",children:"#"}),"9. 推荐阅读"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://vuex.vuejs.org/zh/",rel:"noopener noreferrer",target:"_blank",children:"vuex 官方文档"}),"\n",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vuex",rel:"noopener noreferrer",target:"_blank",children:"vuex github 仓库"}),"\n",(0,s.jsx)(n.a,{href:"https://tech.meituan.com/2017/04/27/vuex-code-analysis.html",rel:"noopener noreferrer",target:"_blank",children:"美团明裔：Vuex框架原理与源码分析"}),(0,s.jsx)(n.strong,{children:"这篇文章强烈推荐，流程图画的很好"}),"\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/23921964",rel:"noopener noreferrer",target:"_blank",children:"知乎黄轶：Vuex 2.0 源码分析"}),(0,s.jsx)(n.strong,{children:"这篇文章也强烈推荐，讲述的比较全面"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5962c13c6fb9a06b9e11a6a9",rel:"noopener noreferrer",target:"_blank",children:"小虫巨蟹：Vuex 源码解析（如何阅读源代码实践篇）"}),(0,s.jsx)(n.strong,{children:"这篇文章也强烈推荐，主要讲如何阅读源代码"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/59f66bd7f265da432d275d30",rel:"noopener noreferrer",target:"_blank",children:"染陌：Vuex 源码解析"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/59b88e2e6fb9a00a4f1b0a0b#heading-8",rel:"noopener noreferrer",target:"_blank",children:"网易考拉前端团队：Vuex 源码分析"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5b8e3182e51d4538ae4dce87",rel:"noopener noreferrer",target:"_blank",children:"yck：Vuex 源码深度解析"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5cb30243e51d456e431ada29",rel:"noopener noreferrer",target:"_blank",children:"小生方勤：【前端词典】从源码解读 Vuex 注入 Vue 生命周期的过程"})]}),"\n",(0,s.jsxs)(n.h2,{id:"笔者另一个系列",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔者另一个系列",children:"#"}),"笔者另一个系列"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"})]}),"\n",(0,s.jsxs)(n.h2,{id:"关于",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"个人博客-若川"}),"，使用",(0,s.jsx)(n.code,{children:"vuepress"}),"重构了，阅读体验可能更好些","\n",(0,s.jsx)(n.a,{href:"https://juejin.im/user/57974dc55bbb500063f522fd/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,s.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://www.yuque.com/lxchuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"语雀前端视野专栏"}),"，新增语雀专栏，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,s.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,s.jsxs)(n.h2,{id:"欢迎加微信交流-微信公众号",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#欢迎加微信交流-微信公众号",children:"#"}),"欢迎加微信交流 微信公众号"]}),"\n",(0,s.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注（",(0,s.jsx)(n.strong,{children:"回复pdf获取前端优质书籍pdf"}),"）。也可以加微信 ",(0,s.jsx)(n.code,{children:"ruochuan12"}),"，注明来源，拉您进【前端视野交流群】。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://github.com/ruochuan12/blog/raw/master/docs/about/wechat-official-accounts-mini.jpg",alt:"若川视野"})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["vuex%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-chrome-浏览器调试-vuex-源码方法",text:"2. chrome 浏览器调试 vuex 源码方法",depth:2},{id:"21-顺便提一下调试-vue-源码v2610的方法",text:"2.1 顺便提一下调试 vue 源码（v2.6.10）的方法",depth:3},{id:"3-vuex-原理",text:"3. vuex 原理",depth:2},{id:"3-vueuse-安装",text:"3. Vue.use 安装",depth:2},{id:"31-install-函数",text:"3.1 install 函数",depth:3},{id:"32-applymixin-函数",text:"3.2 applyMixin 函数",depth:3},{id:"4-vuexstore-构造函数",text:"4. Vuex.Store 构造函数",depth:2},{id:"41-class-modulecollection",text:"4.1 class ModuleCollection",depth:3},{id:"411-class-module",text:"4.1.1 class Module",depth:4},{id:"42-installmodule-函数",text:"4.2 installModule 函数",depth:3},{id:"421-注册-state",text:"4.2.1 注册 state",depth:4},{id:"422-遍历注册-mutation",text:"4.2.2 遍历注册 mutation",depth:4},{id:"423-遍历注册-action",text:"4.2.3 遍历注册 action",depth:4},{id:"424-遍历注册-getter",text:"4.2.4 遍历注册 getter",depth:4},{id:"425-遍历注册-子模块",text:"4.2.5 遍历注册 子模块",depth:4},{id:"43-resetstorevm-函数",text:"4.3 resetStoreVM 函数",depth:3},{id:"5-vuexstore-实例方法",text:"5. Vuex.Store 实例方法",depth:2},{id:"51-commit",text:"5.1 commit",depth:3},{id:"52-dispatch",text:"5.2 dispatch",depth:3},{id:"53-replacestate",text:"5.3 replaceState",depth:3},{id:"54-watch",text:"5.4 watch",depth:3},{id:"55-subscribe",text:"5.5 subscribe",depth:3},{id:"56-subscribeaction",text:"5.6 subscribeAction",depth:3},{id:"57-registermodule",text:"5.7 registerModule",depth:3},{id:"58-unregistermodule",text:"5.8 unregisterModule",depth:3},{id:"59-hotupdate",text:"5.9 hotUpdate",depth:3},{id:"6-组件绑定的辅助函数",text:"6. 组件绑定的辅助函数",depth:2},{id:"61-mapstate",text:"6.1 mapState",depth:3},{id:"62-mapgetters",text:"6.2 mapGetters",depth:3},{id:"63-mapactions",text:"6.3 mapActions",depth:3},{id:"64-mapmutations",text:"6.4 mapMutations",depth:3},{id:"65-createnamespacedhelpers",text:"6.5 createNamespacedHelpers",depth:3},{id:"7-插件",text:"7. 插件",depth:2},{id:"8-总结",text:"8. 总结",depth:2},{id:"9-推荐阅读",text:"9. 推荐阅读",depth:2},{id:"笔者另一个系列",text:"笔者另一个系列",depth:2},{id:"关于",text:"关于",depth:2},{id:"欢迎加微信交流-微信公众号",text:"欢迎加微信交流 微信公众号",depth:2}],title:"学习 vuex 源码整体架构，打造属于自己的状态管理库",headingTitle:"学习 vuex 源码整体架构，打造属于自己的状态管理库",frontmatter:{}}},20713:function(e,n,t){t.d(n,{Z:()=>i});var s=t(52676),r=t(75271),a=t(92815);t(18544);let c={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function o(e,n,t){let s=Object.keys(c).includes(n)?n:t;return c[s](e)}let i=e=>{let{defaultLocale:n="en-US"}=e,t=(0,a.Vi)().page.readingTimeData,c=(0,a.Jr)(),i=(0,a.e7)(),[l,d]=(0,r.useState)(o(t,c,n));return(0,r.useEffect)(()=>{d(o(t,c,n))},[c,t]),(0,s.jsx)("span",{"data-dark":String(i),className:"rp-reading-time",children:l})}}}]);