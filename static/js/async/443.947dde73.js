"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["443"],{60332:function(e,n,r){e.exports=r.p+"static/image/wechat-official-accounts-mini.44481959.png"},84769:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var t=r(52676),o=r(40453),s=r(20713);let c=r.p+"static/image/ctor-prototype-instance@lxchuan12.a0efaf2f.png",l=r.p+"static/image/es6-extends@lxchuan12.9c8ecd3f.png";var i=r(60332);function a(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",code:"code",pre:"pre",strong:"strong",h2:"h2",img:"img",ul:"ul",li:"li",ol:"ol",h3:"h3"},(0,o.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"面试官问js的继承",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#面试官问js的继承",children:"#"}),"面试官问：JS的继承"]}),"\n",(0,t.jsx)(s.Z,{defaultLocale:"zh-CN"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"写于2019年2月20日"})}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["大家好，我是",(0,t.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,t.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,t.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,t.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,t.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["这是面试官问系列的第五篇，旨在帮助读者提升",(0,t.jsx)(n.code,{children:"JS"}),"基础知识，包含",(0,t.jsx)(n.code,{children:"new、call、apply、this、继承"}),"相关知识。","\n",(0,t.jsx)(n.code,{children:"面试官问系列"}),"文章如下：感兴趣的读者可以点击阅读。","\n1.",(0,t.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n2.",(0,t.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n3.",(0,t.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n4.",(0,t.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n5.",(0,t.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["用过",(0,t.jsx)(n.code,{children:"React"}),"的读者知道，经常用",(0,t.jsx)(n.code,{children:"extends"}),"继承",(0,t.jsx)(n.code,{children:"React.Component"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 部分源码\nfunction Component(props, context, updater) {\n  // ...\n}\nComponent.prototype.setState = function(partialState, callback){\n    // ...\n}\nconst React = {\n    Component,\n    // ...\n}\n// 使用\nclass index extends React.Component{\n    // ...\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/blob/master/packages/react/src/ReactBaseClasses.js",rel:"noopener noreferrer",target:"_blank",children:"点击这里查看 React github源码"})}),"\n",(0,t.jsxs)(n.p,{children:["面试官可以顺着这个问",(0,t.jsx)(n.code,{children:"JS"}),"继承的相关问题，比如：",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"ES6"}),"的",(0,t.jsx)(n.code,{children:"class"}),"继承用ES5如何实现"]}),"。据说很多人答得不好。"]}),"\n",(0,t.jsxs)(n.h2,{id:"构造函数原型对象和实例之间的关系",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构造函数原型对象和实例之间的关系",children:"#"}),"构造函数、原型对象和实例之间的关系"]}),"\n",(0,t.jsx)(n.p,{children:"要弄懂extends继承之前，先来复习一下构造函数、原型对象和实例之间的关系。\n代码表示："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function F(){}\nvar f = new F();\n// 构造器\nF.prototype.constructor === F; // true\nF.__proto__ === Function.prototype; // true\nFunction.prototype.__proto__ === Object.prototype; // true\nObject.prototype.__proto__ === null; // true\n\n// 实例\nf.__proto__ === F.prototype; // true\nF.prototype.__proto__ === Object.prototype; // true\nObject.prototype.__proto__ === null; // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["笔者画了一张图表示：\n",(0,t.jsx)(n.img,{alt:"构造函数-原型对象-实例关系图By@若川",src:c})]}),"\n",(0,t.jsxs)(n.h2,{id:"es6-extends-继承做了什么操作",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es6-extends-继承做了什么操作",children:"#"}),(0,t.jsx)(n.code,{children:"ES6 extends"})," 继承做了什么操作"]}),"\n",(0,t.jsxs)(n.p,{children:["我们先看看这段包含静态方法的",(0,t.jsx)(n.code,{children:"ES6"}),"继承代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// ES6\nclass Parent{\n    constructor(name){\n        this.name = name;\n    }\n    static sayHello(){\n        console.log('hello');\n    }\n    sayName(){\n        console.log('my name is ' + this.name);\n        return this.name;\n    }\n}\nclass Child extends Parent{\n    constructor(name, age){\n        super(name);\n        this.age = age;\n    }\n    sayAge(){\n        console.log('my age is ' + this.age);\n        return this.age;\n    }\n}\nlet parent = new Parent('Parent');\nlet child = new Child('Child', 18);\nconsole.log('parent: ', parent); // parent:  Parent\xa0{name: \"Parent\"}\nParent.sayHello(); // hello\nparent.sayName(); // my name is Parent\nconsole.log('child: ', child); // child:  Child\xa0{name: \"Child\", age: 18}\nChild.sayHello(); // hello\nchild.sayName(); // my name is Child\nchild.sayAge(); // my age is 18\n"})}),"\n",(0,t.jsx)(n.p,{children:"其中这段代码里有两条原型链，不信看具体代码。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 1、构造器原型链\nChild.__proto__ === Parent; // true\nParent.__proto__ === Function.prototype; // true\nFunction.prototype.__proto__ === Object.prototype; // true\nObject.prototype.__proto__ === null; // true\n// 2、实例原型链\nchild.__proto__ === Child.prototype; // true\nChild.prototype.__proto__ === Parent.prototype; // true\nParent.prototype.__proto__ === Object.prototype; // true\nObject.prototype.__proto__ === null; // true\n"})}),"\n",(0,t.jsx)(n.p,{children:"一图胜千言，笔者也画了一张图表示，如图所示："}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.img,{alt:"ES6继承(extends)关系图By@若川",src:l}),"\n结合代码和图可以知道。\n",(0,t.jsx)(n.code,{children:"ES6 extends"})," 继承，主要就是："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["把子类构造函数(",(0,t.jsx)(n.code,{children:"Child"}),")的原型(",(0,t.jsx)(n.code,{children:"__proto__"}),")指向了父类构造函数(",(0,t.jsx)(n.code,{children:"Parent"}),")，"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["把子类实例",(0,t.jsx)(n.code,{children:"child"}),"的原型对象(",(0,t.jsx)(n.code,{children:"Child.prototype"}),") 的原型(",(0,t.jsx)(n.code,{children:"__proto__"}),")指向了父类",(0,t.jsx)(n.code,{children:"parent"}),"的原型对象(",(0,t.jsx)(n.code,{children:"Parent.prototype"}),")。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"这两点也就是图中用不同颜色标记的两条线。"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["3. 子类构造函数",(0,t.jsx)(n.code,{children:"Child"}),"继承了父类构造函数",(0,t.jsx)(n.code,{children:"Parent"}),"的里的属性。使用",(0,t.jsx)(n.code,{children:"super"}),"调用的(",(0,t.jsx)(n.code,{children:"ES5"}),"则用",(0,t.jsx)(n.code,{children:"call"}),"或者",(0,t.jsx)(n.code,{children:"apply"}),"调用传参)。\n也就是图中用不同颜色标记的两条线。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["看过《JavaScript高级程序设计-第3版》 章节",(0,t.jsx)(n.code,{children:"6.3继承"}),"的读者应该知道，这",(0,t.jsx)(n.code,{children:"2和3小点"}),"，正是",(0,t.jsx)(n.strong,{children:"寄生组合式继承"}),"，书中例子没有",(0,t.jsx)(n.code,{children:"第1小点"}),"。\n",(0,t.jsx)(n.code,{children:"1和2小点"}),"都是相对于设置了",(0,t.jsx)(n.code,{children:"__proto__"}),"链接。那问题来了，什么可以设置了",(0,t.jsx)(n.code,{children:"__proto__"}),"链接呢。"]}),"\n",(0,t.jsxs)(n.h2,{id:"newobjectcreate和objectsetprototypeof可以设置__proto__",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#newobjectcreate和objectsetprototypeof可以设置__proto__",children:"#"}),(0,t.jsx)(n.code,{children:"new"}),"、",(0,t.jsx)(n.code,{children:"Object.create"}),"和",(0,t.jsx)(n.code,{children:"Object.setPrototypeOf"}),"可以设置",(0,t.jsx)(n.code,{children:"__proto__"})]}),"\n",(0,t.jsxs)(n.p,{children:["说明一下，",(0,t.jsx)(n.code,{children:"__proto__"}),"这种写法是浏览器厂商自己的实现。\n再结合一下图和代码看一下的",(0,t.jsx)(n.code,{children:"new"}),"，",(0,t.jsx)(n.code,{children:"new"}),"出来的实例的__proto__指向构造函数的",(0,t.jsx)(n.code,{children:"prototype"}),"，这就是",(0,t.jsx)(n.code,{children:"new"}),"做的事情。\n摘抄一下之前写过文章的一段。",(0,t.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"，有兴趣的读者可以点击查看。"]}),"\n",(0,t.jsxs)(n.h3,{id:"做了什么",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#做了什么",children:"#"}),(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"new"}),"做了什么："]})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"创建了一个全新的对象。"}),"\n",(0,t.jsxs)(n.li,{children:["这个对象会被执行",(0,t.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,t.jsx)(n.code,{children:"__proto__"}),"）链接。"]}),"\n",(0,t.jsxs)(n.li,{children:["生成的新对象会绑定到函数调用的",(0,t.jsx)(n.code,{children:"this"}),"。"]}),"\n",(0,t.jsxs)(n.li,{children:["通过",(0,t.jsx)(n.code,{children:"new"}),"创建的每个对象将最终被",(0,t.jsx)(n.code,{children:"[[Prototype]]"}),"链接到这个函数的",(0,t.jsx)(n.code,{children:"prototype"}),"对象上。"]}),"\n",(0,t.jsxs)(n.li,{children:["如果函数没有返回对象类型",(0,t.jsx)(n.code,{children:"Object"}),"(包含",(0,t.jsx)(n.code,{children:"Functoin"}),", ",(0,t.jsx)(n.code,{children:"Array"}),", ",(0,t.jsx)(n.code,{children:"Date"}),", ",(0,t.jsx)(n.code,{children:"RegExg"}),", ",(0,t.jsx)(n.code,{children:"Error"}),")，那么",(0,t.jsx)(n.code,{children:"new"}),"表达式中的函数调用会自动返回这个新的对象。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"objectcreatees5提供的",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectcreatees5提供的",children:"#"}),(0,t.jsx)(n.code,{children:"Object.create"}),(0,t.jsx)(n.code,{children:"ES5提供的"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Object.create(proto, [propertiesObject])"}),"\n方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是",(0,t.jsx)(n.code,{children:"undefined"}),"）。对于不支持",(0,t.jsx)(n.code,{children:"ES5"}),"的浏览器，",(0,t.jsx)(n.code,{children:"MDN"}),"上提供了",(0,t.jsx)(n.code,{children:"ployfill"}),"方案。\n",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create",rel:"noopener noreferrer",target:"_blank",children:"MDN Object.create()"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 简版：也正是应用了new会设置__proto__链接的原理。\nif(typeof Object.create !== 'function'){\n    Object.create = function(proto){\n        function F() {}\n        F.prototype = proto;\n        return new F();\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"objectsetprototypeofes6提供的",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectsetprototypeofes6提供的",children:"#"}),(0,t.jsx)(n.code,{children:"Object.setPrototypeOf"}),(0,t.jsx)(n.code,{children:"ES6提供的"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf",rel:"noopener noreferrer",target:"_blank",children:[(0,t.jsx)(n.code,{children:"Object.setPrototypeOf"})," ",(0,t.jsx)(n.code,{children:"MDN"})]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Object.setPrototypeOf()"})," 方法设置一个指定的对象的原型 ( 即, 内部",(0,t.jsx)(n.code,{children:"[[Prototype]]"}),"属性）到另一个对象或  ",(0,t.jsx)(n.code,{children:"null"}),"。\n",(0,t.jsx)(n.code,{children:"Object.setPrototypeOf(obj, prototype)"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"`ployfill`\n// 仅适用于Chrome和FireFox，在IE中不工作：\nObject.setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"nodejs"}),"源码就是利用这个实现继承的工具函数的。\n",(0,t.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/master/lib/util.js#L295-L313",rel:"noopener noreferrer",target:"_blank",children:"nodejs utils inherits"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function inherits(ctor, superCtor) {\n  if (ctor === undefined || ctor === null)\n    throw new ERR_INVALID_ARG_TYPE('ctor', 'Function', ctor);\n\n  if (superCtor === undefined || superCtor === null)\n    throw new ERR_INVALID_ARG_TYPE('superCtor', 'Function', superCtor);\n\n  if (superCtor.prototype === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('superCtor.prototype',\n                                   'Object', superCtor.prototype);\n  }\n  Object.defineProperty(ctor, 'super_', {\n    value: superCtor,\n    writable: true,\n    configurable: true\n  });\n  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"es6的extends的es5版本实现",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es6的extends的es5版本实现",children:"#"}),(0,t.jsx)(n.code,{children:"ES6"}),"的",(0,t.jsx)(n.code,{children:"extends"}),"的",(0,t.jsx)(n.code,{children:"ES5"}),"版本实现"]}),"\n",(0,t.jsxs)(n.p,{children:["知道了",(0,t.jsx)(n.code,{children:"ES6 extends"}),"继承做了什么操作和设置",(0,t.jsx)(n.code,{children:"__proto__"}),"的知识点后，把上面",(0,t.jsx)(n.code,{children:"ES6"}),"例子的用",(0,t.jsx)(n.code,{children:"ES5"}),"就比较容易实现了，也就是说",(0,t.jsx)(n.strong,{children:"实现寄生组合式继承"}),"，简版代码就是："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// ES5 实现ES6 extends的例子\nfunction Parent(name){\n    this.name = name;\n}\nParent.sayHello = function(){\n    console.log('hello');\n}\nParent.prototype.sayName = function(){\n    console.log('my name is ' + this.name);\n    return this.name;\n}\n\nfunction Child(name, age){\n    // 相当于super\n    Parent.call(this, name);\n    this.age = age;\n}\n// new\nfunction object(){\n    function F() {}\n    F.prototype = proto;\n    return new F();\n}\nfunction _inherits(Child, Parent){\n    // Object.create\n    Child.prototype = Object.create(Parent.prototype);\n    // __proto__\n    // Child.prototype.__proto__ = Parent.prototype;\n    Child.prototype.constructor = Child;\n    // ES6\n    // Object.setPrototypeOf(Child, Parent);\n    // __proto__\n    Child.__proto__ = Parent;\n}\n_inherits(Child,  Parent);\nChild.prototype.sayAge = function(){\n    console.log('my age is ' + this.age);\n    return this.age;\n}\nvar parent = new Parent('Parent');\nvar child = new Child('Child', 18);\nconsole.log('parent: ', parent); // parent:  Parent\xa0{name: \"Parent\"}\nParent.sayHello(); // hello\nparent.sayName(); // my name is Parent\nconsole.log('child: ', child); // child:  Child\xa0{name: \"Child\", age: 18}\nChild.sayHello(); // hello\nchild.sayName(); // my name is Child\nchild.sayAge(); // my age is 18\n"})}),"\n",(0,t.jsxs)(n.p,{children:["我们完全可以把上述",(0,t.jsx)(n.code,{children:"ES6的例子"}),"通过",(0,t.jsx)(n.a,{href:"https://babeljs.io/repl",rel:"noopener noreferrer",target:"_blank",children:(0,t.jsx)(n.code,{children:"babeljs"})}),"转码成",(0,t.jsx)(n.code,{children:"ES5"}),"来查看，更严谨的实现。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'// 对转换后的代码进行了简要的注释\n"use strict";\n// 主要是对当前环境支持Symbol和不支持Symbol的typeof处理\nfunction _typeof(obj) {\n    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n        _typeof = function _typeof(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\n// _possibleConstructorReturn 判断Parent。call(this, name)函数返回值 是否为null或者函数或者对象。\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === "object" || typeof call === "function")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\n// 如何 self 是void 0 （undefined） 则报错\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n    }\n    return self;\n}\n// 获取__proto__\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\n// 寄生组合式继承的核心\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== "function" && superClass !== null) {\n        throw new TypeError("Super expression must either be null or a function");\n    }\n    // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n    // 也就是说执行后 subClass.prototype.__proto__ === superClass.prototype; 这条语句为true\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\n// 设置__proto__\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\n// instanceof操作符包含对Symbol的处理\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {\n        return right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!_instanceof(instance, Constructor)) {\n        throw new TypeError("Cannot call a class as a function");\n    }\n}\n// 按照它们的属性描述符 把方法和静态属性赋值到构造函数的prototype和构造器函数上\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if ("value" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n// 把方法和静态属性赋值到构造函数的prototype和构造器函数上\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n\n// ES6\nvar Parent = function () {\n    function Parent(name) {\n        _classCallCheck(this, Parent);\n        this.name = name;\n    }\n    _createClass(Parent, [{\n        key: "sayName",\n        value: function sayName() {\n            console.log(\'my name is \' + this.name);\n            return this.name;\n        }\n    }], [{\n        key: "sayHello",\n        value: function sayHello() {\n            console.log(\'hello\');\n        }\n    }]);\n    return Parent;\n}();\n\nvar Child = function (_Parent) {\n    _inherits(Child, _Parent);\n    function Child(name, age) {\n        var _this;\n        _classCallCheck(this, Child);\n        // Child.__proto__ => Parent\n        // 所以也就是相当于Parent.call(this, name); 是super(name)的一种转换\n        // _possibleConstructorReturn 判断Parent.call(this, name)函数返回值 是否为null或者函数或者对象。\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Child).call(this, name));\n        _this.age = age;\n        return _this;\n    }\n    _createClass(Child, [{\n        key: "sayAge",\n        value: function sayAge() {\n            console.log(\'my age is \' + this.age);\n            return this.age;\n        }\n    }]);\n    return Child;\n}(Parent);\n\nvar parent = new Parent(\'Parent\');\nvar child = new Child(\'Child\', 18);\nconsole.log(\'parent: \', parent); // parent:  Parent\xa0{name: "Parent"}\nParent.sayHello(); // hello\nparent.sayName(); // my name is Parent\nconsole.log(\'child: \', child); // child:  Child\xa0{name: "Child", age: 18}\nChild.sayHello(); // hello\nchild.sayName(); // my name is Child\nchild.sayAge(); // my age is 18\n'})}),"\n",(0,t.jsxs)(n.p,{children:["如果对JS继承相关还是不太明白的读者，推荐阅读以下书籍的相关章节，可以自行找到相应的",(0,t.jsx)(n.code,{children:"pdf"}),"版本。"]}),"\n",(0,t.jsxs)(n.h2,{id:"推荐阅读js继承相关的书籍章节",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#推荐阅读js继承相关的书籍章节",children:"#"}),"推荐阅读JS继承相关的书籍章节"]}),"\n",(0,t.jsxs)(n.p,{children:["《JavaScript高级程序设计第3版》-第6章 面向对象的程序设计，6种继承的方案，分别是原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。",(0,t.jsx)(n.a,{href:"http://www.ituring.com.cn/book/946",rel:"noopener noreferrer",target:"_blank",children:"图灵社区本书地址"}),"，后文放出",(0,t.jsx)(n.code,{children:"github"}),"链接，里面包含这几种继承的代码",(0,t.jsx)(n.code,{children:"demo"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"《JavaScript面向对象编程第2版》-第6章 继承，12种继承的方案。1.原型链法（仿传统）、2.仅从原型继承法、3.临时构造器法、4.原型属性拷贝法、5.全属性拷贝法（即浅拷贝法）、6.深拷贝法、7.原型继承法、8.扩展与增强模式、9.多重继承法、10.寄生继承法、11.构造器借用法、12.构造器借用与属性拷贝法。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"http://es6.ruanyifeng.com/#docs/class-extends",rel:"noopener noreferrer",target:"_blank",children:"ES6标准入门-第21章class的继承"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://oshotokill.gitbooks.io/understandinges6-simplified-chinese/content/chapter_9.html",rel:"noopener noreferrer",target:"_blank",children:["《深入理解",(0,t.jsx)(n.code,{children:"ES6"}),"》-第9章"]})," ",(0,t.jsx)(n.code,{children:"JavaScript"}),"中的类"]}),"\n",(0,t.jsxs)(n.p,{children:["《你不知道的",(0,t.jsx)(n.code,{children:"JavaScript"}),"-上卷》第6章 行为委托和附录A ",(0,t.jsx)(n.code,{children:"ES6中的class"})]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,t.jsxs)(n.p,{children:["继承对于JS来说就是父类拥有的方法和属性、静态方法等，子类也要拥有。子类中可以利用原型链查找，也可以在子类调用父类，或者从父类拷贝一份到子类等方案。\n继承方法可以有很多，重点在于必须理解并熟\n悉这些对象、原型以及构造器的工作方式，剩下的就简单了。",(0,t.jsx)(n.strong,{children:"寄生组合式继承"}),"是开发者使用比较多的。\n回顾寄生组合式继承。主要就是三点："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["子类构造函数的",(0,t.jsx)(n.code,{children:"__proto__"}),"指向父类构造器，继承父类的静态方法。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["子类构造函数的",(0,t.jsx)(n.code,{children:"prototype"}),"的",(0,t.jsx)(n.code,{children:"__proto__"}),"指向父类构造器的",(0,t.jsx)(n.code,{children:"prototype"}),"，继承父类的方法。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["子类构造器里调用父类构造器，继承父类的属性。\n行文到此，文章就基本写完了。文章代码和图片等资源放在这里",(0,t.jsx)(n.a,{href:"https://github.com/ruochuan12/html5/tree/gh-pages/JS%E7%9B%B8%E5%85%B3/oop/inherit",rel:"noopener noreferrer",target:"_blank",children:"github inhert"}),"和",(0,t.jsxs)(n.a,{href:"http://ruochuan12.github.io/html5/JS%E7%9B%B8%E5%85%B3/oop/inherit/7.es6-extends.html",rel:"noopener noreferrer",target:"_blank",children:[(0,t.jsx)(n.code,{children:"demo"}),"展示",(0,t.jsx)(n.code,{children:"es6-extends"})]}),"，结合",(0,t.jsx)(n.code,{children:"console、source"}),"面板查看更佳。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"读者发现有不妥或可改善之处，欢迎评论指出。另外觉得写得不错，可以点赞、评论、转发，也是对笔者的一种支持。"}),"\n",(0,t.jsxs)(n.h2,{id:"关于",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,t.jsxs)(n.p,{children:["作者：常以",(0,t.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,t.jsx)(n.a,{href:"https://ruochuan12.github.io/",rel:"noopener noreferrer",target:"_blank",children:"个人博客"}),"\n",(0,t.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,t.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，开通了",(0,t.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注","\n",(0,t.jsx)(n.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注","\n",(0,t.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，开通了",(0,t.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注","\n",(0,t.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关资源和文件都放在这里，求个",(0,t.jsx)(n.code,{children:"star"}),"~"]}),"\n",(0,t.jsxs)(n.h2,{id:"微信公众号--若川视野",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,t.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ",(0,t.jsx)(n.code,{children:"ruochuan12"}),"，注明来源，拉您进【前端视野交流群】。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"若川视野",src:i})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(a,e)})):a(e)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["js-extend%2Findex.md"]={toc:[{id:"构造函数原型对象和实例之间的关系",text:"构造函数、原型对象和实例之间的关系",depth:2},{id:"es6-extends-继承做了什么操作",text:"`ES6 extends` 继承做了什么操作",depth:2},{id:"newobjectcreate和objectsetprototypeof可以设置__proto__",text:"`new`、`Object.create`和`Object.setPrototypeOf`可以设置`__proto__`",depth:2},{id:"new做了什么",text:"**new做了什么：**",depth:3},{id:"objectcreatees5提供的",text:"`Object.create``ES5提供的`",depth:3},{id:"objectsetprototypeofes6提供的",text:"`Object.setPrototypeOf``ES6提供的`",depth:3},{id:"es6的extends的es5版本实现",text:"`ES6`的`extends`的`ES5`版本实现",depth:2},{id:"推荐阅读js继承相关的书籍章节",text:"推荐阅读JS继承相关的书籍章节",depth:2},{id:"总结",text:"总结",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"面试官问：JS的继承",headingTitle:"面试官问：JS的继承",frontmatter:{}}},20713:function(e,n,r){r.d(n,{Z:()=>i});var t=r(52676),o=r(75271),s=r(92815);r(18544);let c={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function l(e,n,r){let t=Object.keys(c).includes(n)?n:r;return c[t](e)}let i=e=>{let{defaultLocale:n="en-US"}=e,r=(0,s.Vi)().page.readingTimeData,c=(0,s.Jr)(),i=(0,s.e7)(),[a,d]=(0,o.useState)(l(r,c,n));return(0,o.useEffect)(()=>{d(l(r,c,n))},[c,r]),(0,t.jsx)("span",{"data-dark":String(i),className:"rp-reading-time",children:a})}}}]);