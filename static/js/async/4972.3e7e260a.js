"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["4972"],{56541:function(e,n,r){r.r(n),r.d(n,{default:()=>f});var s=r(52676),t=r(40453),a=r(20713);let i=r.p+"static/image/taro-init.254618bc.png",c=r.p+"static/image/taro-dev.2fce2698.png",o=r.p+"static/image/taro-build.9e7d52de.png",l=r.p+"static/image/taro-project-debugger.2741c483.png",p=r.p+"static/image/pnpm-run-debug.d5939528.png",d=r.p+"static/image/pnpm-run-debug-terminal.c3f6cf4b.png",h=r.p+"static/image/taro-debugger.46b809af.png",u=r.p+"static/image/platform-plugin-construct.3ae6410c.png",j=r.p+"static/image/extends.1add557e.png",x=r.p+"static/image/plugins.ca632e34.png";function m(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",input:"input",pre:"pre",blockquote:"blockquote",img:"img",h3:"h3",ol:"ol",h4:"h4",hr:"hr",strong:"strong"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"taro-源码揭秘4-每次-npm-run-devweapp-开发小程序build-编译打包是如何实现的",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘4-每次-npm-run-devweapp-开发小程序build-编译打包是如何实现的",children:"#"}),"Taro 源码揭秘：4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"]}),"\n",(0,s.jsx)(a.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["截至目前（",(0,s.jsx)(n.code,{children:"2024-08-16"}),"），",(0,s.jsxs)(n.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.3",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"taro 4.0"})," 正式版已经发布"]}),"，目前最新是 ",(0,s.jsx)(n.code,{children:"4.0.4"}),"，官方",(0,s.jsx)(n.code,{children:"4.0"}),"正式版本的介绍文章暂未发布。官方之前发过",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"学完本文，你将学到："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. 每次开发编译 npm run dev:weapp build 编译打包是如何实现的？\n2. 微信小程序端平台插件 @tarojs/plugin-platform-weapp 是如何实现的？\n3. 端平台插件基础抽象类 TaroPlatformBase、TaroPlatform 是如何实现的？\n4. 最终是如何调用 runner 执行 webpack 编译构建的？\n等等\n"})}),"\n",(0,s.jsxs)(n.p,{children:["经常使用 ",(0,s.jsx)(n.code,{children:"Taro"})," 开发小程序的小伙伴，一定日常使用 ",(0,s.jsx)(n.code,{children:"npm run dev:weapp"})," 等命令运行小程序。我们这篇文章就来解读这个命令背后，",(0,s.jsx)(n.code,{children:"Taro"})," 到底做了什么。\n",(0,s.jsx)(n.code,{children:"npm run dev:weapp"})," 对应的是 ",(0,s.jsx)(n.code,{children:"taro build --type weapp --watch"}),"。","\n",(0,s.jsx)(n.code,{children:"npm run build:weapp"})," 对应的是 ",(0,s.jsx)(n.code,{children:"taro build --type weapp"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["关于克隆项目、环境准备、如何调试代码等，参考",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章-准备工作、调试"}),"。后续文章基本不再过多赘述。写文章时最新的版本是 4.0.4，后续文章会持续揭秘最新源码，读者后续如果调试源码使用最新版本源码即可。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-调试源码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-调试源码",children:"#"}),"2. 调试源码"]}),"\n",(0,s.jsxs)(n.p,{children:["初始化 ",(0,s.jsx)(n.code,{children:"taro"})," 项目，方便调试，选择",(0,s.jsx)(n.code,{children:"React"}),"、",(0,s.jsx)(n.code,{children:"TS"}),"、",(0,s.jsx)(n.code,{children:"Less"}),"、",(0,s.jsx)(n.code,{children:"pnpm"}),"、",(0,s.jsx)(n.code,{children:"webpack5"}),"、",(0,s.jsx)(n.code,{children:"CLI内置默认模板"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx @taro/cli init taro4-debug\ncd taro4-debug\n# 安装依赖\npnpm i\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如图所示\n",(0,s.jsx)(n.img,{alt:"初始化项目",src:i})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 开发启动\npnpm run dev:weapp\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如图\n",(0,s.jsx)(n.img,{alt:"taro-dev",src:c})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 编译打包\npnpm run build:weapp\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如图\n",(0,s.jsx)(n.img,{alt:"taro-build",src:o})]}),"\n",(0,s.jsx)(n.p,{children:"我们来学习 taro 编译打包的源码。"}),"\n",(0,s.jsxs)(n.h3,{id:"21-调试方式1使用项目里的依赖",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-调试方式1使用项目里的依赖",children:"#"}),"2.1 调试方式1：使用项目里的依赖"]}),"\n",(0,s.jsxs)(n.p,{children:["克隆 ",(0,s.jsx)(n.code,{children:"taro"})," 项目"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/NervJS/taro.git\ncd taro\npnpm i\npnpm run build\n"})}),"\n",(0,s.jsx)(n.p,{children:"方式1调试截图如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"使用项目中的依赖调试",src:l})}),"\n",(0,s.jsxs)(n.p,{children:["优点，无需多余的配置，可以直接调试本身项目。\n缺点：安装的 ",(0,s.jsx)(n.code,{children:"taro"})," 依赖都是 ",(0,s.jsx)(n.code,{children:"dist"})," 目录，压缩过后的，不方便查看原始代码。"]}),"\n",(0,s.jsx)(n.p,{children:"我们使用调试方式2。"}),"\n",(0,s.jsxs)(n.h3,{id:"22-调试方式2使用-taro-源码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-调试方式2使用-taro-源码",children:"#"}),"2.2 调试方式2：使用 taro 源码"]}),"\n",(0,s.jsxs)(n.p,{children:["我把 ",(0,s.jsx)(n.code,{children:"taro"})," 源码和 ",(0,s.jsx)(n.code,{children:"taro4-debug"})," 克隆到了同一个目录 ",(0,s.jsx)(n.code,{children:"github"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["优点：可以调试本身不压缩的源码。因为 ",(0,s.jsx)(n.code,{children:"taro"})," 自身打包生成了对应的 ",(0,s.jsx)(n.code,{children:"sourcemap"})," 文件，所以可以调试源码文件。\n缺点："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["需要配置 ",(0,s.jsx)(n.code,{children:".vscode/launch.json"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"需要使用 pnpm link（更推荐）"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["或者需要在对应的 ",(0,s.jsx)(n.code,{children:"dist"})," 文件修改一些包的路径。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"221-配置vscodelaunchjson",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#221-配置vscodelaunchjson",children:"#"}),"2.2.1 配置",(0,s.jsx)(n.code,{children:".vscode/launch.json"})]}),"\n",(0,s.jsxs)(n.p,{children:['重点添加配置 "cwd": "/Users/ruochuan/git-source/github/taro4-debug"、 ',(0,s.jsx)(n.code,{children:'"args": ["build","--type","weapp" ]'})," 和 ",(0,s.jsx)(n.code,{children:'"console": "integratedTerminal"'})]}),"\n",(0,s.jsx)(n.p,{children:"我们配置调试微信小程序打包。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// .vscode/launch.json\n{\n  "version": "0.2.0",\n  "configurations": [\n    {\n      "type": "node",\n      "request": "launch",\n      "name": "CLI debug",\n      "program": "${workspaceFolder}/packages/taro-cli/bin/taro",\n      "cwd": "/Users/ruochuan/git-source/github/taro4-debug",\n      "args": [\n        "build",\n        "--type",\n        "weapp",\n      ],\n      "console": "integratedTerminal",\n      "skipFiles": ["<node_internals>/**"]\n    },\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.h4,{id:"222-pnpm-run-debug-内置命令更推荐",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#222-pnpm-run-debug-内置命令更推荐",children:"#"}),"2.2.2 pnpm run debug 内置命令（更推荐）"]}),"\n",(0,s.jsxs)(n.p,{children:["Taro 4.0.7 新增了 ",(0,s.jsx)(n.code,{children:"pnpm run debug"})," 命令。"]}),"\n",(0,s.jsx)(n.p,{children:"看源码时，开源项目的 github 仓库中的贡献文档或者文档中的贡献文档要重点看。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/CONTRIBUTING-GUIDE",rel:"noopener noreferrer",target:"_blank",children:"Taro 文档 - 贡献指南"}),"，",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/main/CONTRIBUTING.md",rel:"noopener noreferrer",target:"_blank",children:"CONTRIBUTING.md"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pnpm-run-debug",src:p})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 进入 taro 源码项目\ncd taro\n# 运行 debug 项目 --packages 是初始化的 taro4-debug 项目中依赖的包，或者自己想调试的包\npnpm run debug --projectPath /Users/ruochuan/git-source/github/taro4-debug --packages @tarojs/components,@tarojs/helper,@tarojs/plugin-platform-weapp,@tarojs/runtime,@tarojs/shared,@tarojs/taro,@tarojs/plugin-framework-react,@tarojs/react,@tarojs/cli,@tarojs/taro-loader,@tarojs/webpack5-runner,@tarojs/plugin-platform-alipay,@tarojs/plugin-platform-tt,@tarojs/plugin-platform-swan,@tarojs/plugin-platform-jd,@tarojs/plugin-platform-qq,@tarojs/plugin-platform-h5,@tarojs/plugin-platform-harmony-hybrid\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pnpm-run-debug-terminal",src:d})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 进入初始化的 taro4-debug 项目\ncd taro4-debug\n# 重新安装依赖\npnpm install\n"})}),"\n",(0,s.jsxs)(n.p,{children:["再用 ",(0,s.jsx)(n.code,{children:"VSCode"})," 打开 Taro 源码项目，运行和调试栏选择 ",(0,s.jsx)(n.code,{children:"CLI debug"}),"，调试方式2 调试截图如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"使用 taro 源码调试",src:h})}),"\n",(0,s.jsxs)(n.p,{children:["有时 ",(0,s.jsx)(n.code,{children:"pnpm link"})," 可能不生效，可以使用这个方法。"]}),"\n",(0,s.jsxs)(n.h4,{id:"223-pnpm-link-无效时修改以下两个包的路径",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#223-pnpm-link-无效时修改以下两个包的路径",children:"#"}),"2.2.3 pnpm link 无效时，修改以下两个包的路径"]}),"\n",(0,s.jsx)(n.p,{children:"本文中只涉及这两个包，所以只需要改这两个即可。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@tarojs/plugin-platform-weapp"})," => ",(0,s.jsx)(n.code,{children:"../taro/packages/taro-platform-weapp/index.js"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@tarojs/webpack5-runner"})," => ",(0,s.jsx)(n.code,{children:"../taro/packages/taro-webpack5-runner/index.js"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"对应的具体代码位置如下"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// packages/taro-cli/dist/cli.js\nswitch (platform) {\n	// 省略一些平台\n	case 'weapp': {\n		kernel.optsPlugins.push(path.resolve(`../taro/packages/taro-platform-${platform}/index.js`))\n		// kernel.optsPlugins.push(`@tarojs/plugin-platform-${platform}`);\n		break;\n	}\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// packages/taro-service/dist/platform-plugin-base/mini.js\ngetRunner() {\n	return __awaiter(this, void 0, void 0, function* () {\n		const { appPath } = this.ctx.paths;\n		const { npm } = this.helper;\n		const runnerPkg = this.compiler === 'vite' ? '@tarojs/vite-runner' : '@tarojs/webpack5-runner';\n		// const runner = yield npm.getNpmPkg(runnerPkg, appPath);\n		const runner = require(path.resolve('../taro/packages/taro-webpack5-runner/index.js'));\n		return runner.bind(null, appPath);\n	});\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"不配置的话，不会调用对应的 taro 文件源码，而是调用项目中的依赖包源码，路径不对。"}),"\n",(0,s.jsxs)(n.h2,{id:"3-command-build-命令",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-command-build-命令",children:"#"}),"3. command build 命令"]}),"\n",(0,s.jsxs)(n.p,{children:["根据前面两篇 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. taro cli init"}),"、",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. taro 插件机制"})," 文章，我们可以得知：",(0,s.jsx)(n.code,{children:"taro build"})," 初始化命令，最终调用的是 ",(0,s.jsx)(n.code,{children:"packages/taro-cli/src/presets/commands/build.ts"})," 文件中的 ",(0,s.jsx)(n.code,{children:"ctx.registerCommand"})," 注册的 ",(0,s.jsx)(n.code,{children:"build"})," 命令行的 ",(0,s.jsx)(n.code,{children:"fn"})," 函数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-cli/src/presets/commands/build.ts\nimport {\n  MessageKind,\n  validateConfig\n} from '@tarojs/plugin-doctor'\n\nimport * as hooks from '../constant'\n\nimport type { IPluginContext } from '@tarojs/service'\n\nexport default (ctx: IPluginContext) => {\n  ctx.registerCommand({\n    name: 'build',\n    optionsMap: {\n      '--type [typeName]': 'Build type, weapp/swan/alipay/tt/qq/jd/h5/rn',\n      '--watch': 'Watch mode',\n      // 省略若干代码\n      '--no-check': 'Do not check config is valid or not',\n    },\n    synopsisList: [\n      'taro build --type weapp',\n      'taro build --type weapp --watch',\n      // 省略若干代码\n    ],\n    async fn(opts) {\n      const { options, config, _ } = opts\n      const { platform, isWatch, blended, newBlended, withoutBuild, noInjectGlobalStyle, noCheck } = options\n      const { fs, chalk, PROJECT_CONFIG } = ctx.helper\n      const { outputPath, configPath } = ctx.paths\n\n      if (!configPath || !fs.existsSync(configPath)) {\n        console.log(chalk.red(`找不到项目配置文件${PROJECT_CONFIG}，请确定当前目录是 Taro 项目根目录!`))\n        process.exit(1)\n      }\n\n      if (typeof platform !== 'string') {\n        console.log(chalk.red('请传入正确的编译类型！'))\n        process.exit(0)\n      }\n\n      // 校验 Taro 项目配置\n      if (!noCheck) {\n        const checkResult = await checkConfig({\n          projectConfig: ctx.initialConfig,\n          helper: ctx.helper\n        })\n        if (!checkResult.isValid) {\n        // 校验失败，退出\n        }\n      }\n\n      const isProduction = process.env.NODE_ENV === 'production' || !isWatch\n\n      // dist folder\n	  //   确保输出路径存在，如果不存在就创建\n      fs.ensureDirSync(outputPath)\n\n      // is build native components mode?\n      const isBuildNativeComp = _[1] === 'native-components'\n\n      await ctx.applyPlugins(hooks.ON_BUILD_START)\n      await ctx.applyPlugins({\n        name: platform,\n        opts: {\n          config: {\n            ...config,\n            isWatch,\n            mode: isProduction ? 'production' : 'development',\n			// 省略若干参数和若干钩子\n          },\n        },\n      })\n      await ctx.applyPlugins(hooks.ON_BUILD_COMPLETE)\n    },\n  })\n}\n\nasync function checkConfig ({ projectConfig, helper }) {\n  const result = await validateConfig(projectConfig, helper)\n  return result\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Taro"})," ",(0,s.jsx)(n.code,{children:"build"})," 插件主要做了以下几件事："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["判断 ",(0,s.jsx)(n.code,{children:"config/index"})," 配置文件是否存在，如果不存在，则报错退出程序。"]}),"\n",(0,s.jsxs)(n.li,{children:["判断 ",(0,s.jsx)(n.code,{children:"platform"})," 参数是否是字符串，这里是 ",(0,s.jsx)(n.code,{children:"weapp"}),"，如果不是，退出程序。"]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"@tarojs/plugin-doctor"})," 中的 ",(0,s.jsx)(n.code,{children:"validateConfig"})," 方法 (",(0,s.jsx)(n.code,{children:"checkConfig"}),") 函数校验配置文件 ",(0,s.jsx)(n.code,{children:"config/index"}),"，如果配置文件出错，退出程序。"]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"ctx.applyPlugins(hooks.ON_BUILD_START)"})," （编译开始）",(0,s.jsx)(n.code,{children:"onBuildStart"})," 钩子。"]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"ctx.applyPlugins({ name: platform, })"})," （调用 weapp） 钩子。"]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"ctx.applyPlugins(hooks.ON_BUILD_COMPLETE)"})," （编译结束）",(0,s.jsx)(n.code,{children:"onBuildComplete"})," 钩子。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"其中"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"await ctx.applyPlugins({\n  name: platform,\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["调用的是端平台插件，本文以微信小程序为例，所以调用的是 weapp。对应的源码文件路径是：",(0,s.jsx)(n.code,{children:"packages/taro-platform-weapp/src/index.ts"}),"。我们来看具体实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-端平台插件-weapp",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-端平台插件-weapp",children:"#"}),"4. 端平台插件 Weapp"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/platform-plugin/",rel:"noopener noreferrer",target:"_blank",children:"Taro文档 - 端平台插件"})," 中，有对端平台插件的比较详细的描述，可以参考学习。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"文档中的端平台插件架构图",src:u})}),"\n",(0,s.jsx)(n.p,{children:"我们接着学习微信小程序端平台插件源码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-platform-weapp/src/index.ts\nimport Weapp from './program'\n\nimport type { IPluginContext } from '@tarojs/service'\n\n// 让其它平台插件可以继承此平台\nexport { Weapp }\n\nexport interface IOptions {\n  enablekeyboardAccessory?: boolean\n}\n\nexport default (ctx: IPluginContext, options: IOptions) => {\n  ctx.registerPlatform({\n    name: 'weapp',\n    useConfigName: 'mini',\n    async fn ({ config }) {\n      const program = new Weapp(ctx, config, options || {})\n      await program.start()\n    }\n  })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"重点就是这两行代码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const program = new Weapp(ctx, config, options || {})\nawait program.start()\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ctx.registerPlatform"})," 注册 ",(0,s.jsx)(n.code,{children:"weapp"})," 平台插件，调用 ",(0,s.jsx)(n.code,{children:"Weapp"})," 构造函数，传入 ",(0,s.jsx)(n.code,{children:"ctx"})," 、",(0,s.jsx)(n.code,{children:"config"})," 和 ",(0,s.jsx)(n.code,{children:"options"})," 等配置。再调用实例对象的 ",(0,s.jsx)(n.code,{children:"start"})," 方法。"]}),"\n",(0,s.jsxs)(n.h2,{id:"5-new-weapp-构造函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-new-weapp-构造函数",children:"#"}),"5. new Weapp 构造函数"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"packages/taro-platform-weapp/src/program.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-platform-weapp/src/program.ts\nimport { TaroPlatformBase } from '@tarojs/service'\n\nimport { components } from './components'\nimport { Template } from './template'\n\nimport type { IOptions } from './index'\n\nconst PACKAGE_NAME = '@tarojs/plugin-platform-weapp'\n\nexport default class Weapp extends TaroPlatformBase {\n  template: Template\n  platform = 'weapp'\n  globalObject = 'wx'\n  projectConfigJson: string = this.config.projectConfigName || 'project.config.json'\n  runtimePath = `${PACKAGE_NAME}/dist/runtime`\n  taroComponentsPath = `${PACKAGE_NAME}/dist/components-react`\n  fileType = {\n    templ: '.wxml',\n    style: '.wxss',\n    config: '.json',\n    script: '.js',\n    xs: '.wxs'\n  }\n\n  /**\n   * 1. setupTransaction - init\n   * 2. setup\n   * 3. setupTransaction - close\n   * 4. buildTransaction - init\n   * 5. build\n   * 6. buildTransaction - close\n   */\n  constructor (ctx, config, pluginOptions?: IOptions) {\n    super(ctx, config)\n    this.template = new Template(pluginOptions)\n    this.setupTransaction.addWrapper({\n      close () {\n		//   增加组件或修改组件属性\n        this.modifyTemplate(pluginOptions)\n		// 修改 Webpack 配置\n        this.modifyWebpackConfig()\n      }\n    })\n  }\n  //  省略代码 modifyTemplate 和 modifyWebpackConfig 具体实现\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"class Weapp"})," 继承于抽象类 ",(0,s.jsx)(n.code,{children:"TaroPlatformBase"})," 继承于抽象类 ",(0,s.jsx)(n.code,{children:"TaroPlatform"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如图所示：\n",(0,s.jsx)(n.img,{alt:"extends",src:j})]}),"\n",(0,s.jsxs)(n.p,{children:["关于抽象类和更多类相关，可以参考：\n",(0,s.jsx)(n.a,{href:"https://ts.xcatliu.com/advanced/class.html",rel:"noopener noreferrer",target:"_blank",children:"TypeScript 入门教程 - 类"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n",(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/classes.html",rel:"noopener noreferrer",target:"_blank",children:"Classes"}),"(",(0,s.jsx)(n.a,{href:"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Classes.html",rel:"noopener noreferrer",target:"_blank",children:"中文版"}),")\n",(0,s.jsx)(n.a,{href:"http://es6.ruanyifeng.com/#docs/class",rel:"noopener noreferrer",target:"_blank",children:"ECMAScript 6 入门 - Class"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这样抽象的好处，在于其他端平台插件 ",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro-plugin-platform-xhs",rel:"noopener noreferrer",target:"_blank",children:"比如小红书"})," 基于这个抽象类扩展继承就比较方便。"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-taroplatform-端平台插件抽象类",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-taroplatform-端平台插件抽象类",children:"#"}),"6. TaroPlatform 端平台插件抽象类"]}),"\n",(0,s.jsxs)(n.h3,{id:"61-transaction-事务",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-transaction-事务",children:"#"}),"6.1 Transaction 事务"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/platform-plugin-base/platform.ts\ninterface IWrapper {\n  init? (): void\n  close? (): void\n}\n\nexport class Transaction<T = TaroPlatform> {\n  wrappers: IWrapper[] = []\n\n  async perform (fn: Func, scope: T, ...args: any[]) {\n    this.initAll(scope)\n    await fn.call(scope, ...args)\n    this.closeAll(scope)\n  }\n\n  initAll (scope: T) {\n    const wrappers = this.wrappers\n    wrappers.forEach(wrapper => wrapper.init?.call(scope))\n  }\n\n  closeAll (scope: T) {\n    const wrappers = this.wrappers\n    wrappers.forEach(wrapper => wrapper.close?.call(scope))\n  }\n\n  addWrapper (wrapper: IWrapper) {\n    this.wrappers.push(wrapper)\n  }\n}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样的好处在于，方便按顺序执行 ",(0,s.jsx)(n.code,{children:"init"})," ",(0,s.jsx)(n.code,{children:"perform"})," ",(0,s.jsx)(n.code,{children:"close"})," 函数。我们也可以在工作中使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们接着来看 ",(0,s.jsx)(n.code,{children:"class TaroPlatform"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/platform-plugin-base/platform.ts\nimport { PLATFORM_TYPE } from '@tarojs/shared'\n\nimport type { Func } from '@tarojs/taro/types/compile'\nimport type { IPluginContext, TConfig } from '../utils/types'\n\nconst VALID_COMPILER = ['webpack5', 'vite']\nconst DEFAULT_COMPILER = 'webpack5'\n\nexport default abstract class TaroPlatform<T extends TConfig = TConfig> {\n  protected ctx: IPluginContext\n  protected config: T\n  protected helper: IPluginContext['helper']\n  protected compiler: string\n\n  abstract platformType: PLATFORM_TYPE\n  abstract platform: string\n  abstract runtimePath: string | string[]\n\n  protected setupTransaction = new Transaction<this>()\n  protected buildTransaction = new Transaction<this>()\n\n  constructor (ctx: IPluginContext, config: T) {\n    this.ctx = ctx\n    this.helper = ctx.helper\n    this.config = config\n    this.updateOutputPath(config)\n    const _compiler = config.compiler\n    this.compiler = typeof _compiler === 'object' ? _compiler.type : _compiler\n    // Note: 兼容 webpack4 和不填写 compiler 的情况，默认使用 webpack5\n    if (!VALID_COMPILER.includes(this.compiler)) {\n      this.compiler = DEFAULT_COMPILER\n    }\n  }\n//   拆开下方\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"62-emptyoutputdir-清空输出的文件夹等",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-emptyoutputdir-清空输出的文件夹等",children:"#"}),"6.2 emptyOutputDir 清空输出的文件夹等"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 清空输出的文件夹\nprotected emptyOutputDir (excludes: Array<string | RegExp> = []) {\n	const { outputPath } = this.ctx.paths\n	this.helper.emptyDirectory(outputPath, { excludes })\n}\n\n/**\n * 如果分端编译详情 webpack 配置了 output 则需更新 outputPath 位置\n */\nprivate updateOutputPath (config: TConfig) {\n	const platformPath = config.output?.path\n	if (platformPath) {\n		this.ctx.paths.outputPath = platformPath\n	}\n}\n\n/**\n * 调用 runner 开启编译\n */\nabstract start(): Promise<void>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们来看 ",(0,s.jsx)(n.code,{children:"TaroPlatformBase"})," 的实现"]}),"\n",(0,s.jsxs)(n.h2,{id:"7-taroplatformbase-端平台插件基础抽象类",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-taroplatformbase-端平台插件基础抽象类",children:"#"}),"7. TaroPlatformBase 端平台插件基础抽象类"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/platform-plugin-base/mini.ts\nimport * as path from 'node:path'\n\nimport { recursiveMerge, taroJsMiniComponentsPath } from '@tarojs/helper'\nimport { isObject, PLATFORM_TYPE } from '@tarojs/shared'\n\nimport { getPkgVersion } from '../utils/package'\nimport TaroPlatform from './platform'\n\nimport type { RecursiveTemplate, UnRecursiveTemplate } from '@tarojs/shared/dist/template'\nimport type { TConfig } from '../utils/types'\n\ninterface IFileType {\n  templ: string\n  style: string\n  config: string\n  script: string\n  xs?: string\n}\n\nexport abstract class TaroPlatformBase<T extends TConfig = TConfig> extends TaroPlatform<T> {\n  platformType = PLATFORM_TYPE.MINI\n\n  abstract globalObject: string\n  abstract fileType: IFileType\n  abstract template: RecursiveTemplate | UnRecursiveTemplate\n  // Note: 给所有的小程序平台一个默认的 taroComponentsPath\n  taroComponentsPath: string = taroJsMiniComponentsPath\n  projectConfigJson?: string\n\n  private projectConfigJsonOutputPath: string\n\n  /**\n   * 调用 runner 开启编译\n   */\n  public async start () {\n    await this.setup()\n    await this.build()\n  }\n}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"start"})," 实现，",(0,s.jsx)(n.code,{children:"setup"})," 再执行 ",(0,s.jsx)(n.code,{children:"build"}),"。我们来看 setup 函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"71-setup",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-setup",children:"#"}),"7.1 setup"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * 1. 清空 dist 文件夹\n * 2. 输出编译提示\n * 3. 生成 project.config.json\n */\nprivate async setup () {\n	await this.setupTransaction.perform(this.setupImpl, this)\n	this.ctx.onSetupClose?.(this)\n}\n\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"private setupImpl () {\n	const { output } = this.config\n	// webpack5 原生支持 output.clean 选项，但是 webpack4 不支持， 为统一行为，这里做一下兼容\n	// （在 packages/taro-mini-runner/src/webpack/chain.ts 和 packages/taro-webpack-runner/src/utils/chain.ts 的 makeConfig 中对 clean 选项做了过滤）\n	// 仅 output.clean 为 false 时不清空输出目录\n	// eslint-disable-next-line eqeqeq\n	if (output == undefined || output.clean == undefined || output.clean === true) {\n		this.emptyOutputDir()\n	} else if (isObject(output.clean)) {\n		this.emptyOutputDir(output.clean.keep || [])\n	}\n	this.printDevelopmentTip(this.platform)\n	if (this.projectConfigJson) {\n		this.generateProjectConfig(this.projectConfigJson)\n	}\n	// 省略以下这两部分的代码\n	// 打印开发者工具-项目目录\n	// Webpack5 代码自动热重载\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"taro-dev",src:c})}),"\n",(0,s.jsxs)(n.p,{children:["我们继续来看 ",(0,s.jsx)(n.code,{children:"build"})," 函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"72-build",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-build",children:"#"}),"7.2 build"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n   * 调用 runner 开始编译\n   * @param extraOptions 需要额外传入 runner 的配置项\n   */\n  private async build (extraOptions = {}) {\n    this.ctx.onBuildInit?.(this)\n    await this.buildTransaction.perform(this.buildImpl, this, extraOptions)\n  }\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"private async buildImpl (extraOptions = {}) {\n    const runner = await this.getRunner()\n    const options = this.getOptions(\n      Object.assign(\n        {\n          runtimePath: this.runtimePath,\n          taroComponentsPath: this.taroComponentsPath\n        },\n        extraOptions\n      )\n    )\n    await runner(options)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们来看下 ",(0,s.jsx)(n.code,{children:"getRunner"})," 的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * 返回当前项目内的 runner 包\n */\nprotected async getRunner () {\n	const { appPath } = this.ctx.paths\n	const { npm } = this.helper\n\n	const runnerPkg = this.compiler === 'vite' ? '@tarojs/vite-runner' : '@tarojs/webpack5-runner'\n\n	const runner = await npm.getNpmPkg(runnerPkg, appPath)\n\n	return runner.bind(null, appPath)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"build"})," 函数最后调用 ",(0,s.jsx)(n.code,{children:"runner"})," 函数。",(0,s.jsx)(n.code,{children:"appPath"})," 项目路径是",(0,s.jsx)(n.code,{children:"/Users/ruochuan/git-source/github/taro4-debug"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["初始化项目使用的 ",(0,s.jsx)(n.code,{children:"webpack5"})," 所以使用的是 ",(0,s.jsx)(n.code,{children:"@tarojs/webpack5-runner"})," 我们来看它的具体实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"8-runner--tarojswebpack5-runner",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-runner--tarojswebpack5-runner",children:"#"}),"8. runner => @tarojs/webpack5-runner"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"package.json"}),' 属性 "main": "index.js" 入口文件 ',(0,s.jsx)(n.code,{children:"index.js"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (process.env.TARO_PLATFORM === 'web') {\n  module.exports = require('./dist/index.h5.js').default\n} else if (process.env.TARO_PLATFORM === 'harmony' || process.env.TARO_ENV === 'harmony') {\n  module.exports = require('./dist/index.harmony.js').default\n} else {\n  module.exports = require('./dist/index.mini.js').default\n}\n\nmodule.exports.default = module.exports\n"})}),"\n",(0,s.jsxs)(n.p,{children:["本文中打包微信小程序，根据 ",(0,s.jsx)(n.code,{children:"process.env.TARO_PLATFORM"})," 和 ",(0,s.jsx)(n.code,{children:"process.env.TARO_ENV"})," 调用的是打包后的文件 ",(0,s.jsx)(n.code,{children:"dist/index.mini.js"}),"，源码文件是 ",(0,s.jsx)(n.code,{children:"packages/taro-webpack5-runner/src/index.mini.ts"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/index.mini.ts\n\nimport webpack from 'webpack'\n//   省略若干代码\nexport default async function build (appPath: string, rawConfig: IMiniBuildConfig): Promise<Stats | void> {\n  const combination = new MiniCombination(appPath, rawConfig)\n  await combination.make()\n  //   省略若干代码\n\n  const webpackConfig = combination.chain.toConfig()\n  const config = combination.config\n\n  return new Promise<Stats | void>((resolve, reject) => {\n    if (config.withoutBuild) return\n\n    const compiler = webpack(webpackConfig)\n\n    const callback = async (err: Error, stats: Stats) => {\n    //   省略若干代码\n      onFinish(null, stats)\n      resolve(stats)\n    }\n\n    if (config.isWatch) {\n      compiler.watch({\n        aggregateTimeout: 300,\n        poll: undefined\n      }, callback)\n    } else {\n      compiler.run((err: Error, stats: Stats) => {\n        compiler.close(err2 => callback(err || err2, stats))\n      })\n    }\n  })\n}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"const compiler = webpack(webpackConfig)"})," 使用 ",(0,s.jsx)(n.code,{children:"webpack"})," 编译。这部分代码比较多。后续有空再写 ",(0,s.jsx)(n.code,{children:"webpack"})," 编译的文章。"]}),"\n",(0,s.jsxs)(n.h2,{id:"9-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-总结",children:"#"}),"9. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["我们学习了两种方式如何调试 ",(0,s.jsx)(n.code,{children:"taro"})," build 部分的源码。"]}),"\n",(0,s.jsx)(n.p,{children:"我们来总结下，打包构建流程简单梳理。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"调用 taro 插件 build"}),"\n",(0,s.jsx)(n.li,{children:"调用端平台插件 Weapp"}),"\n",(0,s.jsx)(n.li,{children:"平台插件继承自 TaroPlatformBase 端平台插件基础抽象类"}),"\n",(0,s.jsx)(n.li,{children:"平台插件继承自 TaroPlatform 端平台插件抽象类"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"简版代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class Weapp extends TaroPlatformBase{}\nexport abstract class TaroPlatformBase extends TaroPlatform{\n	public async start () {\n		/**\n		 * 1. 清空 dist 文件夹\n		 * 2. 输出编译提示\n		 * 3. 生成 project.config.json\n		 */\n		await this.setup()\n		/**\n		 * 调用 runner 开始编译\n		 * @param extraOptions 需要额外传入 runner 的配置项\n		 */\n		await this.build()\n	}\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export default (ctx: IPluginContext, options: IOptions) => {\nctx.registerPlatform({\n    name: 'weapp',\n    useConfigName: 'mini',\n    async fn ({ config }) {\n      const program = new Weapp(ctx, config, options || {})\n      await program.start()\n    }\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最后调用的是 ",(0,s.jsx)(n.code,{children:"@tarojs/webpack5-runner"}),"，",(0,s.jsx)(n.code,{children:"webpack"})," 编译打包生成项目文件。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"packages/taro-service/dist/Kernel.js"})," 的 ",(0,s.jsx)(n.code,{children:"applyPlugins"})," 方法中，打印出 ",(0,s.jsx)(n.code,{children:"plugins-name"})," ，调用插件的依次顺序是："]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"plugins",src:x}),"也是开发者开发插件配置钩子的执行。"]}),"\n",(0,s.jsxs)(n.p,{children:["更多 ",(0,s.jsx)(n.code,{children:"Taro"})," 端平台插件实现细节可参考",(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/platform-plugin/",rel:"noopener noreferrer",target:"_blank",children:"Taro文档 - 端平台插件"}),"，更多 ",(0,s.jsx)(n.code,{children:"Taro"})," 实现细节也可以参考",(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/implement-note",rel:"noopener noreferrer",target:"_blank",children:"官方文档：Taro 实现细节"}),"。"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,s.jsx)(n.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后可以持续关注我",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(m,e)})):m(e)}let f=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["taro%2Fcli-build%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-调试源码",text:"2. 调试源码",depth:2},{id:"21-调试方式1使用项目里的依赖",text:"2.1 调试方式1：使用项目里的依赖",depth:3},{id:"22-调试方式2使用-taro-源码",text:"2.2 调试方式2：使用 taro 源码",depth:3},{id:"221-配置vscodelaunchjson",text:"2.2.1 配置`.vscode/launch.json`",depth:4},{id:"222-pnpm-run-debug-内置命令更推荐",text:"2.2.2 pnpm run debug 内置命令（更推荐）",depth:4},{id:"223-pnpm-link-无效时修改以下两个包的路径",text:"2.2.3 pnpm link 无效时，修改以下两个包的路径",depth:4},{id:"3-command-build-命令",text:"3. command build 命令",depth:2},{id:"4-端平台插件-weapp",text:"4. 端平台插件 Weapp",depth:2},{id:"5-new-weapp-构造函数",text:"5. new Weapp 构造函数",depth:2},{id:"6-taroplatform-端平台插件抽象类",text:"6. TaroPlatform 端平台插件抽象类",depth:2},{id:"61-transaction-事务",text:"6.1 Transaction 事务",depth:3},{id:"62-emptyoutputdir-清空输出的文件夹等",text:"6.2 emptyOutputDir 清空输出的文件夹等",depth:3},{id:"7-taroplatformbase-端平台插件基础抽象类",text:"7. TaroPlatformBase 端平台插件基础抽象类",depth:2},{id:"71-setup",text:"7.1 setup",depth:3},{id:"72-build",text:"7.2 build",depth:3},{id:"8-runner--tarojswebpack5-runner",text:"8. runner => @tarojs/webpack5-runner",depth:2},{id:"9-总结",text:"9. 总结",depth:2}],title:"Taro 源码揭秘：4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？",headingTitle:"Taro 源码揭秘：4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(e,n,r){r.d(n,{Z:()=>o});var s=r(52676),t=r(75271),a=r(92815);r(18544);let i={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function c(e,n,r){let s=Object.keys(i).includes(n)?n:r;return i[s](e)}let o=e=>{let{defaultLocale:n="en-US"}=e,r=(0,a.Vi)().page.readingTimeData,i=(0,a.Jr)(),o=(0,a.e7)(),[l,p]=(0,t.useState)(c(r,i,n));return(0,t.useEffect)(()=>{p(c(r,i,n))},[i,r]),(0,s.jsx)("span",{"data-dark":String(o),className:"rp-reading-time",children:l})}}}]);