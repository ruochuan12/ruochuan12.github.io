"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["8333"],{60332:function(e,n,r){e.exports=r.p+"static/image/wechat-official-accounts-mini.44481959.png"},38135:function(e,n,r){r.r(n),r.d(n,{default:()=>p});var s=r(52676),t=r(40453),i=r(20713);let o=r.p+"static/image/BrowserClient-instance.1c46338c.png",c=r.p+"static/image/Hub-instance-new.7ad33e38.png",a=r.p+"static/image/captureMessageCallStack.c4cf1529.png";var d=r(60332);function l(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",code:"code",strong:"strong",h3:"h3",pre:"pre",h4:"h4",img:"img"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"学习-sentry-源码整体架构打造属于自己的前端异常监控sdk",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#学习-sentry-源码整体架构打造属于自己的前端异常监控sdk",children:"#"}),"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK"]}),"\n",(0,s.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这是",(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"第四篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。文章学习的是打包整合后的代码，不是实际仓库中的拆分的代码。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/sentry-analysis.git",rel:"noopener noreferrer",target:"_blank",children:"本文仓库地址"}),"：",(0,s.jsx)(n.code,{children:"git clone https://github.com/ruochuan12/sentry-analysis.git"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"文章如下："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d39d2cbf265da1bc23fbd42",rel:"noopener noreferrer",target:"_blank",children:"学习 jQuery 源码整体架构，打造属于自己的 js 类库"}),"\n2.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d4bf94de51d453bb13b65dc",rel:"noopener noreferrer",target:"_blank",children:"学习 underscore 源码整体架构，打造属于自己的函数式编程类库"}),"\n3.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d767e1d6fb9a06b032025ea",rel:"noopener noreferrer",target:"_blank",children:"学习 lodash 源码整体架构，打造属于自己的函数式编程类库"}),"\n4.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dba5a39e51d452a2378348a",rel:"noopener noreferrer",target:"_blank",children:"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK"}),"\n5.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dd4e61a6fb9a05a5c010af0",rel:"noopener noreferrer",target:"_blank",children:"学习 vuex 源码整体架构，打造属于自己的状态管理库"}),"\n6.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5df349b5518825123751ba66",rel:"noopener noreferrer",target:"_blank",children:"学习 axios 源码整体架构，打造属于自己的请求库"}),"\n7.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5e69925cf265da571e262fe6",rel:"noopener noreferrer",target:"_blank",children:"学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理"}),"\n8.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5ee63b7d51882542fc6265ad",rel:"noopener noreferrer",target:"_blank",children:"学习 redux 源码整体架构，深入理解 redux 及其中间件原理"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["感兴趣的读者可以点击阅读。","\n其他源码计划中的有：",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/express-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"express"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vue-router-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-rotuer"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/react-redux-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"react-redux"})})," 等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。"]}),"\n",(0,s.jsxs)(n.p,{children:["源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。","\n所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"导读"}),"\n本文通过梳理前端错误监控知识、介绍",(0,s.jsx)(n.code,{children:"sentry"}),"错误监控原理、",(0,s.jsx)(n.code,{children:"sentry"}),"初始化、",(0,s.jsx)(n.code,{children:"Ajax"}),"上报、",(0,s.jsx)(n.code,{children:"window.onerror、window.onunhandledrejection"}),"几个方面来学习",(0,s.jsx)(n.code,{children:"sentry"}),"的源码。"]}),"\n",(0,s.jsxs)(n.p,{children:["开发微信小程序，想着搭建小程序错误监控方案。最近用了丁香园 开源的",(0,s.jsx)(n.code,{children:"Sentry"})," 小程序 ",(0,s.jsx)(n.code,{children:"SDK"}),(0,s.jsx)(n.a,{href:"https://github.com/lizhiyao/sentry-miniapp",rel:"noopener noreferrer",target:"_blank",children:"sentry-miniapp"}),"。\n顺便研究下",(0,s.jsxs)(n.a,{href:"https://github.com/getsentry/sentry-javascript",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"sentry-javascript"}),"仓库"]})," 的源码整体架构，于是有了这篇文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文分析的是打包后未压缩的源码，源码总行数五千余行，链接地址是：",(0,s.jsx)(n.a,{href:"https://browser.sentry-cdn.com/5.7.1/bundle.js",rel:"noopener noreferrer",target:"_blank",children:"https://browser.sentry-cdn.com/5.7.1/bundle.js"}),"， 版本是",(0,s.jsx)(n.code,{children:"v5.7.1"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文示例等源代码在这我的",(0,s.jsx)(n.code,{children:"github"}),"博客中",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog/blob/master/docs/sentry/README.md",rel:"noopener noreferrer",target:"_blank",children:"github blog sentry"}),"，需要的读者可以点击查看，如果觉得不错，可以顺便",(0,s.jsx)(n.code,{children:"star"}),"一下。"]}),"\n",(0,s.jsx)(n.p,{children:"看源码前先来梳理下前端错误监控的知识。"}),"\n",(0,s.jsxs)(n.h2,{id:"2-前端错误监控知识",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-前端错误监控知识",children:"#"}),"2. 前端错误监控知识"]}),"\n",(0,s.jsxs)(n.p,{children:["摘抄自 ",(0,s.jsx)(n.a,{href:"https://coding.imooc.com/class/129.html",rel:"noopener noreferrer",target:"_blank",children:"慕课网视频教程：前端跳槽面试必备技巧"}),"\n",(0,s.jsx)(n.a,{href:"https://articles.jerryshi.com/learning/fe/js-interview-skill.html#_4-4-%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E7%B1%BB",rel:"noopener noreferrer",target:"_blank",children:"别人做的笔记：前端跳槽面试必备技巧-4-4 错误监控类"})]}),"\n",(0,s.jsxs)(n.h3,{id:"21-前端错误的分类",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-前端错误的分类",children:"#"}),"2.1 前端错误的分类"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1.即时运行错误：代码错误"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"try...catch"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"window.onerror"})," (也可以用",(0,s.jsx)(n.code,{children:"DOM2"}),"事件监听)"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.资源加载错误"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"object.onerror"}),": ",(0,s.jsx)(n.code,{children:"dom"}),"对象的",(0,s.jsx)(n.code,{children:"onerror"}),"事件"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"performance.getEntries()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Error"}),"事件捕获"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["3.",(0,s.jsxs)(n.strong,{children:["使用",(0,s.jsx)(n.code,{children:"performance.getEntries()"}),"获取网页图片加载错误"]})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"var allImgs = document.getElementsByTagName('image')"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"var loadedImgs = performance.getEntries().filter(i => i.initiatorType === 'img')"})}),"\n",(0,s.jsxs)(n.p,{children:["最后",(0,s.jsx)(n.code,{children:"allIms"}),"和",(0,s.jsx)(n.code,{children:"loadedImgs"}),"对比即可找出图片资源未加载项目"]}),"\n",(0,s.jsxs)(n.h3,{id:"22-error事件捕获代码示例",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-error事件捕获代码示例",children:"#"}),"2.2 Error事件捕获代码示例"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"window.addEventListener('error', function(e) {\n  console.log('捕获', e)\n}, true) // 这里只有捕获才能触发事件，冒泡是不能触发\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"23-上报错误的基本原理",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-上报错误的基本原理",children:"#"}),"2.3 上报错误的基本原理"]}),"\n",(0,s.jsxs)(n.p,{children:["1.采用",(0,s.jsx)(n.code,{children:"Ajax"}),"通信的方式上报"]}),"\n",(0,s.jsxs)(n.p,{children:["2.利用",(0,s.jsx)(n.code,{children:"Image"}),"对象上报 (主流方式)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Image"}),"上报错误方式：\n",(0,s.jsx)(n.code,{children:" (new Image()).src = 'https://ruochuan12.github.io/error?name=若川'"})]}),"\n",(0,s.jsxs)(n.h2,{id:"3-sentry-前端异常监控基本原理",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-sentry-前端异常监控基本原理",children:"#"}),"3. Sentry 前端异常监控基本原理"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.重写 ",(0,s.jsx)(n.code,{children:"window.onerror"})," 方法、重写 ",(0,s.jsx)(n.code,{children:"window.onunhandledrejection"})," 方法"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果不了解",(0,s.jsx)(n.code,{children:"onerror和onunhandledrejection"}),"方法的读者，可以看相关的",(0,s.jsx)(n.code,{children:"MDN"}),"文档。这里简要介绍一下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror",rel:"noopener noreferrer",target:"_blank",children:"MDN GlobalEventHandlers.onerror"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"window.onerror = function (message, source, lineno, colno, error) {\n	console.log('message, source, lineno, colno, error', message, source, lineno, colno, error);\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["参数：","\n",(0,s.jsx)(n.code,{children:"message"}),"：错误信息（字符串）。可用于",(0,s.jsx)(n.code,{children:'HTML onerror=""'}),"处理程序中的",(0,s.jsx)(n.code,{children:"event"}),"。","\n",(0,s.jsx)(n.code,{children:"source"}),"：发生错误的脚本",(0,s.jsx)(n.code,{children:"URL"}),"（字符串）","\n",(0,s.jsx)(n.code,{children:"lineno"}),"：发生错误的行号（数字）","\n",(0,s.jsx)(n.code,{children:"colno"}),"：发生错误的列号（数字）","\n",(0,s.jsx)(n.code,{children:"error"}),"：",(0,s.jsx)(n.code,{children:"Error"}),"对象（对象）"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/Events/unhandledrejection",rel:"noopener noreferrer",target:"_blank",children:"MDN unhandledrejection"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["当 ",(0,s.jsx)(n.code,{children:"Promise"})," 被 ",(0,s.jsx)(n.code,{children:"reject"})," 且没有 ",(0,s.jsx)(n.code,{children:"reject"})," 处理器的时候，会触发 ",(0,s.jsx)(n.code,{children:"unhandledrejection"})," 事件；这可能发生在 ",(0,s.jsx)(n.code,{children:"window"})," 下，但也可能发生在 ",(0,s.jsx)(n.code,{children:"Worker"})," 中。 这对于调试回退错误处理非常有用。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Sentry"})," 源码可以搜索 ",(0,s.jsx)(n.code,{children:"global.onerror"})," 定位到具体位置"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" GlobalHandlers.prototype._installGlobalOnErrorHandler = function () {\n	// 代码有删减\n	// 这里的 this._global 在浏览器中就是 window\n	this._oldOnErrorHandler = this._global.onerror;\n	this._global.onerror = function (msg, url, line, column, error) {}\n	// code ...\n }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同样，可以搜索",(0,s.jsx)(n.code,{children:"global.onunhandledrejection"})," 定位到具体位置"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"GlobalHandlers.prototype._installGlobalOnUnhandledRejectionHandler = function () {\n	// 代码有删减\n	this._oldOnUnhandledRejectionHandler = this._global.onunhandledrejection;\n	this._global.onunhandledrejection = function (e) {}\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["2.采用",(0,s.jsx)(n.code,{children:"Ajax"}),"上传"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["支持 ",(0,s.jsx)(n.code,{children:"fetch"})," 使用 ",(0,s.jsx)(n.code,{children:"fetch"}),"，否则使用　",(0,s.jsx)(n.code,{children:"XHR"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"BrowserBackend.prototype._setupTransport = function () {\n	// 代码有删减\n	if (supportsFetch()) {\n		return new FetchTransport(transportOptions);\n	}\n	return new XHRTransport(transportOptions);\n};\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["2.1 ",(0,s.jsx)(n.code,{children:"fetch"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"FetchTransport.prototype.sendEvent = function (event) {\n	var defaultOptions = {\n		body: JSON.stringify(event),\n		method: 'POST',\n		referrerPolicy: (supportsReferrerPolicy() ? 'origin' : ''),\n	};\n	return this._buffer.add(global$2.fetch(this.url, defaultOptions).then(function (response) { return ({\n		status: exports.Status.fromHttpCode(response.status),\n	}); }));\n};\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["2.2 ",(0,s.jsx)(n.code,{children:"XMLHttpRequest"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"XHRTransport.prototype.sendEvent = function (event) {\n	var _this = this;\n	return this._buffer.add(new SyncPromise(function (resolve, reject) {\n		// 熟悉的 XMLHttpRequest\n		var request = new XMLHttpRequest();\n		request.onreadystatechange = function () {\n			if (request.readyState !== 4) {\n				return;\n			}\n			if (request.status === 200) {\n				resolve({\n					status: exports.Status.fromHttpCode(request.status),\n				});\n			}\n			reject(request);\n		};\n		request.open('POST', _this.url);\n		request.send(JSON.stringify(event));\n	}));\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来主要通过Sentry初始化、如何",(0,s.jsx)(n.code,{children:"Ajax上报"}),"和",(0,s.jsx)(n.code,{children:"window.onerror、window.onunhandledrejection"}),"三条主线来学习源码。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"如果看到这里，暂时不想关注后面的源码细节，直接看后文小结1和2的两张图。或者可以点赞或收藏这篇文章，后续想看了再看。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-sentry-源码入口和出口",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-sentry-源码入口和出口",children:"#"}),"4. Sentry 源码入口和出口"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var Sentry = (function(exports){\n	// code ...\n\n    var SDK_NAME = 'sentry.javascript.browser';\n	var SDK_VERSION = '5.7.1';\n\n	// code ...\n	// 省略了导出的Sentry的若干个方法和属性\n	// 只列出了如下几个\n    exports.SDK_NAME = SDK_NAME;\n    exports.SDK_VERSION = SDK_VERSION;\n	// 重点关注 captureMessage\n    exports.captureMessage = captureMessage;\n	// 重点关注 init\n    exports.init = init;\n\n    return exports;\n}({}));\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"5-sentryinit-初始化-之-init-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-sentryinit-初始化-之-init-函数",children:"#"}),"5. Sentry.init 初始化 之 init 函数"]}),"\n",(0,s.jsx)(n.p,{children:"初始化"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 这里的dsn，是sentry.io网站会生成的。\nSentry.init({ dsn: 'xxx' });\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// options 是 {dsn: '...'}\nfunction init(options) {\n	// 如果options 是undefined，则赋值为 空对象\n	if (options === void 0) { options = {}; }\n	// 如果没传 defaultIntegrations 则赋值默认的\n	if (options.defaultIntegrations === undefined) {\n		options.defaultIntegrations = defaultIntegrations;\n	}\n	// 初始化语句\n	if (options.release === undefined) {\n		var window_1 = getGlobalObject();\n		// 这是给  sentry-webpack-plugin 插件提供的，webpack插件注入的变量。这里没用这个插件，所以这里不深究。\n		// This supports the variable that sentry-webpack-plugin injects\n		if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {\n			options.release = window_1.SENTRY_RELEASE.id;\n		}\n	}\n	// 初始化并且绑定\n	initAndBind(BrowserClient, options);\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"51-getglobalobjectinnodeenv-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-getglobalobjectinnodeenv-函数",children:"#"}),"5.1 getGlobalObject、inNodeEnv 函数"]}),"\n",(0,s.jsxs)(n.p,{children:["很多地方用到这个函数",(0,s.jsx)(n.code,{children:"getGlobalObject"}),"。其实做的事情也比较简单，就是获取全局对象。浏览器中是",(0,s.jsx)(n.code,{children:"window"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * 判断是否是node环境\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nfunction isNodeEnv() {\n	// tslint:disable:strict-type-predicates\n	return Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n}\nvar fallbackGlobalObject = {};\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nfunction getGlobalObject() {\n	return (isNodeEnv()\n	// 是 node 环境 赋值给 global\n		? global\n		: typeof window !== 'undefined'\n			? window\n			// 不是 window self 不是undefined 说明是 Web Worker 环境\n			: typeof self !== 'undefined'\n				? self\n				// 都不是，赋值给空对象。\n				: fallbackGlobalObject);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["继续看 ",(0,s.jsx)(n.code,{children:"initAndBind"})," 函数"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-initandbind-函数之-new-browserclientoptions",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-initandbind-函数之-new-browserclientoptions",children:"#"}),"6. initAndBind 函数之 new BrowserClient(options)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function initAndBind(clientClass, options) {\n	// 这里没有开启debug模式，logger.enable() 这句不会执行\n	if (options.debug === true) {\n		logger.enable();\n	}\n	getCurrentHub().bindClient(new clientClass(options));\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看出 ",(0,s.jsx)(n.code,{children:"initAndBind()"}),"，第一个参数是 ",(0,s.jsx)(n.code,{children:"BrowserClient"})," 构造函数，第二个参数是初始化后的",(0,s.jsx)(n.code,{children:"options"}),"。\n接着先看 构造函数 ",(0,s.jsx)(n.code,{children:"BrowserClient"}),"。\n另一条线 ",(0,s.jsx)(n.code,{children:"getCurrentHub().bindClient()"})," 先不看。"]}),"\n",(0,s.jsxs)(n.h3,{id:"61-browserclient-构造函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-browserclient-构造函数",children:"#"}),"6.1 BrowserClient 构造函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var BrowserClient = /** @class */ (function (_super) {\n	// `BrowserClient` 继承自`BaseClient`\n	__extends(BrowserClient, _super);\n	/**\n	 * Creates a new Browser SDK instance.\n	 *\n	 * @param options Configuration options for this SDK.\n	 */\n	function BrowserClient(options) {\n		if (options === void 0) { options = {}; }\n		// 把`BrowserBackend`，`options`传参给`BaseClient`调用。\n		return _super.call(this, BrowserBackend, options) || this;\n	}\n	return BrowserClient;\n}(BaseClient));\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"从代码中可以看出"}),"：\n",(0,s.jsx)(n.code,{children:"BrowserClient"})," 继承自",(0,s.jsx)(n.code,{children:"BaseClient"}),"，并且把",(0,s.jsx)(n.code,{children:"BrowserBackend"}),"，",(0,s.jsx)(n.code,{children:"options"}),"传参给",(0,s.jsx)(n.code,{children:"BaseClient"}),"调用。"]}),"\n",(0,s.jsxs)(n.p,{children:["先看 ",(0,s.jsx)(n.code,{children:"BrowserBackend"}),"，这里的",(0,s.jsx)(n.code,{children:"BaseClient"}),"，暂时不看。"]}),"\n",(0,s.jsxs)(n.p,{children:["看",(0,s.jsx)(n.code,{children:"BrowserBackend"}),"之前，先提一下继承、继承静态属性和方法。"]}),"\n",(0,s.jsxs)(n.h3,{id:"62-__extendsextendstatics-打包代码实现的继承",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-__extendsextendstatics-打包代码实现的继承",children:"#"}),"6.2 __extends、extendStatics 打包代码实现的继承"]}),"\n",(0,s.jsxs)(n.p,{children:["未打包的源码是使用",(0,s.jsx)(n.code,{children:"ES6 extends"}),"实现的。这是打包后的对",(0,s.jsx)(n.code,{children:"ES6"}),"的",(0,s.jsx)(n.code,{children:"extends"}),"的一种实现。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果对继承还不是很熟悉的读者，可以参考我之前写的文章。",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 继承静态方法和属性\nvar extendStatics = function(d, b) {\n	// 如果支持 Object.setPrototypeOf 这个函数，直接使用\n	// 不支持，则使用原型__proto__ 属性，\n	// 如何还不支持（但有可能__proto__也不支持，毕竟是浏览器特有的方法。）\n	// 则使用for in 遍历原型链上的属性，从而达到继承的目的。\n	extendStatics = Object.setPrototypeOf ||\n		({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n		function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n	return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n	extendStatics(d, b);\n	// 申明构造函数__ 并且把 d 赋值给 constructor\n	function __() { this.constructor = d; }\n	// (__.prototype = b.prototype, new __()) 这种逗号形式的代码，最终返回是后者，也就是 new __()\n	// 比如 (typeof null, 1) 返回的是1\n	// 如果 b === null 用Object.create(b) 创建 ，也就是一个不含原型链等信息的空对象 {}\n	// 否则使用 new __() 返回\n	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不得不说这打包后的代码十分严谨，上面说的我的文章《面试官问：",(0,s.jsx)(n.code,{children:"JS"}),"的继承》中没有提到不支持",(0,s.jsx)(n.code,{children:"__proto__"}),"的情况。看来这文章可以进一步严谨修正了。\n让我想起",(0,s.jsx)(n.code,{children:"Vue"}),"源码中对数组检测代理判断是否支持",(0,s.jsx)(n.code,{children:"__proto__"}),"的判断。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// vuejs 源码：https://github.com/vuejs/vue/blob/dev/dist/vue.js#L526-L527\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["看完打包代码实现的继承，继续看 ",(0,s.jsx)(n.code,{children:"BrowserBackend"})," 构造函数"]}),"\n",(0,s.jsxs)(n.h3,{id:"63-browserbackend--构造函数-浏览器后端",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#63-browserbackend--构造函数-浏览器后端",children:"#"}),"6.3 BrowserBackend  构造函数 （浏览器后端）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var BrowserBackend = /** @class */ (function (_super) {\n    __extends(BrowserBackend, _super);\n	function BrowserBackend() {\n		return _super !== null && _super.apply(this, arguments) || this;\n	}\n	/**\n	 * 设置请求\n	 */\n	BrowserBackend.prototype._setupTransport = function () {\n		if (!this._options.dsn) {\n			// We return the noop transport here in case there is no Dsn.\n			// 没有设置dsn，调用BaseBackend.prototype._setupTransport 返回空函数\n			return _super.prototype._setupTransport.call(this);\n		}\n		var transportOptions = __assign({}, this._options.transportOptions, { dsn: this._options.dsn });\n		if (this._options.transport) {\n			return new this._options.transport(transportOptions);\n		}\n		// 支持Fetch则返回 FetchTransport 实例，否则返回 XHRTransport实例，\n		// 这两个构造函数具体代码在开头已有提到。\n		if (supportsFetch()) {\n			return new FetchTransport(transportOptions);\n		}\n		return new XHRTransport(transportOptions);\n	};\n	// code ...\n	return BrowserBackend;\n}(BaseBackend));\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BrowserBackend"})," 又继承自 ",(0,s.jsx)(n.code,{children:"BaseBackend"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"631-basebackend--构造函数-基础后端",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#631-basebackend--构造函数-基础后端",children:"#"}),"6.3.1 BaseBackend  构造函数 （基础后端）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * This is the base implemention of a Backend.\n * @hidden\n */\nvar BaseBackend = /** @class */ (function () {\n	/** Creates a new backend instance. */\n	function BaseBackend(options) {\n		this._options = options;\n		if (!this._options.dsn) {\n			logger.warn('No DSN provided, backend will not do anything.');\n		}\n		// 调用设置请求函数\n		this._transport = this._setupTransport();\n	}\n	/**\n	 * Sets up the transport so it can be used later to send requests.\n	 * 设置发送请求空函数\n	 */\n	BaseBackend.prototype._setupTransport = function () {\n		return new NoopTransport();\n	};\n	// code ...\n	BaseBackend.prototype.sendEvent = function (event) {\n		this._transport.sendEvent(event).then(null, function (reason) {\n			logger.error(\"Error while sending event: \" + reason);\n		});\n	};\n	BaseBackend.prototype.getTransport = function () {\n		return this._transport;\n	};\n	return BaseBackend;\n}());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过一系列的继承后，回过头来看 ",(0,s.jsx)(n.code,{children:"BaseClient"})," 构造函数。"]}),"\n",(0,s.jsxs)(n.h4,{id:"632-baseclient-构造函数基础客户端",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#632-baseclient-构造函数基础客户端",children:"#"}),"6.3.2 BaseClient 构造函数（基础客户端）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var BaseClient = /** @class */ (function () {\n	/**\n	 * Initializes this client instance.\n	 *\n	 * @param backendClass A constructor function to create the backend.\n	 * @param options Options for the client.\n	 */\n	function BaseClient(backendClass, options) {\n		/** Array of used integrations. */\n		this._integrations = {};\n		/** Is the client still processing a call? */\n		this._processing = false;\n		this._backend = new backendClass(options);\n		this._options = options;\n		if (options.dsn) {\n			this._dsn = new Dsn(options.dsn);\n		}\n		if (this._isEnabled()) {\n			this._integrations = setupIntegrations(this._options);\n		}\n	}\n	// code ...\n	return BaseClient;\n}());\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"64-小结1-new-browerclient-经过一系列的继承和初始化",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#64-小结1-new-browerclient-经过一系列的继承和初始化",children:"#"}),"6.4 小结1. new BrowerClient 经过一系列的继承和初始化"]}),"\n",(0,s.jsxs)(n.p,{children:["可以输出下具体",(0,s.jsx)(n.code,{children:"new clientClass(options)"}),"之后的结果："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function initAndBind(clientClass, options) {\n	if (options.debug === true) {\n		logger.enable();\n	}\n	var client = new clientClass(options);\n	console.log('new clientClass(options)', client);\n	getCurrentHub().bindClient(client);\n	// 原来的代码\n	// getCurrentHub().bindClient(new clientClass(options));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"最终输出得到这样的数据。我画了一张图表示。重点关注的原型链用颜色标注了，其他部分收缩了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"sentry new BrowserClient 实例图 By@若川",src:o})}),"\n",(0,s.jsxs)(n.h2,{id:"7-initandbind-函数之-getcurrenthubbindclient",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-initandbind-函数之-getcurrenthubbindclient",children:"#"}),"7. initAndBind 函数之 getCurrentHub().bindClient()"]}),"\n",(0,s.jsxs)(n.p,{children:["继续看 ",(0,s.jsx)(n.code,{children:"initAndBind"})," 的另一条线。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function initAndBind(clientClass, options) {\n	if (options.debug === true) {\n		logger.enable();\n	}\n	getCurrentHub().bindClient(new clientClass(options));\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["获取当前的控制中心 ",(0,s.jsx)(n.code,{children:"Hub"}),"，再把",(0,s.jsx)(n.code,{children:"new BrowserClient()"})," 的实例对象绑定在",(0,s.jsx)(n.code,{children:"Hub"}),"上。"]}),"\n",(0,s.jsxs)(n.h3,{id:"71-getcurrenthub-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-getcurrenthub-函数",children:"#"}),"7.1 getCurrentHub 函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 获取当前Hub 控制中心\nfunction getCurrentHub() {\n	// Get main carrier (global for every environment)\n	var registry = getMainCarrier();\n	// 如果没有控制中心在载体上，或者它的版本是老版本，就设置新的。\n	// If there's no hub, or its an old API, assign a new one\n	if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n		setHubOnCarrier(registry, new Hub());\n	}\n	// node 才执行\n	// Prefer domains over global if they are there (applicable only to Node environment)\n	if (isNodeEnv()) {\n		return getHubFromActiveDomain(registry);\n	}\n	// 返回当前控制中心来自载体上。\n	// Return hub that lives on a global object\n	return getHubFromCarrier(registry);\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"72-衍生的函数-getmaincarriergethubfromcarrier",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-衍生的函数-getmaincarriergethubfromcarrier",children:"#"}),"7.2 衍生的函数 getMainCarrier、getHubFromCarrier"]}),"\n","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getMainCarrier() {\n	// 载体 这里是window\n	// 通过一系列new BrowerClient() 一系列的初始化\n	// 挂载在  carrier.__SENTRY__ 已经有了三个属性，globalEventProcessors, hub, logger\n	var carrier = getGlobalObject();\n	carrier.__SENTRY__ = carrier.__SENTRY__ || {\n		hub: undefined,\n	};\n	return carrier;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 获取控制中心 hub 从载体上\nfunction getHubFromCarrier(carrier) {\n	// 已经有了则返回，没有则new Hub\n	if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub) {\n		return carrier.__SENTRY__.hub;\n	}\n	carrier.__SENTRY__ = carrier.__SENTRY__ || {};\n	carrier.__SENTRY__.hub = new Hub();\n	return carrier.__SENTRY__.hub;\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"73-bindclient-绑定客户端在当前控制中心上",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#73-bindclient-绑定客户端在当前控制中心上",children:"#"}),"7.3 bindClient 绑定客户端在当前控制中心上"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Hub.prototype.bindClient = function (client) {\n	// 获取最后一个\n	var top = this.getStackTop();\n	// 把 new BrowerClient() 实例 绑定到top上\n	top.client = client;\n};\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Hub.prototype.getStackTop = function () {\n	// 获取最后一个\n	return this._stack[this._stack.length - 1];\n};\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"74-小结2-经过一系列的继承和初始化",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#74-小结2-经过一系列的继承和初始化",children:"#"}),"7.4 小结2. 经过一系列的继承和初始化"]}),"\n",(0,s.jsxs)(n.p,{children:["再回过头来看 ",(0,s.jsx)(n.code,{children:"initAndBind"}),"函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function initAndBind(clientClass, options) {\n	if (options.debug === true) {\n		logger.enable();\n	}\n	var client = new clientClass(options);\n	console.log(client, options, 'client, options');\n	var currentHub = getCurrentHub();\n	currentHub.bindClient(client);\n	console.log('currentHub', currentHub);\n	// 源代码\n	// getCurrentHub().bindClient(new clientClass(options));\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最终会得到这样的",(0,s.jsx)(n.code,{children:"Hub"}),"实例对象。笔者画了一张图表示，便于查看理解。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Hub 实例关系图",src:c})}),"\n",(0,s.jsxs)(n.p,{children:["初始化完成后，再来看具体例子。\n具体 ",(0,s.jsx)(n.code,{children:"captureMessage"})," 函数的实现。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Sentry.captureMessage('Hello, 若川!');\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"8-capturemessage-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-capturemessage-函数",children:"#"}),"8. captureMessage 函数"]}),"\n",(0,s.jsxs)(n.p,{children:["通过之前的阅读代码，知道会最终会调用",(0,s.jsx)(n.code,{children:"Fetch"}),"接口，所以直接断点调试即可，得出如下调用栈。\n接下来描述调用栈的主要流程。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"captureMessage 断点调试图",src:a})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"调用栈主要流程："}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"captureMessage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function captureMessage(message, level) {\n	var syntheticException;\n	try {\n		throw new Error(message);\n	}\n	catch (exception) {\n		syntheticException = exception;\n	}\n	// 调用 callOnHub 方法\n	return callOnHub('captureMessage', message, level, {\n		originalException: message,\n		syntheticException: syntheticException,\n	});\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"=> callOnHub"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'/**\n * This calls a function on the current hub.\n * @param method function to call on hub.\n * @param args to pass to function.\n */\nfunction callOnHub(method) {\n	// 这里method 传进来的是 \'captureMessage\'\n	// 把method除外的其他参数放到args数组中\n	var args = [];\n	for (var _i = 1; _i < arguments.length; _i++) {\n		args[_i - 1] = arguments[_i];\n	}\n	// 获取当前控制中心 hub\n	var hub = getCurrentHub();\n	// 有这个方法 把args 数组展开，传递给 hub[method] 执行\n	if (hub && hub[method]) {\n		// tslint:disable-next-line:no-unsafe-any\n		return hub[method].apply(hub, __spread(args));\n	}\n	throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"=>  Hub.prototype.captureMessage"}),"\n",(0,s.jsxs)(n.p,{children:["接着看",(0,s.jsx)(n.code,{children:"Hub.prototype"})," 上定义的 ",(0,s.jsx)(n.code,{children:"captureMessage"})," 方法"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Hub.prototype.captureMessage = function (message, level, hint) {\n	var eventId = (this._lastEventId = uuid4());\n	var finalHint = hint;\n	// 代码有删减\n	this._invokeClient('captureMessage', message, level, __assign({}, finalHint, { event_id: eventId }));\n	return eventId;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"=> Hub.prototype._invokeClient"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Internal helper function to call a method on the top client if it exists.\n *\n * @param method The method to call on the client.\n * @param args Arguments to pass to the client function.\n */\nHub.prototype._invokeClient = function (method) {\n	// 同样：这里method 传进来的是 'captureMessage'\n	// 把method除外的其他参数放到args数组中\n	var _a;\n	var args = [];\n	for (var _i = 1; _i < arguments.length; _i++) {\n		args[_i - 1] = arguments[_i];\n	}\n	var top = this.getStackTop();\n	// 获取控制中心的 hub，调用客户端也就是new BrowerClient () 实例中继承自 BaseClient 的 captureMessage 方法\n	// 有这个方法 把args 数组展开，传递给 hub[method] 执行\n	if (top && top.client && top.client[method]) {\n		(_a = top.client)[method].apply(_a, __spread(args, [top.scope]));\n	}\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"=> BaseClient.prototype.captureMessage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'BaseClient.prototype.captureMessage = function (message, level, hint, scope) {\n	var _this = this;\n	var eventId = hint && hint.event_id;\n	this._processing = true;\n	var promisedEvent = isPrimitive(message)\n		? this._getBackend().eventFromMessage("" + message, level, hint)\n		: this._getBackend().eventFromException(message, hint);\n		// 代码有删减\n	promisedEvent\n		.then(function (event) { return _this._processEvent(event, hint, scope); })\n	// 代码有删减\n	return eventId;\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["最后会调用 ",(0,s.jsx)(n.code,{children:"_processEvent"})," 也就是"]}),"\n",(0,s.jsx)(n.p,{children:"=> BaseClient.prototype._processEvent"}),"\n",(0,s.jsx)(n.p,{children:"这个函数最终会调用"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_this._getBackend().sendEvent(finalEvent);\n"})}),"\n",(0,s.jsx)(n.p,{children:"也就是"}),"\n",(0,s.jsx)(n.p,{children:"=>  BaseBackend.prototype.sendEvent"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'BaseBackend.prototype.sendEvent = function (event) {\n	this._transport.sendEvent(event).then(null, function (reason) {\n		logger.error("Error while sending event: " + reason);\n	});\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"=> FetchTransport.prototype.sendEvent 最终发送了请求"}),"\n",(0,s.jsxs)(n.h3,{id:"81-fetchtransportprototypesendevent",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#81-fetchtransportprototypesendevent",children:"#"}),"8.1 FetchTransport.prototype.sendEvent"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"FetchTransport.prototype.sendEvent = function (event) {\n	var defaultOptions = {\n		body: JSON.stringify(event),\n		method: 'POST',\n		// Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default\n		// https://caniuse.com/#feat=referrer-policy\n		// It doesn't. And it throw exception instead of ignoring this parameter...\n		// REF: https://github.com/getsentry/raven-js/issues/1233\n		referrerPolicy: (supportsReferrerPolicy() ? 'origin' : ''),\n	};\n	// global$2.fetch(this.url, defaultOptions) 使用fetch发送请求\n	return this._buffer.add(global$2.fetch(this.url, defaultOptions).then(function (response) { return ({\n		status: exports.Status.fromHttpCode(response.status),\n	}); }));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["看完 ",(0,s.jsx)(n.code,{children:"Ajax 上报"})," 主线，再看本文的另外一条主线 ",(0,s.jsx)(n.code,{children:"window.onerror"})," 捕获。"]}),"\n",(0,s.jsxs)(n.h2,{id:"9-windowonerror-和-windowonunhandledrejection-捕获-错误",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-windowonerror-和-windowonunhandledrejection-捕获-错误",children:"#"}),"9. window.onerror 和 window.onunhandledrejection 捕获 错误"]}),"\n",(0,s.jsx)(n.p,{children:"例子：调用一个未申明的变量。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"func();\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Promise"})," 不捕获错误"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"new Promise(() => {\n	fun();\n})\n.then(res => {\n	console.log('then');\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"91-captureevent",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#91-captureevent",children:"#"}),"9.1 captureEvent"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"调用栈主要流程："}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"window.onerror"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"GlobalHandlers.prototype._installGlobalOnErrorHandler = function () {\n	if (this._onErrorHandlerInstalled) {\n		return;\n	}\n	var self = this; // tslint:disable-line:no-this-assignment\n	// 浏览器中这里的 this._global.  就是window\n	this._oldOnErrorHandler = this._global.onerror;\n	this._global.onerror = function (msg, url, line, column, error) {\n		var currentHub = getCurrentHub();\n		// 代码有删减\n		currentHub.captureEvent(event, {\n			originalException: error,\n		});\n		if (self._oldOnErrorHandler) {\n			return self._oldOnErrorHandler.apply(this, arguments);\n		}\n		return false;\n	};\n	this._onErrorHandlerInstalled = true;\n};\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"window.onunhandledrejection"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"GlobalHandlers.prototype._installGlobalOnUnhandledRejectionHandler = function () {\n	if (this._onUnhandledRejectionHandlerInstalled) {\n		return;\n	}\n	var self = this; // tslint:disable-line:no-this-assignment\n	this._oldOnUnhandledRejectionHandler = this._global.onunhandledrejection;\n	this._global.onunhandledrejection = function (e) {\n		// 代码有删减\n		var currentHub = getCurrentHub();\n		currentHub.captureEvent(event, {\n			originalException: error,\n		});\n		if (self._oldOnUnhandledRejectionHandler) {\n			return self._oldOnUnhandledRejectionHandler.apply(this, arguments);\n		}\n		return false;\n	};\n	this._onUnhandledRejectionHandlerInstalled = true;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["共同点：都会调用",(0,s.jsx)(n.code,{children:"currentHub.captureEvent"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"currentHub.captureEvent(event, {\n	originalException: error,\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"=> Hub.prototype.captureEvent"}),"\n",(0,s.jsxs)(n.p,{children:["最终又是调用 ",(0,s.jsx)(n.code,{children:"_invokeClient"})," ，调用流程跟 ",(0,s.jsx)(n.code,{children:"captureMessage"})," 类似，这里就不再赘述。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this._invokeClient('captureEvent')\n"})}),"\n",(0,s.jsx)(n.p,{children:"=> Hub.prototype._invokeClient"}),"\n",(0,s.jsx)(n.p,{children:"=> BaseClient.prototype.captureEvent"}),"\n",(0,s.jsx)(n.p,{children:"=> BaseClient.prototype._processEvent"}),"\n",(0,s.jsx)(n.p,{children:"=>  BaseBackend.prototype.sendEvent"}),"\n",(0,s.jsx)(n.p,{children:"=> FetchTransport.prototype.sendEvent"}),"\n",(0,s.jsx)(n.p,{children:"最终同样是调用了这个函数发送了请求。"}),"\n",(0,s.jsx)(n.p,{children:"可谓是殊途同归，行文至此就基本已经结束，最后总结一下。"}),"\n",(0,s.jsxs)(n.h2,{id:"10-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-总结",children:"#"}),"10. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Sentry-JavaScript"}),"源码高效利用了",(0,s.jsx)(n.code,{children:"JS"}),"的原型链机制。可谓是惊艳，值得学习。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文通过梳理前端错误监控知识、介绍",(0,s.jsx)(n.code,{children:"sentry"}),"错误监控原理、",(0,s.jsx)(n.code,{children:"sentry"}),"初始化、",(0,s.jsx)(n.code,{children:"Ajax"}),"上报、",(0,s.jsx)(n.code,{children:"window.onerror、window.onunhandledrejection"}),"几个方面来学习",(0,s.jsx)(n.code,{children:"sentry"}),"的源码。还有很多细节和构造函数没有分析。"]}),"\n",(0,s.jsxs)(n.p,{children:["总共的构造函数（类）有25个，提到的主要有9个，分别是：",(0,s.jsx)(n.code,{children:"Hub、BaseClient、BaseBackend、BaseTransport、FetchTransport、XHRTransport、BrowserBackend、BrowserClient、GlobalHandlers"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["其他没有提到的分别是 ",(0,s.jsx)(n.code,{children:"SentryError、Logger、Memo、SyncPromise、PromiseBuffer、Span、Scope、Dsn、API、NoopTransport、FunctionToString、InboundFilters、TryCatch、Breadcrumbs、LinkedErrors、UserAgent"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这些构造函数（类）中还有很多值得学习，比如同步的",(0,s.jsx)(n.code,{children:"Promise"}),"（SyncPromise）。\n有兴趣的读者，可以看这一块官方仓库中采用",(0,s.jsx)(n.code,{children:"typescript"}),"写的源码",(0,s.jsx)(n.a,{href:"https://github.com/getsentry/sentry-javascript/blob/master/packages/utils/src/syncpromise.ts",rel:"noopener noreferrer",target:"_blank",children:"SyncPromise"}),"，也可以看打包后出来未压缩的代码。"]}),"\n",(0,s.jsx)(n.p,{children:"读源码比较耗费时间，写文章记录下来更加费时间（比如写这篇文章跨度十几天...），但收获一般都比较大。"}),"\n",(0,s.jsx)(n.p,{children:"如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持。万分感谢。"}),"\n",(0,s.jsxs)(n.h2,{id:"11-推荐阅读",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-推荐阅读",children:"#"}),"11. 推荐阅读"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/51446011",rel:"noopener noreferrer",target:"_blank",children:"知乎滴滴云：超详细！搭建一个前端错误监控系统"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5b7f63c96fb9a019f709b14b",rel:"noopener noreferrer",target:"_blank",children:"掘金BlackHole1：JavaScript集成Sentry"}),"\n丁香园 开源的",(0,s.jsx)(n.code,{children:"Sentry"})," 小程序 ",(0,s.jsx)(n.code,{children:"SDK"}),(0,s.jsx)(n.a,{href:"https://github.com/lizhiyao/sentry-miniapp",rel:"noopener noreferrer",target:"_blank",children:"sentry-miniapp"}),"\n",(0,s.jsxs)(n.a,{href:"https://sentry.io",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"sentry"}),"官网"]}),"\n",(0,s.jsxs)(n.a,{href:"https://github.com/getsentry/sentry-javascript",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"sentry-javascript"}),"仓库"]})]}),"\n",(0,s.jsxs)(n.h2,{id:"笔者往期文章",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔者往期文章",children:"#"}),"笔者往期文章"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5b86732451882542af1c8082",rel:"noopener noreferrer",target:"_blank",children:"前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并"})]}),"\n",(0,s.jsxs)(n.h2,{id:"关于",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，使用",(0,s.jsx)(n.code,{children:"vuepress"}),"重构了，阅读体验可能更好些","\n",(0,s.jsx)(n.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,s.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://www.yuque.com/lxchuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"语雀前端视野专栏"}),"，新增语雀专栏，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,s.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,s.jsxs)(n.h2,{id:"微信公众号--若川视野",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,s.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注（",(0,s.jsx)(n.strong,{children:"回复pdf获取前端优质书籍pdf"}),"）。欢迎加笔者微信",(0,s.jsx)(n.code,{children:"ruochuan12"}),"（注明来源，基本来者不拒），拉您进【前端视野交流群】，长期交流学习~"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"若川视野",src:d})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}let p=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["sentry%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-前端错误监控知识",text:"2. 前端错误监控知识",depth:2},{id:"21-前端错误的分类",text:"2.1 前端错误的分类",depth:3},{id:"22-error事件捕获代码示例",text:"2.2 Error事件捕获代码示例",depth:3},{id:"23-上报错误的基本原理",text:"2.3 上报错误的基本原理",depth:3},{id:"3-sentry-前端异常监控基本原理",text:"3. Sentry 前端异常监控基本原理",depth:2},{id:"4-sentry-源码入口和出口",text:"4. Sentry 源码入口和出口",depth:2},{id:"5-sentryinit-初始化-之-init-函数",text:"5. Sentry.init 初始化 之 init 函数",depth:2},{id:"51-getglobalobjectinnodeenv-函数",text:"5.1 getGlobalObject、inNodeEnv 函数",depth:3},{id:"6-initandbind-函数之-new-browserclientoptions",text:"6. initAndBind 函数之 new BrowserClient(options)",depth:2},{id:"61-browserclient-构造函数",text:"6.1 BrowserClient 构造函数",depth:3},{id:"62-__extendsextendstatics-打包代码实现的继承",text:"6.2 __extends、extendStatics 打包代码实现的继承",depth:3},{id:"63-browserbackend--构造函数-浏览器后端",text:"6.3 BrowserBackend  构造函数 （浏览器后端）",depth:3},{id:"631-basebackend--构造函数-基础后端",text:"6.3.1 BaseBackend  构造函数 （基础后端）",depth:4},{id:"632-baseclient-构造函数基础客户端",text:"6.3.2 BaseClient 构造函数（基础客户端）",depth:4},{id:"64-小结1-new-browerclient-经过一系列的继承和初始化",text:"6.4 小结1. new BrowerClient 经过一系列的继承和初始化",depth:3},{id:"7-initandbind-函数之-getcurrenthubbindclient",text:"7. initAndBind 函数之 getCurrentHub().bindClient()",depth:2},{id:"71-getcurrenthub-函数",text:"7.1 getCurrentHub 函数",depth:3},{id:"72-衍生的函数-getmaincarriergethubfromcarrier",text:"7.2 衍生的函数 getMainCarrier、getHubFromCarrier",depth:3},{id:"73-bindclient-绑定客户端在当前控制中心上",text:"7.3 bindClient 绑定客户端在当前控制中心上",depth:3},{id:"74-小结2-经过一系列的继承和初始化",text:"7.4 小结2. 经过一系列的继承和初始化",depth:3},{id:"8-capturemessage-函数",text:"8. captureMessage 函数",depth:2},{id:"81-fetchtransportprototypesendevent",text:"8.1 FetchTransport.prototype.sendEvent",depth:3},{id:"9-windowonerror-和-windowonunhandledrejection-捕获-错误",text:"9. window.onerror 和 window.onunhandledrejection 捕获 错误",depth:2},{id:"91-captureevent",text:"9.1 captureEvent",depth:3},{id:"10-总结",text:"10. 总结",depth:2},{id:"11-推荐阅读",text:"11. 推荐阅读",depth:2},{id:"笔者往期文章",text:"笔者往期文章",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK",headingTitle:"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK",frontmatter:{}}},20713:function(e,n,r){r.d(n,{Z:()=>a});var s=r(52676),t=r(75271),i=r(92815);r(18544);let o={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function c(e,n,r){let s=Object.keys(o).includes(n)?n:r;return o[s](e)}let a=e=>{let{defaultLocale:n="en-US"}=e,r=(0,i.Vi)().page.readingTimeData,o=(0,i.Jr)(),a=(0,i.e7)(),[d,l]=(0,t.useState)(c(r,o,n));return(0,t.useEffect)(()=>{l(c(r,o,n))},[o,r]),(0,s.jsx)("span",{"data-dark":String(a),className:"rp-reading-time",children:d})}}}]);