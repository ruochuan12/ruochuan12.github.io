"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["3374"],{36418:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(52676),a=r(40453),c=r(20713);let i=r.p+"static/image/vue-next-debugger.a4da66e5.png";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre",h3:"h3",blockquote:"blockquote",img:"img",em:"em"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"初学者也能看懂的-vue3-源码中那些实用的基础工具函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初学者也能看懂的-vue3-源码中那些实用的基础工具函数",children:"#"}),"初学者也能看懂的 Vue3 源码中那些实用的基础工具函数"]}),"\n",(0,s.jsx)(c.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。欢迎关注我的",(0,s.jsx)(n.a,{href:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe57ddc7c9eb3~tplv-t2oaga2asx-image.image",title:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe57ddc7c9eb3~tplv-t2oaga2asx-image.image",rel:"noopener noreferrer",target:"_blank",children:"公众号若川视野"}),"，最近组织了",(0,s.jsxs)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650756550&idx=1&sn=9acc5e30325963e455f53ec2f64c1fdd&chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&token=917686367&lang=zh_CN#rd",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.strong,{children:"源码共读活动"}),"《1个月，200+人，一起读了4周源码》"]}),"，感兴趣的可以加我微信 ",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650756550&idx=1&sn=9acc5e30325963e455f53ec2f64c1fdd&chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&token=917686367&lang=zh_CN#rd",rel:"noopener noreferrer",target:"_blank",children:"ruochuan12"})," 加微信群参与，长期交流学习。"]}),"\n",(0,s.jsxs)(n.p,{children:["之前写的",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"})," 包含",(0,s.jsx)(n.code,{children:"jQuery"}),"、",(0,s.jsx)(n.code,{children:"underscore"}),"、",(0,s.jsx)(n.code,{children:"lodash"}),"、",(0,s.jsx)(n.code,{children:"vuex"}),"、",(0,s.jsx)(n.code,{children:"sentry"}),"、",(0,s.jsx)(n.code,{children:"axios"}),"、",(0,s.jsx)(n.code,{children:"redux"}),"、",(0,s.jsx)(n.code,{children:"koa"}),"、",(0,s.jsx)(n.code,{children:"vue-devtools"}),"、",(0,s.jsx)(n.code,{children:"vuex4"}),"十篇源码文章。"]}),"\n",(0,s.jsx)(n.p,{children:"写相对很难的源码，耗费了自己的时间和精力，也没收获多少阅读点赞，其实是一件挺受打击的事情。从阅读量和读者受益方面来看，不能促进作者持续输出文章。"}),"\n",(0,s.jsxs)(n.p,{children:["所以转变思路，写一些相对通俗易懂的文章。",(0,s.jsx)(n.strong,{children:"其实源码也不是想象的那么难，至少有很多看得懂。比如工具函数"}),"。本文通过学习",(0,s.jsx)(n.code,{children:"Vue3"}),"源码中的工具函数模块的源码，学习源码为自己所用。歌德曾说：读一本好书，就是在和高尚的人谈话。\n同理可得：读源码，也算是和作者的一种学习交流的方式。"]}),"\n",(0,s.jsx)(n.p,{children:"阅读本文，你将学到："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"1. 如何学习 JavaScript 基础知识，会推荐很多学习资料\n2. 如何学习调试 vue 3 源码\n3. 如何学习源码中优秀代码和思想，投入到自己的项目中\n4. Vue 3 源码 shared 模块中的几十个实用工具函数\n5. 我的一些经验分享\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"shared"}),"模块中",(0,s.jsx)(n.code,{children:"57个"}),"工具函数，本次阅读其中的",(0,s.jsx)(n.code,{children:"30余个"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-环境准备",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-环境准备",children:"#"}),"2. 环境准备"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-读开源项目-贡献指南",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-读开源项目-贡献指南",children:"#"}),"2.1 读开源项目 贡献指南"]}),"\n",(0,s.jsxs)(n.p,{children:["打开 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next",rel:"noopener noreferrer",target:"_blank",children:"vue-next"}),"，\n开源项目一般都能在 ",(0,s.jsx)(n.code,{children:"README.md"})," 或者 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next/blob/master/.github/contributing.md",rel:"noopener noreferrer",target:"_blank",children:".github/contributing.md"})," 找到贡献指南。"]}),"\n",(0,s.jsx)(n.p,{children:"而贡献指南写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。"}),"\n",(0,s.jsxs)(n.p,{children:["我们可以在 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next/blob/master/.github/contributing.md#project-structure",rel:"noopener noreferrer",target:"_blank",children:"项目目录结构"})," 描述中，找到",(0,s.jsx)(n.code,{children:"shared"}),"模块。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"shared"}),": Internal utilities shared across multiple packages (especially environment-agnostic utils used by both runtime and compiler packages)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"README.md"})," 和 ",(0,s.jsx)(n.code,{children:"contributing.md"})," 一般都是英文的。可能会难倒一部分人。其实看不懂，完全可以可以借助划词翻译，整页翻译和百度翻译等翻译工具。再把英文加入后续学习计划。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文就是讲",(0,s.jsx)(n.code,{children:"shared"}),"模块，对应的文件路径是：",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-next/packages/shared/src/index.ts"})})]}),"\n",(0,s.jsxs)(n.p,{children:["也可以用",(0,s.jsx)(n.code,{children:"github1s"}),"访问，速度更快。",(0,s.jsx)(n.a,{href:"https://github1s.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts",rel:"noopener noreferrer",target:"_blank",children:"github1s packages/shared/src/index.ts"})]}),"\n",(0,s.jsxs)(n.h3,{id:"22-按照项目指南-打包构建代码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-按照项目指南-打包构建代码",children:"#"}),"2.2 按照项目指南 打包构建代码"]}),"\n",(0,s.jsxs)(n.p,{children:["为了降低文章难度，我按照贡献指南中方法打包把",(0,s.jsx)(n.code,{children:"ts"}),"转成了",(0,s.jsx)(n.code,{children:"js"}),"。如果你需要打包，也可以参考下文打包构建。"]}),"\n",(0,s.jsxs)(n.p,{children:["你需要确保 ",(0,s.jsx)(n.a,{href:"http://nodejs.org/",rel:"noopener noreferrer",target:"_blank",children:"Node.js"})," 版本是 ",(0,s.jsx)(n.code,{children:"10+"}),", 而且 ",(0,s.jsx)(n.code,{children:"yarn"})," 的版本是 ",(0,s.jsx)(n.code,{children:"1.x"})," ",(0,s.jsx)(n.a,{href:"https://yarnpkg.com/en/docs/install",rel:"noopener noreferrer",target:"_blank",children:"Yarn 1.x"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["你安装的 ",(0,s.jsx)(n.code,{children:"Node.js"})," 版本很可能是低于 ",(0,s.jsx)(n.code,{children:"10"}),"。最简单的办法就是去官网重新安装。也可以使用 ",(0,s.jsx)(n.code,{children:"nvm"}),"等管理",(0,s.jsx)(n.code,{children:"Node.js"}),"版本。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node -v\n# v14.16.0\n# 全局安装 yarn\n\n# 推荐克隆我的项目\ngit clone https://github.com/ruochuan12/vue-next-analysis.git\ncd vue-next-analysis/vue-next\n\n# 或者克隆官方项目\ngit clone https://github.com/vuejs/vue-next.git\ncd vue-next\n\nnpm install --global yarn\nyarn # install the dependencies of the project\nyarn build\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以得到 ",(0,s.jsx)(n.code,{children:"vue-next/packages/shared/dist/shared.esm-bundler.js"}),"，文件也就是纯",(0,s.jsx)(n.code,{children:"js"}),"文件。接下来就是解释其中的一些方法。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["当然，前面可能比较啰嗦。我可以直接讲 ",(0,s.jsx)(n.code,{children:"3. 工具函数"}),"。但通过我上文的介绍，即使是初学者，都能看懂一些开源项目源码，也许就会有一定的成就感。\n另外，面试问到被类似的问题或者笔试题时，你说看",(0,s.jsx)(n.code,{children:"Vue3"}),"源码学到的，面试官绝对对你刮目相看。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"23-如何生成-sourcemap-调试-vue-next-源码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-如何生成-sourcemap-调试-vue-next-源码",children:"#"}),"2.3 如何生成 sourcemap 调试 vue-next 源码"]}),"\n",(0,s.jsxs)(n.p,{children:["熟悉我的读者知道，我是经常强调生成",(0,s.jsx)(n.code,{children:"sourcemap"}),"调试看源码，所以顺便提一下如何配置生成",(0,s.jsx)(n.code,{children:"sourcemap"}),"，如何调试。这部分可以简单略过，动手操作时再仔细看。"]}),"\n",(0,s.jsxs)(n.p,{children:["其实",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next/blob/master/.github/contributing.md",rel:"noopener noreferrer",target:"_blank",children:"贡献指南"}),"里描述了。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Build with Source Maps\nUse the ",(0,s.jsx)(n.code,{children:"--sourcemap"})," or ",(0,s.jsx)(n.code,{children:"-s"})," flag to build with source maps. Note this will make the build much slower."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["所以在 ",(0,s.jsx)(n.code,{children:"vue-next/package.json"})," 追加 ",(0,s.jsx)(n.code,{children:'"dev:sourcemap": "node scripts/dev.js --sourcemap"'}),"，",(0,s.jsx)(n.code,{children:"yarn dev:sourcemap"}),"执行，即可生成",(0,s.jsx)(n.code,{children:"sourcemap"}),"，或者直接 ",(0,s.jsx)(n.code,{children:"build"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n    "version": "3.2.1",\n    "scripts": {\n        "dev:sourcemap": "node scripts/dev.js --sourcemap"\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["会在控制台输出类似",(0,s.jsx)(n.code,{children:"vue-next/packages/vue/src/index.ts → packages/vue/dist/vue.global.js"}),"的信息。"]}),"\n",(0,s.jsxs)(n.p,{children:["其中",(0,s.jsx)(n.code,{children:"packages/vue/dist/vue.global.js.map"})," 就是",(0,s.jsx)(n.code,{children:"sourcemap"}),"文件了。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们在 Vue3官网找个例子，在 ",(0,s.jsx)(n.code,{children:"vue-next/examples/index.html"}),"。其内容引入",(0,s.jsx)(n.code,{children:"packages/vue/dist/vue.global.js"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// vue-next/examples/index.html\n<script src=\"../../packages/vue/dist/vue.global.js\"><\/script>\n<script>\n    const Counter = {\n        data() {\n            return {\n                counter: 0\n            }\n        }\n    }\n\n    Vue.createApp(Counter).mount('#counter')\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后我们新建一个终端窗口，",(0,s.jsx)(n.code,{children:"yarn serve"}),"，在浏览器中打开",(0,s.jsx)(n.code,{children:"http://localhost:5000/examples/"}),"，如下图所示，按",(0,s.jsx)(n.code,{children:"F11"}),"等进入函数，就可以愉快的调试源码了。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"vue-next-debugger",src:i})}),"\n",(0,s.jsxs)(n.h2,{id:"3-工具函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-工具函数",children:"#"}),"3. 工具函数"]}),"\n",(0,s.jsxs)(n.p,{children:["本文主要按照源码 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-next/packages/shared/src/index.ts"})})," 的顺序来写。也省去了一些从外部导入的方法。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们也可以通过",(0,s.jsx)(n.code,{children:"ts"}),"文件，查看使用函数的位置。同时在",(0,s.jsx)(n.code,{children:"VSCode"}),"运行调试JS代码，我们比较推荐韩老师写的",(0,s.jsx)(n.code,{children:"code runner"}),"插件。"]}),"\n",(0,s.jsxs)(n.h3,{id:"31-babelparserdefaultplugins--babel-解析默认插件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-babelparserdefaultplugins--babel-解析默认插件",children:"#"}),"3.1 babelParserDefaultPlugins  babel 解析默认插件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * List of @babel/parser plugins that are used for template expression\n * transforms and SFC script transforms. By default we enable proposals slated\n * for ES2020. This will need to be updated as the spec moves forward.\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\n */\nconst babelParserDefaultPlugins = [\n    'bigInt',\n    'optionalChaining',\n    'nullishCoalescingOperator'\n];\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里就是几个默认插件。感兴趣看英文注释查看。"}),"\n",(0,s.jsxs)(n.h3,{id:"32-empty_obj-空对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-empty_obj-空对象",children:"#"}),"3.2 EMPTY_OBJ 空对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\n    ? Object.freeze({})\n    : {};\n\n// 例子：\n// Object.freeze 是 冻结对象\n// 冻结的对象最外层无法修改。\nconst EMPTY_OBJ_1 = Object.freeze({});\nEMPTY_OBJ_1.name = '若川';\nconsole.log(EMPTY_OBJ_1.name); // undefined\n\nconst EMPTY_OBJ_2 = Object.freeze({ props: { mp: '若川视野' } });\nEMPTY_OBJ_2.props.name = '若川';\nEMPTY_OBJ_2.props2 = 'props2';\nconsole.log(EMPTY_OBJ_2.props.name); // '若川'\nconsole.log(EMPTY_OBJ_2.props2); // undefined\nconsole.log(EMPTY_OBJ_2);\n/**\n *\n * {\n *  props: {\n     mp: \"若川视野\",\n     name: \"若川\"\n    }\n * }\n * */\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"process.env.NODE_ENV"})," 是 ",(0,s.jsx)(n.code,{children:"node"})," 项目中的一个环境变量，一般定义为：",(0,s.jsx)(n.code,{children:"development"})," 和",(0,s.jsx)(n.code,{children:"production"}),"。根据环境写代码。比如开发环境，有报错等信息，生产环境则不需要这些报错警告。"]}),"\n",(0,s.jsxs)(n.h3,{id:"33-empty_arr-空数组",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-empty_arr-空数组",children:"#"}),"3.3 EMPTY_ARR 空数组"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\n\n// 例子：\nEMPTY_ARR.push(1) // 报错，也就是为啥生产环境还是用 []\nEMPTY_ARR.length = 3;\nconsole.log(EMPTY_ARR.length); // 0\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"34-noop-空函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-noop-空函数",children:"#"}),"3.4 NOOP 空函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const NOOP = () => { };\n\n// 很多库的源码中都有这样的定义函数，比如 jQuery、underscore、lodash 等\n// 使用场景：1. 方便判断， 2. 方便压缩\n// 1. 比如：\nconst instance = {\n    render: NOOP\n};\n\n// 条件\nconst dev = true;\nif(dev){\n    instance.render = function(){\n        console.log('render');\n    }\n}\n\n// 可以用作判断。\nif(instance.render === NOOP){\n console.log('i');\n}\n// 2. 再比如：\n// 方便压缩代码\n// 如果是 function(){} ，不方便压缩代码\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"35-no-永远返回-false-的函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35-no-永远返回-false-的函数",children:"#"}),"3.5 NO 永远返回 false 的函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Always return false.\n */\nconst NO = () => false;\n\n// 除了压缩代码的好处外。\n// 一直返回 false\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"36-ison-判断字符串是不是-on-开头并且-on-后首字母不是小写字母",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-ison-判断字符串是不是-on-开头并且-on-后首字母不是小写字母",children:"#"}),"3.6 isOn 判断字符串是不是 on 开头，并且 on 后首字母不是小写字母"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\n\n// 例子：\nisOn('onChange'); // true\nisOn('onchange'); // false\nisOn('on3change'); // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"onRE"})," 是正则。",(0,s.jsx)(n.code,{children:"^"}),"符号在开头，则表示是什么开头。而在其他地方是指非。"]}),"\n",(0,s.jsxs)(n.p,{children:["与之相反的是：",(0,s.jsx)(n.code,{children:"$"}),"符合在结尾，则表示是以什么结尾。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"[^a-z]"}),"是指不是",(0,s.jsx)(n.code,{children:"a"}),"到",(0,s.jsx)(n.code,{children:"z"}),"的小写字母。"]}),"\n",(0,s.jsx)(n.p,{children:"同时推荐一个正则在线工具。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://regex101.com",rel:"noopener noreferrer",target:"_blank",children:"regex101"})}),"\n",(0,s.jsx)(n.p,{children:"另外正则看老姚的迷你书就够用了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903501034684430",rel:"noopener noreferrer",target:"_blank",children:"老姚：《JavaScript 正则表达式迷你书》问世了！"})}),"\n",(0,s.jsxs)(n.h3,{id:"37-ismodellistener-监听器",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37-ismodellistener-监听器",children:"#"}),"3.7 isModelListener 监听器"]}),"\n",(0,s.jsxs)(n.p,{children:["判断字符串是不是以",(0,s.jsx)(n.code,{children:"onUpdate:"}),"开头"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isModelListener = (key) => key.startsWith('onUpdate:');\n\n// 例子：\nisModelListener('onUpdate:change'); // true\nisModelListener('1onUpdate:change'); // false\n// startsWith 是 ES6 提供的方法\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://es6.ruanyifeng.com/#docs/string-methods",rel:"noopener noreferrer",target:"_blank",children:"ES6入门教程：字符串的新增方法"})}),"\n",(0,s.jsx)(n.p,{children:"很多方法都在《ES6入门教程》中有讲到，就不赘述了。"}),"\n",(0,s.jsxs)(n.h3,{id:"38-extend-继承-合并",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#38-extend-继承-合并",children:"#"}),"3.8 extend 继承 合并"]}),"\n",(0,s.jsx)(n.p,{children:"说合并可能更准确些。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const extend = Object.assign;\n\n// 例子：\nconst data = { name: \'若川\' };\nconst data2 = extend(data, { mp: \'若川视野\', name: \'是若川啊\' });\nconsole.log(data); // { name: "是若川啊", mp: "若川视野" }\nconsole.log(data2); // { name: "是若川啊", mp: "若川视野" }\nconsole.log(data === data2); // true\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"39-remove-移除数组的一项",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#39-remove-移除数组的一项",children:"#"}),"3.9 remove 移除数组的一项"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\n\n// 例子：\nconst arr = [1, 2, 3];\nremove(arr, 3);\nconsole.log(arr); // [1, 2]\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"splice"})," 其实是一个很耗性能的方法。删除数组中的一项，其他元素都要移动位置。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"引申"}),"：",(0,s.jsxs)(n.a,{href:"https://github.com/axios/axios/blob/master/lib/core/InterceptorManager.js",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"axios InterceptorManager"})," 拦截器源码"]})," 中，拦截器用数组存储的。但实际移除拦截器时，只是把拦截器置为 ",(0,s.jsx)(n.code,{children:"null"})," 。而不是用",(0,s.jsx)(n.code,{children:"splice"}),"移除。最后执行时为 ",(0,s.jsx)(n.code,{children:"null"})," 的不执行，同样效果。",(0,s.jsx)(n.code,{children:"axios"})," 拦截器这个场景下，不得不说为性能做到了很好的考虑。"]}),"\n",(0,s.jsxs)(n.p,{children:["看如下 ",(0,s.jsx)(n.code,{children:"axios"})," 拦截器代码示例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 代码有删减\n// 声明\nthis.handlers = [];\n\n// 移除\nif (this.handlers[id]) {\n    this.handlers[id] = null;\n}\n\n// 执行\nif (h !== null) {\n    fn(h);\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"310-hasown-是不是自己本身所拥有的属性",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#310-hasown-是不是自己本身所拥有的属性",children:"#"}),"3.10 hasOwn 是不是自己本身所拥有的属性"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\n\n// 例子：\n\n// 特别提醒：__proto__ 是浏览器实现的原型写法，后面还会用到\n// 现在已经有提供好几个原型相关的API\n// Object.getPrototypeOf\n// Object.setPrototypeOf\n// Object.isPrototypeOf\n\n// .call 则是函数里 this 显示指定以为第一个参数，并执行函数。\n\nhasOwn({__proto__: { a: 1 }}, 'a') // false\nhasOwn({ a: undefined }, 'a') // true\nhasOwn({}, 'a') // false\nhasOwn({}, 'hasOwnProperty') // false\nhasOwn({}, 'toString') // false\n// 是自己的本身拥有的属性，不是通过原型链向上查找的。\n"})}),"\n",(0,s.jsxs)(n.p,{children:["对象API可以看我之前写的一篇文章",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/Y3nL3GPcxiqb3zK6pEuycg",rel:"noopener noreferrer",target:"_blank",children:"JavaScript 对象所有API解析"}),"，写的还算全面。"]}),"\n",(0,s.jsxs)(n.h3,{id:"311-isarray-判断数组",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#311-isarray-判断数组",children:"#"}),"3.11 isArray 判断数组"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isArray = Array.isArray;\n\nisArray([]); // true\nconst fakeArr = { __proto__: Array.prototype, length: 0 };\nisArray(fakeArr); // false\nfakeArr instanceof Array; // true\n// 所以 instanceof 这种情况 不准确\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"312-ismap-判断是不是-map-对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#312-ismap-判断是不是-map-对象",children:"#"}),"3.12 isMap 判断是不是 Map 对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isMap = (val) => toTypeString(val) === '[object Map]';\n\n// 例子：\nconst map = new Map();\nconst o = { p: 'Hello World' };\n\nmap.set(o, 'content');\nmap.get(o); // 'content'\nisMap(map); // true\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"313-isset-判断是不是-set-对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#313-isset-判断是不是-set-对象",children:"#"}),"3.13 isSet 判断是不是 Set 对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isSet = (val) => toTypeString(val) === '[object Set]';\n\n// 例子：\nconst set = new Set();\nisSet(set); // true\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ES6"})," 提供了新的数据结构 ",(0,s.jsx)(n.code,{children:"Set"}),"。它类似于数组，但是成员的值都是唯一的，没有重复的值。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Set"}),"本身是一个构造函数，用来生成 ",(0,s.jsx)(n.code,{children:"Set"})," 数据结构。"]}),"\n",(0,s.jsxs)(n.h3,{id:"314-isdate-判断是不是-date-对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#314-isdate-判断是不是-date-对象",children:"#"}),"3.14 isDate 判断是不是 Date 对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isDate = (val) => val instanceof Date;\n\n// 例子：\nisDate(new Date()); // true\n\n// `instanceof` 操作符左边是右边的实例。但不是很准，但一般够用了。原理是根据原型链向上查找的。\n\nisDate({__proto__: new Date()}); // true\n// 实际上是应该是 Object 才对。\n// 所以用 instanceof 判断数组也不准确。\n// 再比如\n({__proto__: [] }) instanceof Array; // true\n// 实际上是对象。\n// 所以用 数组本身提供的方法 Array.isArray 是比较准确的。\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"315-isfunction-判断是不是函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#315-isfunction-判断是不是函数",children:"#"}),"3.15 isFunction 判断是不是函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isFunction = (val) => typeof val === 'function';\n// 判断函数有多种方法，但这个是比较常用也相对兼容性好的。\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"316-isstring-判断是不是字符串",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#316-isstring-判断是不是字符串",children:"#"}),"3.16 isString 判断是不是字符串"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isString = (val) => typeof val === 'string';\n\n// 例子：\nisString('') // true\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"317-issymbol-判断是不是-symbol",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#317-issymbol-判断是不是-symbol",children:"#"}),"3.17 isSymbol 判断是不是 Symbol"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isSymbol = (val) => typeof val === 'symbol';\n\n// 例子：\nlet s = Symbol();\n\ntypeof s;\n// \"symbol\"\n// Symbol 是函数，不需要用 new 调用。\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ES6"})," 引入了一种新的原始数据类型",(0,s.jsx)(n.code,{children:"Symbol"}),"，表示独一无二的值。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"318-isobject-判断是不是对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#318-isobject-判断是不是对象",children:"#"}),"3.18 isObject 判断是不是对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isObject = (val) => val !== null && typeof val === 'object';\n\n// 例子：\nisObject(null); // false\nisObject({name: '若川'}); // true\n// 判断不为 null 的原因是 typeof null 其实 是 object\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"319-ispromise-判断是不是-promise",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#319-ispromise-判断是不是-promise",children:"#"}),"3.19 isPromise 判断是不是 Promise"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\n\n// 判断是不是Promise对象\nconst p1 = new Promise(function(resolve, reject){\n  resolve('若川');\n});\nisPromise(p1); // true\n\n// promise 对于初学者来说可能比较难理解。但是重点内容，JS异步编程，要着重掌握。\n// 现在 web 开发 Promise 和 async await 等非常常用。\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以根据文末推荐的书籍看",(0,s.jsx)(n.code,{children:"Promise"}),"相关章节掌握。同时也推荐这本迷你书",(0,s.jsx)(n.a,{href:"http://liubin.org/promises-book/",rel:"noopener noreferrer",target:"_blank",children:"JavaScript Promise迷你书（中文版）"})]}),"\n",(0,s.jsxs)(n.h3,{id:"320-objecttostring-对象转字符串",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#320-objecttostring-对象转字符串",children:"#"}),"3.20 objectToString 对象转字符串"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const objectToString = Object.prototype.toString;\n\n// 对象转字符串\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"321-totypestring--对象转字符串",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#321-totypestring--对象转字符串",children:"#"}),"3.21 toTypeString  对象转字符串"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const toTypeString = (value) => objectToString.call(value);\n\n// call 是一个函数，第一个参数是 执行函数里面 this 指向。\n// 通过这个能获得 类似  "[object String]" 其中 String 是根据类型变化的\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"322-torawtype--对象转字符串-截取后几位",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#322-torawtype--对象转字符串-截取后几位",children:"#"}),"3.22 toRawType  对象转字符串 截取后几位"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\n\n// 截取到\ntoRawType('');  'String'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以 截取到 ",(0,s.jsx)(n.code,{children:"String"})," ",(0,s.jsx)(n.code,{children:"Array"})," 等这些类型"]}),"\n",(0,s.jsxs)(n.p,{children:["是 ",(0,s.jsx)(n.code,{children:"JS"})," 判断数据类型非常重要的知识点。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"JS"})," 判断类型也有  typeof ，但不是很准确，而且能够识别出的不多。"]}),"\n",(0,s.jsx)(n.p,{children:"这些算是基础知识"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof",rel:"noopener noreferrer",target:"_blank",children:"mdn typeof 文档"}),"，文档比较详细，也实现了一个很完善的",(0,s.jsx)(n.code,{children:"type"}),"函数，本文就不赘述了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// typeof 返回值目前有以下8种\n'undefined'\n'object'\n'boolean'\n'number'\n'bigint'\n'string'\n'symobl'\n'function'\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"323-isplainobject-判断是不是纯粹的对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#323-isplainobject-判断是不是纯粹的对象",children:"#"}),"3.23 isPlainObject 判断是不是纯粹的对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\n//\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\n\n// 前文中 有 isObject 判断是不是对象了。\n// isPlainObject 这个函数在很多源码里都有，比如 jQuery 源码和 lodash 源码等，具体实现不一样\n// 上文的 isObject([]) 也是 true ，因为 type [] 为 'object'\n// 而 isPlainObject([]) 则是false\nconst Ctor = function(){\n    this.name = '我是构造函数';\n}\nisPlainObject({}); // true\nisPlainObject(new Ctor()); // true\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"324-isintegerkey-判断是不是数字型的字符串key值",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#324-isintegerkey-判断是不是数字型的字符串key值",children:"#"}),"3.24 isIntegerKey 判断是不是数字型的字符串key值"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\n\n// 例子:\nisIntegerKey('a'); // false\nisIntegerKey('0'); // true\nisIntegerKey('011'); // false\nisIntegerKey('11'); // true\n// 其中 parseInt 第二个参数是进制。\n// 字符串能用数组取值的形式取值。\n//  还有一个 charAt 函数，但不常用\n'abc'.charAt(0) // 'a'\n// charAt 与数组形式不同的是 取不到值会返回空字符串''，数组形式取值取不到则是 undefined\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"325-makemap--isreservedprop",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#325-makemap--isreservedprop",children:"#"}),"3.25 makeMap && isReservedProp"]}),"\n",(0,s.jsxs)(n.p,{children:["传入一个以逗号分隔的字符串，生成一个 ",(0,s.jsx)(n.code,{children:"map"}),"(键值对)，并且返回一个函数检测 ",(0,s.jsx)(n.code,{children:"key"})," 值在不在这个 ",(0,s.jsx)(n.code,{children:"map"})," 中。第二个参数是小写选项。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\n\n// 保留的属性\nisReservedProp('key'); // true\nisReservedProp('ref'); // true\nisReservedProp('onVnodeBeforeMount'); // true\nisReservedProp('onVnodeMounted'); // true\nisReservedProp('onVnodeBeforeUpdate'); // true\nisReservedProp('onVnodeUpdated'); // true\nisReservedProp('onVnodeBeforeUnmount'); // true\nisReservedProp('onVnodeUnmounted'); // true\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"326-cachestringfunction-缓存",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#326-cachestringfunction-缓存",children:"#"}),"3.26 cacheStringFunction 缓存"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个函数也是和上面 MakeMap 函数类似。只不过接收参数的是函数。\n《JavaScript 设计模式与开发实践》书中的第四章 JS单例模式也是类似的实现。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var getSingle = function(fn){ // 获取单例\n    var result;\n    return function(){\n        return result || (result = fn.apply(this, arguments));\n    }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["以下是一些正则，系统学习正则推荐",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903501034684430",rel:"noopener noreferrer",target:"_blank",children:"老姚：《JavaScript 正则表达式迷你书》问世了！"}),"，看过的都说好。所以本文不会过多描述正则相关知识点。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// \\w 是 0-9a-zA-Z_ 数字 大小写字母和下划线组成\n// () 小括号是 分组捕获\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\n// 连字符 - 转驼峰  on-click => onClick\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\n// \\B 是指 非 \\b 单词边界。\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\n\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n\n// 举例：onClick => on-click\nconst hyphenateResult = hyphenate('onClick');\nconsole.log('hyphenateResult', hyphenateResult); // 'on-click'\n\n/**\n * @private\n */\n// 首字母转大写\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\n// click => onClick\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\n\nconst result = toHandlerKey('click');\nconsole.log(result, 'result'); // 'onClick'\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"327-haschanged-判断是不是有变化",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#327-haschanged-判断是不是有变化",children:"#"}),"3.27 hasChanged 判断是不是有变化"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hasChanged"})," 这个方法，值得一提的是：我刚写这篇文章时，还没有用",(0,s.jsx)(n.code,{children:"Object.is"}),"，后来看 ",(0,s.jsx)(n.code,{children:"git"})," 记录发现有人 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-next/pull/3837",rel:"noopener noreferrer",target:"_blank",children:"提PR"})," 修改为",(0,s.jsx)(n.code,{children:"Object.is"}),"了，尤大合并了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const hasChanged = (value, oldValue) => !Object.is(value, oldValue);\n"})}),"\n",(0,s.jsx)(n.p,{children:"以下是原先的源码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n// 例子：\n// 认为 NaN 是不变的\nhasChanged(NaN, NaN); // false\nhasChanged(1, 1); // false\nhasChanged(1, 2); // true\nhasChanged(+0, -0); // false\n// Obect.is 认为 +0 和 -0 不是同一个值\nObject.is(+0, -0); // false\n// Object.is 认为  NaN 和 本身 相比 是同一个值\nObject.is(NaN, NaN); // true\n// 场景\n// watch 监测值是不是变化了\n\n// (value === value || oldValue === oldValue)\n// 为什么会有这句 因为要判断 NaN 。认为 NaN 是不变的。因为 NaN === NaN 为 false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["根据 ",(0,s.jsx)(n.code,{children:"hasChanged"})," 这个我们继续来看看：",(0,s.jsx)(n.code,{children:"Object.is"})," ",(0,s.jsx)(n.code,{children:"API"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Object.is(value1, value2) (ES6)"})}),"\n",(0,s.jsxs)(n.p,{children:["该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。 不同之处只有两个：一是",(0,s.jsx)(n.code,{children:"+0"}),"不等于",(0,s.jsx)(n.code,{children:"-0"}),"，二是 ",(0,s.jsx)(n.code,{children:"NaN"})," 等于自身。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Object.is('若川', '若川'); // true\nObject.is({},{}); // false\nObject.is(+0, -0); // false\n+0 === -0; // true\nObject.is(NaN, NaN); // true\nNaN === NaN; // false\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ES5"}),"可以通过以下代码部署",(0,s.jsx)(n.code,{children:"Object.is"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Object.defineProperty(Object, 'is', {\n    value: function() {x, y} {\n        if (x === y) {\n           // 针对+0不等于-0的情况\n           return x !== 0 || 1 / x === 1 / y;\n        }\n        // 针对 NaN的情况\n        return x !== x && y !== y;\n    },\n    configurable: true,\n    enumerable: false,\n    writable: true\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"根据举例可以说明"}),"\n",(0,s.jsxs)(n.h3,{id:"328-invokearrayfns--执行数组里的函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#328-invokearrayfns--执行数组里的函数",children:"#"}),"3.28 invokeArrayFns  执行数组里的函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\n\n// 例子：\nconst arr = [\n    function(val){\n        console.log(val + '的博客地址是：https://ruochuan12.github.io');\n    },\n    function(val){\n        console.log('百度搜索 若川 可以找到' + val);\n    },\n    function(val){\n        console.log('微信搜索 若川视野 可以找到关注' + val);\n    },\n]\ninvokeArrayFns(arr, '我');\n"})}),"\n",(0,s.jsx)(n.p,{children:"为什么这样写，我们一般都是一个函数执行就行。"}),"\n",(0,s.jsx)(n.p,{children:"数组中存放函数，函数其实也算是数据。这种写法方便统一执行多个函数。"}),"\n",(0,s.jsxs)(n.h3,{id:"329-def-定义对象属性",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#329-def-定义对象属性",children:"#"}),"3.29 def 定义对象属性"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object.defineProperty"})," 算是一个非常重要的",(0,s.jsx)(n.code,{children:"API"}),"。还有一个定义多个属性的",(0,s.jsx)(n.code,{children:"API"}),"：",(0,s.jsx)(n.code,{children:"Object.defineProperties(obj, props) (ES5)"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object.defineProperty"})," 涉及到比较重要的知识点。","\n在",(0,s.jsx)(n.code,{children:"ES3"}),"中，除了一些内置属性（如：",(0,s.jsx)(n.code,{children:"Math.PI"}),"），对象的所有的属性在任何时候都可以被修改、插入、删除。在",(0,s.jsx)(n.code,{children:"ES5"}),"中，我们可以设置属性是否可以被改变或是被删除——在这之前，它是内置属性的特权。",(0,s.jsx)(n.code,{children:"ES5"}),"中引入了",(0,s.jsx)(n.strong,{children:"属性描述符"}),"的概念，我们可以通过它对所定义的属性有更大的控制权。这些",(0,s.jsx)(n.strong,{children:"属性描述符"}),"（特性）包括："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"value"}),"——当试图获取属性时所返回的值。","\n",(0,s.jsx)(n.code,{children:"writable"}),"——该属性是否可写。","\n",(0,s.jsx)(n.code,{children:"enumerable"}),"——该属性在",(0,s.jsx)(n.code,{children:"for in"}),"循环中是否会被枚举。","\n",(0,s.jsx)(n.code,{children:"configurable"}),"——该属性是否可被删除。","\n",(0,s.jsx)(n.code,{children:"set()"}),"——该属性的更新操作所调用的函数。","\n",(0,s.jsx)(n.code,{children:"get()"}),"——获取属性值时所调用的函数。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，",(0,s.jsx)(n.strong,{children:"数据描述符"}),"（其中属性为：",(0,s.jsx)(n.code,{children:"enumerable"}),"，",(0,s.jsx)(n.code,{children:"configurable"}),"，",(0,s.jsx)(n.code,{children:"value"}),"，",(0,s.jsx)(n.code,{children:"writable"}),"）与",(0,s.jsx)(n.strong,{children:"存取描述符"}),"（其中属性为",(0,s.jsx)(n.code,{children:"enumerable"}),"，",(0,s.jsx)(n.code,{children:"configurable"}),"，",(0,s.jsx)(n.code,{children:"set()"}),"，",(0,s.jsx)(n.code,{children:"get()"}),"）之间是有互斥关系的。在定义了",(0,s.jsx)(n.code,{children:"set()"}),"和",(0,s.jsx)(n.code,{children:"get()"}),"之后，描述符会认为存取操作已被 定义了，其中再定义",(0,s.jsx)(n.code,{children:"value"}),"和",(0,s.jsx)(n.code,{children:"writable"}),"会",(0,s.jsx)(n.strong,{children:"引起错误"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["以下是",(0,s.jsx)(n.em,{children:"ES3"}),"风格的属性定义方式："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var person = {};\nperson.legs = 2;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["以下是等价的ES5通过",(0,s.jsx)(n.strong,{children:"数据描述符"}),"定义属性的方式："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var person = {};\nObject.defineProperty(person, 'legs', {\n    value: 2,\n    writable: true,\n    configurable: true,\n    enumerable: true\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中， 除了value的默认值为",(0,s.jsx)(n.code,{children:"undefined"}),"以外，其他的默认值都为",(0,s.jsx)(n.code,{children:"false"}),"。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为",(0,s.jsx)(n.code,{children:"true"}),"。\n或者，我们也可以通过",(0,s.jsx)(n.code,{children:"ES5"}),"的存储描述符来定义："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var person = {};\nObject.defineProperty(person, 'legs', {\n    set:function(v) {\n        return this.value = v;\n    },\n    get: function(v) {\n        return this.value;\n    },\n    configurable: true,\n    enumerable: true\n});\nperson.legs = 2;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容",(0,s.jsx)(n.code,{children:"ES3"}),"方面所做的考虑。例如，跟添加",(0,s.jsx)(n.code,{children:"Array.prototype"}),"属性不一样，我们不能再旧版的浏览器中使用",(0,s.jsx)(n.code,{children:"shim"}),"这一特性。\n另外，我们还可以（通过定义",(0,s.jsx)(n.code,{children:"nonmalleable"}),"属性），在具体行为中运用这些描述符："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var person = {};\nObject.defineProperty(person, 'heads', {value: 1});\nperson.heads = 0; // 0\nperson.heads; // 1  (改不了)\ndelete person.heads; // false\nperson.heads // 1 (删不掉)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其他本文就不过多赘述了。更多对象 ",(0,s.jsx)(n.code,{children:"API"})," 可以查看这篇文章",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/Y3nL3GPcxiqb3zK6pEuycg",rel:"noopener noreferrer",target:"_blank",children:"JavaScript 对象所有API解析"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"330-tonumber-转数字",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#330-tonumber-转数字",children:"#"}),"3.30 toNumber 转数字"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const toNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n\ntoNumber('111'); // 111\ntoNumber('a111'); // 'a111'\nparseFloat('a111'); // NaN\nisNaN(NaN); // true\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["其实 ",(0,s.jsx)(n.code,{children:"isNaN"})," 本意是判断是不是 ",(0,s.jsx)(n.code,{children:"NaN"})," 值，但是不准确的。\n比如：",(0,s.jsx)(n.code,{children:"isNaN('a')"})," 为 ",(0,s.jsx)(n.code,{children:"true"}),"。\n所以 ",(0,s.jsx)(n.code,{children:"ES6"})," 有了 ",(0,s.jsx)(n.code,{children:"Number.isNaN"})," 这个判断方法，为了弥补这一个",(0,s.jsx)(n.code,{children:"API"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Number.isNaN('a')  // false\nNumber.isNaN(NaN); // true\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"331-getglobalthis-全局对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#331-getglobalthis-全局对象",children:"#"}),"3.31 getGlobalThis 全局对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof global !== 'undefined'\n                            ? global\n                            : {}));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["获取全局 ",(0,s.jsx)(n.code,{children:"this"})," 指向。"]}),"\n",(0,s.jsxs)(n.p,{children:["初次执行肯定是 ",(0,s.jsx)(n.code,{children:"_globalThis"})," 是 ",(0,s.jsx)(n.code,{children:"undefined"}),"。所以会执行后面的赋值语句。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果存在 ",(0,s.jsx)(n.code,{children:"globalThis"})," 就用 ",(0,s.jsx)(n.code,{children:"globalThis"}),"。",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis",rel:"noopener noreferrer",target:"_blank",children:"MDN globalThis"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果存在",(0,s.jsx)(n.code,{children:"self"}),"，就用",(0,s.jsx)(n.code,{children:"self"}),"。在 ",(0,s.jsx)(n.code,{children:"Web Worker"})," 中不能访问到 ",(0,s.jsx)(n.code,{children:"window"})," 对象，但是我们却能通过 ",(0,s.jsx)(n.code,{children:"self"})," 访问到 ",(0,s.jsx)(n.code,{children:"Worker"})," 环境中的全局对象。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果存在",(0,s.jsx)(n.code,{children:"window"}),"，就用",(0,s.jsx)(n.code,{children:"window"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果存在",(0,s.jsx)(n.code,{children:"global"}),"，就用",(0,s.jsx)(n.code,{children:"global"}),"。",(0,s.jsx)(n.code,{children:"Node"}),"环境下，使用",(0,s.jsx)(n.code,{children:"global"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"如果都不存在，使用空对象。可能是微信小程序环境下。"}),"\n",(0,s.jsxs)(n.p,{children:["下次执行就直接返回 ",(0,s.jsx)(n.code,{children:"_globalThis"}),"，不需要第二次继续判断了。这种写法值得我们学习。"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-最后推荐一些文章和书籍",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-最后推荐一些文章和书籍",children:"#"}),"4. 最后推荐一些文章和书籍"]}),"\n",(0,s.jsxs)(n.p,{children:["先推荐我认为不错的",(0,s.jsx)(n.code,{children:"JavaScript API"}),"的几篇文章和几本值得读的书。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903476720320525",rel:"noopener noreferrer",target:"_blank",children:"JavaScript字符串所有API全解密"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903476216987655",rel:"noopener noreferrer",target:"_blank",children:"【深度长文】JavaScript数组所有API全解密"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903469824868365",rel:"noopener noreferrer",target:"_blank",children:"正则表达式前端使用手册"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903501034684430",rel:"noopener noreferrer",target:"_blank",children:"老姚：《JavaScript 正则表达式迷你书》问世了！"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650754216&idx=1&sn=9163fb9d843bb2e0b07a5dec862ea9cc&chksm=88664f24bf11c632df132a8c34443a5dd9ef34437f811b3c05a4d409e2e27794bb9d005712b6&token=917686367&lang=zh_CN#rd",rel:"noopener noreferrer",target:"_blank",children:"老姚浅谈：怎么学JavaScript？"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/Y3nL3GPcxiqb3zK6pEuycg",rel:"noopener noreferrer",target:"_blank",children:"JavaScript 对象所有API解析"})," ",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/js-object-api/",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/js-object-api/"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript",rel:"noopener noreferrer",target:"_blank",children:"MDN JavaScript"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/35175321/",rel:"noopener noreferrer",target:"_blank",children:"《JavaScript高级程序设计》第4版"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/35396470/",rel:"noopener noreferrer",target:"_blank",children:"《JavaScript 权威指南》第7版"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/26302623/",rel:"noopener noreferrer",target:"_blank",children:"《JavaScript面向对象编程2》"})," 面向对象讲的很详细。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://es6.ruanyifeng.com/",rel:"noopener noreferrer",target:"_blank",children:"阮一峰老师：《ES6 入门教程》"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://zh.javascript.info/",rel:"noopener noreferrer",target:"_blank",children:"《现代 JavaScript 教程》"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/26351021/",rel:"noopener noreferrer",target:"_blank",children:"《你不知道的JavaScript》上中卷"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/26382780/",rel:"noopener noreferrer",target:"_blank",children:"《JavaScript 设计模式与开发实践》"})}),"\n",(0,s.jsx)(n.p,{children:"我也是从小白看不懂书经历过来的。到现在写文章分享。"}),"\n",(0,s.jsx)(n.p,{children:"我看书的方法：多本书同时看，看相同类似的章节，比如函数。看完这本可能没懂，看下一本，几本书看下来基本就懂了，一遍没看懂，再看几遍，可以避免遗忘，巩固相关章节。当然，刚开始看书很难受，看不进。这些书大部分在微信读书都有，如果习惯看纸质书，那可以买来看。"}),"\n",(0,s.jsx)(n.p,{children:"这时可以看些视频和动手练习一些简单的项目。"}),"\n",(0,s.jsxs)(n.p,{children:["比如：可以自己注册一个",(0,s.jsx)(n.code,{children:"github"}),"账号，分章节小节，抄写书中的代码，提交到",(0,s.jsx)(n.code,{children:"github"}),"，练习了才会更有感觉。"]}),"\n",(0,s.jsxs)(n.p,{children:["再比如 ",(0,s.jsx)(n.a,{href:"https://www.freecodecamp.org/chinese/",rel:"noopener noreferrer",target:"_blank",children:"freeCodeCamp 中文在线学习网站"})," 网站。看书是系统学习非常好的方法。后来我就是看源码较多，写文章分享出来给大家。"]}),"\n",(0,s.jsxs)(n.h2,{id:"5-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-总结",children:"#"}),"5. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["文中主要通过学习 ",(0,s.jsx)(n.code,{children:"shared"})," 模块下的几十个工具函数，比如有：",(0,s.jsx)(n.code,{children:"isPromise"}),"、",(0,s.jsx)(n.code,{children:"makeMap"}),"、",(0,s.jsx)(n.code,{children:"cacheStringFunction"}),"、",(0,s.jsx)(n.code,{children:"invokeArrayFns"}),"、",(0,s.jsx)(n.code,{children:"def"}),"、",(0,s.jsx)(n.code,{children:"getGlobalThis"}),"等等。"]}),"\n",(0,s.jsxs)(n.p,{children:["同时还分享了",(0,s.jsx)(n.code,{children:"vue"}),"源码的调试技巧，推荐了一些书籍和看书籍的方法。"]}),"\n",(0,s.jsx)(n.p,{children:"源码也不是那么可怕。平常我们工作中也是经常能使用到这些工具函数。通过学习一些简单源码，拓展视野的同时，还能落实到自己工作开发中，收益相对比较高。"}),"\n",(0,s.jsxs)(n.p,{children:["最后欢迎加我微信 ",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650756550&idx=1&sn=9acc5e30325963e455f53ec2f64c1fdd&chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&token=917686367&lang=zh_CN#rd",rel:"noopener noreferrer",target:"_blank",children:"ruochuan12"})," 交流，参与 ",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650756550&idx=1&sn=9acc5e30325963e455f53ec2f64c1fdd&chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&token=917686367&lang=zh_CN#rd",rel:"noopener noreferrer",target:"_blank",children:"源码共读"})," 活动，大家一起学习源码，共同进步。"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(d,e)})):d(e)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["vue-next-utils%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-环境准备",text:"2. 环境准备",depth:2},{id:"21-读开源项目-贡献指南",text:"2.1 读开源项目 贡献指南",depth:3},{id:"22-按照项目指南-打包构建代码",text:"2.2 按照项目指南 打包构建代码",depth:3},{id:"23-如何生成-sourcemap-调试-vue-next-源码",text:"2.3 如何生成 sourcemap 调试 vue-next 源码",depth:3},{id:"3-工具函数",text:"3. 工具函数",depth:2},{id:"31-babelparserdefaultplugins--babel-解析默认插件",text:"3.1 babelParserDefaultPlugins  babel 解析默认插件",depth:3},{id:"32-empty_obj-空对象",text:"3.2 EMPTY_OBJ 空对象",depth:3},{id:"33-empty_arr-空数组",text:"3.3 EMPTY_ARR 空数组",depth:3},{id:"34-noop-空函数",text:"3.4 NOOP 空函数",depth:3},{id:"35-no-永远返回-false-的函数",text:"3.5 NO 永远返回 false 的函数",depth:3},{id:"36-ison-判断字符串是不是-on-开头并且-on-后首字母不是小写字母",text:"3.6 isOn 判断字符串是不是 on 开头，并且 on 后首字母不是小写字母",depth:3},{id:"37-ismodellistener-监听器",text:"3.7 isModelListener 监听器",depth:3},{id:"38-extend-继承-合并",text:"3.8 extend 继承 合并",depth:3},{id:"39-remove-移除数组的一项",text:"3.9 remove 移除数组的一项",depth:3},{id:"310-hasown-是不是自己本身所拥有的属性",text:"3.10 hasOwn 是不是自己本身所拥有的属性",depth:3},{id:"311-isarray-判断数组",text:"3.11 isArray 判断数组",depth:3},{id:"312-ismap-判断是不是-map-对象",text:"3.12 isMap 判断是不是 Map 对象",depth:3},{id:"313-isset-判断是不是-set-对象",text:"3.13 isSet 判断是不是 Set 对象",depth:3},{id:"314-isdate-判断是不是-date-对象",text:"3.14 isDate 判断是不是 Date 对象",depth:3},{id:"315-isfunction-判断是不是函数",text:"3.15 isFunction 判断是不是函数",depth:3},{id:"316-isstring-判断是不是字符串",text:"3.16 isString 判断是不是字符串",depth:3},{id:"317-issymbol-判断是不是-symbol",text:"3.17 isSymbol 判断是不是 Symbol",depth:3},{id:"318-isobject-判断是不是对象",text:"3.18 isObject 判断是不是对象",depth:3},{id:"319-ispromise-判断是不是-promise",text:"3.19 isPromise 判断是不是 Promise",depth:3},{id:"320-objecttostring-对象转字符串",text:"3.20 objectToString 对象转字符串",depth:3},{id:"321-totypestring--对象转字符串",text:"3.21 toTypeString  对象转字符串",depth:3},{id:"322-torawtype--对象转字符串-截取后几位",text:"3.22 toRawType  对象转字符串 截取后几位",depth:3},{id:"323-isplainobject-判断是不是纯粹的对象",text:"3.23 isPlainObject 判断是不是纯粹的对象",depth:3},{id:"324-isintegerkey-判断是不是数字型的字符串key值",text:"3.24 isIntegerKey 判断是不是数字型的字符串key值",depth:3},{id:"325-makemap--isreservedprop",text:"3.25 makeMap && isReservedProp",depth:3},{id:"326-cachestringfunction-缓存",text:"3.26 cacheStringFunction 缓存",depth:3},{id:"327-haschanged-判断是不是有变化",text:"3.27 hasChanged 判断是不是有变化",depth:3},{id:"328-invokearrayfns--执行数组里的函数",text:"3.28 invokeArrayFns  执行数组里的函数",depth:3},{id:"329-def-定义对象属性",text:"3.29 def 定义对象属性",depth:3},{id:"330-tonumber-转数字",text:"3.30 toNumber 转数字",depth:3},{id:"331-getglobalthis-全局对象",text:"3.31 getGlobalThis 全局对象",depth:3},{id:"4-最后推荐一些文章和书籍",text:"4. 最后推荐一些文章和书籍",depth:2},{id:"5-总结",text:"5. 总结",depth:2}],title:"初学者也能看懂的 Vue3 源码中那些实用的基础工具函数",headingTitle:"初学者也能看懂的 Vue3 源码中那些实用的基础工具函数",frontmatter:{theme:"smartblue",highlight:"dracula"}}},20713:function(e,n,r){r.d(n,{Z:()=>t});var s=r(52676),a=r(75271),c=r(92815);r(18544);let i={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function d(e,n,r){let s=Object.keys(i).includes(n)?n:r;return i[s](e)}let t=e=>{let{defaultLocale:n="en-US"}=e,r=(0,c.Vi)().page.readingTimeData,i=(0,c.Jr)(),t=(0,c.e7)(),[l,o]=(0,a.useState)(d(r,i,n));return(0,a.useEffect)(()=>{o(d(r,i,n))},[i,r]),(0,s.jsx)("span",{"data-dark":String(t),className:"rp-reading-time",children:l})}}}]);