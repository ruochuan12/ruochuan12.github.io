"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["4641"],{60332:function(e,n,r){e.exports=r.p+"static/image/wechat-official-accounts-mini.44481959.png"},97528:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var s=r(52676),c=r(40453),o=r(20713);let i=r.p+"static/image/ctor-prototype-instance@lxchuan12.a0efaf2f.png",t=r.p+"static/image/underscore.js-chain.2bfd6ecb.png",d=r.p+"static/image/underscore.js-prototype.39dae0ff.png";var a=r(60332);function h(e){let n=Object.assign({h1:"h1",a:"a",code:"code",blockquote:"blockquote",p:"p",h2:"h2",strong:"strong",pre:"pre",img:"img",h3:"h3"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"学习underscore源码整体架构打造属于自己的函数式编程类库",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#学习underscore源码整体架构打造属于自己的函数式编程类库",children:"#"}),"学习",(0,s.jsx)(n.code,{children:"underscore"}),"源码整体架构，打造属于自己的函数式编程类库"]}),"\n",(0,s.jsx)(o.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"写于2019年8月8日"})}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这是",(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"第二篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章学习的是打包整合后的代码，不是实际仓库中的拆分的代码。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/underscore-analysis.git",rel:"noopener noreferrer",target:"_blank",children:"本文仓库地址"}),"：",(0,s.jsx)(n.code,{children:"git clone https://github.com/ruochuan12/underscore-analysis.git"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"文章如下："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d39d2cbf265da1bc23fbd42",rel:"noopener noreferrer",target:"_blank",children:"学习 jQuery 源码整体架构，打造属于自己的 js 类库"}),"\n2.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d4bf94de51d453bb13b65dc",rel:"noopener noreferrer",target:"_blank",children:"学习 underscore 源码整体架构，打造属于自己的函数式编程类库"}),"\n3.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d767e1d6fb9a06b032025ea",rel:"noopener noreferrer",target:"_blank",children:"学习 lodash 源码整体架构，打造属于自己的函数式编程类库"}),"\n4.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dba5a39e51d452a2378348a",rel:"noopener noreferrer",target:"_blank",children:"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK"}),"\n5.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dd4e61a6fb9a05a5c010af0",rel:"noopener noreferrer",target:"_blank",children:"学习 vuex 源码整体架构，打造属于自己的状态管理库"}),"\n6.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5df349b5518825123751ba66",rel:"noopener noreferrer",target:"_blank",children:"学习 axios 源码整体架构，打造属于自己的请求库"}),"\n7.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5e69925cf265da571e262fe6",rel:"noopener noreferrer",target:"_blank",children:"学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理"}),"\n8.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5ee63b7d51882542fc6265ad",rel:"noopener noreferrer",target:"_blank",children:"学习 redux 源码整体架构，深入理解 redux 及其中间件原理"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["感兴趣的读者可以点击阅读。","\n其他源码计划中的有：",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/express-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"express"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vue-router-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-rotuer"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/react-redux-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"react-redux"})})," 等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。"]}),"\n",(0,s.jsxs)(n.p,{children:["源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。","\n所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。"]}),"\n",(0,s.jsxs)(n.p,{children:["虽然看过挺多",(0,s.jsx)(n.code,{children:"underscore.js"}),"分析类的文章，但总感觉少点什么。这也许就是",(0,s.jsx)(n.strong,{children:"纸上得来终觉浅，绝知此事要躬行"}),"吧。于是决定自己写一篇学习",(0,s.jsx)(n.code,{children:"underscore.js"}),"整体架构的文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文章学习的版本是",(0,s.jsx)(n.code,{children:"v1.9.1"}),"。\n",(0,s.jsxs)(n.a,{href:"https://unpkg.com/underscore@1.9.1/underscore.js",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"unpkg.com"})," underscore 源码地址"]})]}),"\n",(0,s.jsxs)(n.p,{children:["虽然很多人都没用过",(0,s.jsx)(n.code,{children:"underscore.js"}),"，但看下官方文档都应该知道如何使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["从一个官方文档",(0,s.jsx)(n.code,{children:"_.chain"}),"简单例子看起："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.chain([1, 2, 3]).reverse().value();\n// => [3, 2, 1]\n"})}),"\n",(0,s.jsx)(n.p,{children:"看例子中可以看出，这是支持链式调用。"}),"\n",(0,s.jsx)(n.p,{children:"读者也可以顺着文章思路，自行打开下载源码进行调试，这样印象更加深刻。"}),"\n",(0,s.jsxs)(n.h2,{id:"2-链式调用",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-链式调用",children:"#"}),"2. 链式调用"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_.chain"})," 函数源码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.chain = function(obj) {\n	var instance = _(obj);\n	instance._chain = true;\n	return instance;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个函数比较简单，就是传递",(0,s.jsx)(n.code,{children:"obj"}),"调用",(0,s.jsx)(n.code,{children:"_()"}),"。但返回值变量竟然是",(0,s.jsx)(n.code,{children:"instance"}),"实例对象。添加属性",(0,s.jsx)(n.code,{children:"_chain"}),"赋值为",(0,s.jsx)(n.code,{children:"true"}),"，并返回",(0,s.jsx)(n.code,{children:"intance"}),"对象。但再看例子，实例对象竟然可以调用",(0,s.jsx)(n.code,{children:"reverse"}),"方法，再调用",(0,s.jsx)(n.code,{children:"value"}),"方法。猜测支持",(0,s.jsx)(n.code,{children:"OOP"}),"（面向对象）调用。"]}),"\n",(0,s.jsxs)(n.p,{children:["带着问题，笔者看了下定义 ",(0,s.jsx)(n.code,{children:"_"})," 函数对象的代码。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3_-函数对象-支持oop",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3_-函数对象-支持oop",children:"#"}),"3.",(0,s.jsx)(n.code,{children:"_"})," 函数对象 支持",(0,s.jsx)(n.code,{children:"OOP"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var _ = function(obj) {\n	if (obj instanceof _) return obj;\n	if (!(this instanceof _)) return new _(obj);\n	this._wrapped = obj;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果参数",(0,s.jsx)(n.code,{children:"obj"}),"已经是",(0,s.jsx)(n.code,{children:"_"}),"的实例了，则返回",(0,s.jsx)(n.code,{children:"obj"}),"。\n如果",(0,s.jsx)(n.code,{children:"this"}),"不是",(0,s.jsx)(n.code,{children:"_"}),"的实例，则手动 ",(0,s.jsx)(n.code,{children:"new _(obj)"}),";\n再次",(0,s.jsx)(n.code,{children:"new"}),"调用时，把",(0,s.jsx)(n.code,{children:"obj"}),"对象赋值给",(0,s.jsx)(n.code,{children:"_wrapped"}),"这个属性。\n也就是说最后得到的实例对象是这样的结构\n",(0,s.jsx)(n.code,{children:"{ 	_wrapped: '参数obj', }"}),"\n它的原型",(0,s.jsx)(n.code,{children:"_(obj).__proto__"})," 是 ",(0,s.jsx)(n.code,{children:"_.prototype"}),";"]}),"\n",(0,s.jsxs)(n.p,{children:["如果对这块不熟悉的读者，可以看下以下这张图(之前写",(0,s.jsxs)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:["面试官问：",(0,s.jsx)(n.code,{children:"JS的继承"})]}),"画的图)。\n",(0,s.jsx)(n.img,{alt:"构造函数、原型对象和实例关系图",src:i})]}),"\n",(0,s.jsxs)(n.p,{children:["继续分析官方的",(0,s.jsx)(n.code,{children:"_.chain"}),"例子。这个例子拆开，写成三步。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var part1 = _.chain([1, 2, 3]);\nvar part2 = part1.reverse();\nvar part3 = part2.value();\n\n// 没有后续part1.reverse()操作的情况下\nconsole.log(part1); // {__wrapped: [1, 2, 3], _chain: true}\n\nconsole.log(part2); // {__wrapped: [3, 2, 1], _chain: true}\n\nconsole.log(part3); // [3, 2, 1]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["思考问题：",(0,s.jsx)(n.code,{children:"reverse"}),"本是",(0,s.jsx)(n.code,{children:"Array.prototype"}),"上的方法呀。为啥支持链式调用呢。\n搜索",(0,s.jsx)(n.code,{children:"reverse"}),"，可以看到如下这段代码："]}),"\n",(0,s.jsx)(n.p,{children:"并将例子代入这段代码可得（怎么有种高中做数学题的既视感^_^）："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.chain([1,2,3]).reverse().value()\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var ArrayProto = Array.prototype;\n// 遍历 数组 Array.prototype 的这些方法，赋值到 _.prototype 上\n_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n	// 这里的`method`是 reverse 函数\n	var method = ArrayProto[name];\n	_.prototype[name] = function() {\n	// 这里的obj 就是数组 [1, 2, 3]\n	var obj = this._wrapped;\n	// arguments  是参数集合，指定reverse 的this指向为obj，参数为arguments， 并执行这个函数函数。执行后 obj 则是 [3, 2, 1]\n	method.apply(obj, arguments);\n	if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n	// 重点在于这里 chainResult 函数。\n	return chainResult(this, obj);\n	};\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Helper function to continue chaining intermediate results.\nvar chainResult = function(instance, obj) {\n	// 如果实例中有_chain 为 true 这个属性，则返回实例 支持链式调用的实例对象  { _chain: true, this._wrapped: [3, 2, 1] }，否则直接返回这个对象[3, 2, 1]。\n	return instance._chain ? _(obj).chain() : obj;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];"}),"\n提一下上面源码中的这一句，看到这句是百思不得其解。于是赶紧在",(0,s.jsx)(n.code,{children:"github"}),"中搜索这句加上",(0,s.jsx)(n.code,{children:'""'}),"双引号。表示全部搜索。"]}),"\n",(0,s.jsxs)(n.p,{children:["搜索到两个在官方库中的",(0,s.jsx)(n.code,{children:"ISSUE"}),"，大概意思就是兼容IE低版本的写法。有兴趣的可以点击去看看。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/jashkenas/underscore/issues/2016",rel:"noopener noreferrer",target:"_blank",children:"I don't understand the meaning of this sentence."})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/jashkenas/underscore/issues/2773",rel:"noopener noreferrer",target:"_blank",children:"why delete obj[0]"})}),"\n",(0,s.jsxs)(n.h2,{id:"4-基于流的编程",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-基于流的编程",children:"#"}),"4. 基于流的编程"]}),"\n",(0,s.jsxs)(n.p,{children:["至此就算是分析完了链式调用",(0,s.jsx)(n.code,{children:"_.chain()"}),"和",(0,s.jsx)(n.code,{children:"_"})," 函数对象。这种把数据存储在实例对象",(0,s.jsx)(n.code,{children:"{_wrapped: '', _chain: true}"})," 中，",(0,s.jsx)(n.code,{children:"_chain"}),"判断是否支持链式调用，来传递给下一个函数处理。这种做法叫做 ",(0,s.jsx)(n.strong,{children:"基于流的编程"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后数据处理完，要返回这个数据怎么办呢。",(0,s.jsx)(n.code,{children:"underscore"}),"提供了一个",(0,s.jsx)(n.code,{children:"value"}),"的方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.prototype.value = function(){\n	return this._wrapped;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["顺便提供了几个别名。",(0,s.jsx)(n.code,{children:"toJSON"}),"、",(0,s.jsx)(n.code,{children:"valueOf"}),"。\n_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;"]}),"\n",(0,s.jsxs)(n.p,{children:["还提供了 ",(0,s.jsx)(n.code,{children:"toString"}),"的方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.prototype.toString = function() {\n	return String(this._wrapped);\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里的",(0,s.jsx)(n.code,{children:"String()"})," 和",(0,s.jsx)(n.code,{children:"new String()"})," 效果是一样的。\n可以猜测内部实现和 ",(0,s.jsx)(n.code,{children:"_"}),"函数对象类似。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var String = function(){\n	if(!(this instanceOf String)) return new String(obj);\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js{2}",children:"var chainResult = function(instance, obj) {\n	return instance._chain ? _(obj).chain() : obj;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["细心的读者会发现",(0,s.jsx)(n.code,{children:"chainResult"}),"函数中的",(0,s.jsx)(n.code,{children:"_(obj).chain()"}),"，是怎么实现实现链式调用的呢。"]}),"\n",(0,s.jsxs)(n.p,{children:["而",(0,s.jsx)(n.code,{children:"_(obj) "}),"是返回的实例对象",(0,s.jsx)(n.code,{children:"{_wrapped: obj}"}),"呀。怎么会有",(0,s.jsx)(n.code,{children:"chain()"}),"方法，肯定有地方挂载了这个方法到",(0,s.jsx)(n.code,{children:"_.prototype"}),"上或者其他操作，这就是",(0,s.jsx)(n.code,{children:"_.mixin()"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"5_mixin-挂载所有的静态方法到_prototype-也可以挂载自定义的方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5_mixin-挂载所有的静态方法到_prototype-也可以挂载自定义的方法",children:"#"}),"5.",(0,s.jsx)(n.code,{children:"_.mixin"})," 挂载所有的静态方法到",(0,s.jsx)(n.code,{children:"_.prototype"}),"， 也可以挂载自定义的方法"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_.mixin"})," 混入。但侵入性太强，经常容易出现覆盖之类的问题。记得之前",(0,s.jsx)(n.code,{children:"React"}),"有",(0,s.jsx)(n.code,{children:"mixin"}),"功能，",(0,s.jsx)(n.code,{children:"Vue"}),"也有",(0,s.jsx)(n.code,{children:"mixin"}),"功能。但版本迭代更新后基本都是慢慢的都不推荐或者不支持",(0,s.jsx)(n.code,{children:"mixin"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.mixin = function(obj) {\n	// 遍历对象上的所有方法\n	_.each(_.functions(obj), function(name) {\n		// 比如 chain, obj['chain'] 函数，自定义的，则赋值到_[name] 上，func 就是该函数。也就是说自定义的方法，不仅_函数对象上有，而且`_.prototype`上也有\n	var func = _[name] = obj[name];\n	_.prototype[name] = function() {\n		// 处理的数据对象\n		var args = [this._wrapped];\n		// 处理的数据对象 和 arguments 结合\n		push.apply(args, arguments);\n		// 链式调用  chain.apply(_, args) 参数又被加上了 _chain属性，支持链式调用。\n		// _.chain = function(obj) {\n		//	var instance = _(obj);\n		//	instance._chain = true;\n		//	return instance;\n		// };\n		return chainResult(this, func.apply(_, args));\n	};\n	});\n	// 最终返回 _ 函数对象。\n	return _;\n};\n\n_.mixin(_);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_mixin(_)"})," 把静态方法挂载到了",(0,s.jsx)(n.code,{children:"_.prototype"}),"上，也就是",(0,s.jsx)(n.code,{children:"_.prototype.chain"}),"方法 也就是 ",(0,s.jsx)(n.code,{children:"_.chain"}),"方法。"]}),"\n",(0,s.jsxs)(n.p,{children:["所以",(0,s.jsx)(n.code,{children:"_.chain(obj)"}),"和",(0,s.jsx)(n.code,{children:"_(obj).chain()"}),"效果一样，都能实现链式调用。"]}),"\n",(0,s.jsx)(n.p,{children:"关于上述的链式调用，笔者画了一张图，所谓一图胜千言。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"underscore.js 链式调用图解",src:t})}),"\n",(0,s.jsxs)(n.h3,{id:"51-_mixin-挂载自定义方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-_mixin-挂载自定义方法",children:"#"}),"5.1 _.mixin 挂载自定义方法"]}),"\n",(0,s.jsx)(n.p,{children:"挂载自定义方法：\n举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.mixin({\n	log: function(){\n		console.log('哎呀，我被调用了');\n	}\n})\n_.log() // 哎呀，我被调用了\n_().log() // 哎呀，我被调用了\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"52-_functionsobj",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-_functionsobj",children:"#"}),"5.2 _.functions(obj)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_.functions = _.methods = function(obj) {\n	var names = [];\n	for (var key in obj) {\n	if (_.isFunction(obj[key])) names.push(key);\n	}\n	return names.sort();\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_.functions"})," 和 ",(0,s.jsx)(n.code,{children:"_.methods"})," 两个方法，遍历对象上的方法，放入一个数组，并且排序。返回排序后的数组。"]}),"\n",(0,s.jsxs)(n.h3,{id:"53underscorejs-究竟在_和_prototype挂载了多少方法和属性",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53underscorejs-究竟在_和_prototype挂载了多少方法和属性",children:"#"}),"5.3",(0,s.jsx)(n.code,{children:"underscore.js"})," 究竟在",(0,s.jsx)(n.code,{children:"_"}),"和",(0,s.jsx)(n.code,{children:"_.prototype"}),"挂载了多少方法和属性"]}),"\n",(0,s.jsxs)(n.p,{children:["再来看下",(0,s.jsx)(n.code,{children:"underscore.js"}),"究竟挂载在",(0,s.jsx)(n.code,{children:"_函数对象"}),"上有多少静态方法和属性，和挂载",(0,s.jsx)(n.code,{children:"_.prototype"}),"上有多少方法和属性。"]}),"\n",(0,s.jsxs)(n.p,{children:["使用",(0,s.jsx)(n.code,{children:"for in"}),"循环一试便知。看如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'var staticMethods = [];\nvar staticProperty = [];\nfor(var name in _){\n	if(typeof _[name] === \'function\'){\n		staticMethods.push(name);\n	}\n	else{\n		staticProperty.push(name);\n	}\n}\nconsole.log(staticProperty); // ["VERSION", "templateSettings"] 两个\nconsole.log(staticMethods); // ["after", "all", "allKeys", "any", "assign", ...] 138个\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'var prototypeMethods = [];\nvar prototypeProperty = [];\nfor(var name in _.prototype){\n	if(typeof _.prototype[name] === \'function\'){\n		prototypeMethods.push(name);\n	}\n	else{\n		prototypeProperty.push(name);\n	}\n}\nconsole.log(prototypeProperty); // []\nconsole.log(prototypeMethods); // ["after", "all", "allKeys", "any", "assign", ...] 152个\n'})}),"\n",(0,s.jsxs)(n.p,{children:["根据这些，笔者又画了一张图",(0,s.jsx)(n.code,{children:"underscore.js"})," 原型关系图，毕竟一图胜千言。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"underscore.js 原型关系图",src:d})}),"\n",(0,s.jsxs)(n.h2,{id:"6-整体架构概览",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-整体架构概览",children:"#"}),"6. 整体架构概览"]}),"\n",(0,s.jsxs)(n.h3,{id:"61-匿名函数自执行",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-匿名函数自执行",children:"#"}),"6.1 匿名函数自执行"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(function(){\n\n}());\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样保证不污染外界环境，同时隔离外界环境，不是外界影响内部环境。"}),"\n",(0,s.jsxs)(n.p,{children:["外界访问不到里面的变量和函数，里面可以访问到外界的变量，但里面定义了自己的变量，则不会访问外界的变量。\n匿名函数将代码包裹在里面，防止与其他代码冲突和污染全局环境。\n关于自执行函数不是很了解的读者可以参看这篇文章。\n",(0,s.jsx)(n.a,{href:"https://segmentfault.com/a/1190000003985390",rel:"noopener noreferrer",target:"_blank",children:"[译] JavaScript：立即执行函数表达式（IIFE）"})]}),"\n",(0,s.jsxs)(n.h3,{id:"62-root-处理",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-root-处理",children:"#"}),"6.2 root 处理"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var root = typeof self == 'object' && self.self === self && self ||\n	typeof global == 'object' && global.global === global && global ||\n	this ||\n	{};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["支持",(0,s.jsx)(n.code,{children:"浏览器环境"}),"、",(0,s.jsx)(n.code,{children:"node"}),"、",(0,s.jsx)(n.code,{children:"Web Worker"}),"、",(0,s.jsx)(n.code,{children:"node vm"}),"、",(0,s.jsx)(n.code,{children:"微信小程序"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"63-导出",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#63-导出",children:"#"}),"6.3 导出"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (typeof exports != 'undefined' && !exports.nodeType) {\n	if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n	exports = module.exports = _;\n	}\n	exports._ = _;\n} else {\n	root._ = _;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["关于",(0,s.jsx)(n.code,{children:"root处理"}),"和",(0,s.jsx)(n.code,{children:"导出"}),"的这两段代码的解释，推荐看这篇文章",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5a0bae515188252964213855",rel:"noopener noreferrer",target:"_blank",children:"冴羽：underscore 系列之如何写自己的 underscore"}),"，讲得真的太好了。笔者在此就不赘述了。\n总之，",(0,s.jsx)(n.code,{children:"underscore.js"}),"作者对这些处理也不是一蹴而就的，也是慢慢积累，和其他人提",(0,s.jsx)(n.code,{children:"ISSUE"}),"之后不断改进的。"]}),"\n",(0,s.jsxs)(n.h3,{id:"64-支持amd-模块化规范",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#64-支持amd-模块化规范",children:"#"}),"6.4 支持",(0,s.jsx)(n.code,{children:"amd"})," 模块化规范"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (typeof define == 'function' && define.amd) {\n	define('underscore', [], function() {\n		return _;\n	});\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"65-_noconflict-防冲突函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#65-_noconflict-防冲突函数",children:"#"}),"6.5 _.noConflict 防冲突函数"]}),"\n",(0,s.jsx)(n.p,{children:"源码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 暂存在 root 上， 执行noConflict时再赋值回来\nvar previousUnderscore = root._;\n_.noConflict = function() {\n	root._ = previousUnderscore;\n	return this;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"<script>\nvar _ = '我就是我，不一样的烟火，其他可不要覆盖我呀';\n<\/script>\n<script src=\"https://unpkg.com/underscore@1.9.1/underscore.js\">\n<\/script>\n<script>\nvar underscore = _.noConflict();\nconsole.log(_); // '我就是我，不一样的烟火，其他可不要覆盖我呀'\nunderscore.isArray([]) // true\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"7-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-总结",children:"#"}),"7. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["全文根据官网提供的链式调用的例子， ",(0,s.jsx)(n.code,{children:"_.chain([1, 2, 3]).reverse().value();"}),"较为深入的调试和追踪代码，分析链式调用（",(0,s.jsx)(n.code,{children:"_.chain()"})," 和 ",(0,s.jsx)(n.code,{children:"_(obj).chain()"}),"）、",(0,s.jsx)(n.code,{children:"OOP"}),"、基于流式编程、和",(0,s.jsx)(n.code,{children:"_.mixin(_)"}),"在",(0,s.jsx)(n.code,{children:"_.prototype"}),"挂载方法，最后整体架构分析。学习",(0,s.jsx)(n.code,{children:"underscore.js"}),"整体架构，利于打造属于自己的函数式编程类库。"]}),"\n",(0,s.jsx)(n.p,{children:"文章分析的源码整体结构。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(function() {\n	var root = typeof self == 'object' && self.self === self && self ||\n		typeof global == 'object' && global.global === global && global ||\n		this ||\n		{};\n	var previousUnderscore = root._;\n\n	var _ = function(obj) {\n	  if (obj instanceof _) return obj;\n	  if (!(this instanceof _)) return new _(obj);\n	  this._wrapped = obj;\n	};\n\n	if (typeof exports != 'undefined' && !exports.nodeType) {\n	  if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n		exports = module.exports = _;\n	  }\n	  exports._ = _;\n	} else {\n	  root._ = _;\n	}\n	_.VERSION = '1.9.1';\n\n	_.chain = function(obj) {\n	  var instance = _(obj);\n	  instance._chain = true;\n	  return instance;\n	};\n\n	var chainResult = function(instance, obj) {\n	  return instance._chain ? _(obj).chain() : obj;\n	};\n\n	_.mixin = function(obj) {\n	  _.each(_.functions(obj), function(name) {\n		var func = _[name] = obj[name];\n		_.prototype[name] = function() {\n		  var args = [this._wrapped];\n		  push.apply(args, arguments);\n		  return chainResult(this, func.apply(_, args));\n		};\n	  });\n	  return _;\n	};\n\n	_.mixin(_);\n\n	_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n	  var method = ArrayProto[name];\n	  _.prototype[name] = function() {\n		var obj = this._wrapped;\n		method.apply(obj, arguments);\n		if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n		return chainResult(this, obj);\n	  };\n	});\n\n	_.each(['concat', 'join', 'slice'], function(name) {\n	  var method = ArrayProto[name];\n	  _.prototype[name] = function() {\n		return chainResult(this, method.apply(this._wrapped, arguments));\n	  };\n	});\n\n	_.prototype.value = function() {\n	  return this._wrapped;\n	};\n\n	_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n	_.prototype.toString = function() {\n	  return String(this._wrapped);\n	};\n\n	if (typeof define == 'function' && define.amd) {\n	  define('underscore', [], function() {\n		return _;\n	  });\n	}\n}());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["下一篇文章可能是学习",(0,s.jsx)(n.code,{children:"lodash"}),"的源码整体架构。"]}),"\n",(0,s.jsx)(n.p,{children:"读者发现有不妥或可改善之处，欢迎评论指出。另外觉得写得不错，可以点赞、评论、转发，也是对笔者的一种支持。"}),"\n",(0,s.jsxs)(n.h2,{id:"8-推荐阅读",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-推荐阅读",children:"#"}),"8. 推荐阅读"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://underscorejs.org/",rel:"noopener noreferrer",target:"_blank",children:"underscorejs.org 官网"}),"\n",(0,s.jsx)(n.a,{href:"https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/",rel:"noopener noreferrer",target:"_blank",children:"undersercore-analysis"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5a0bae515188252964213855",rel:"noopener noreferrer",target:"_blank",children:"underscore 系列之如何写自己的 underscore"})]}),"\n",(0,s.jsxs)(n.h2,{id:"笔者往期文章",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔者往期文章",children:"#"}),"笔者往期文章"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5b86732451882542af1c8082",rel:"noopener noreferrer",target:"_blank",children:"前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并"})]}),"\n",(0,s.jsxs)(n.h2,{id:"关于",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，使用",(0,s.jsx)(n.code,{children:"vuepress"}),"重构了，阅读体验可能更好些","\n",(0,s.jsx)(n.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,s.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，开通了",(0,s.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，开通了",(0,s.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://www.yuque.com/lxchuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"语雀前端视野专栏"}),"，新增语雀专栏，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,s.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,s.jsxs)(n.h2,{id:"微信公众号--若川视野",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,s.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注（",(0,s.jsx)(n.strong,{children:"回复pdf获取前端优质书籍pdf"}),"）。欢迎加笔者微信",(0,s.jsx)(n.code,{children:"ruochuan12"}),"（注明来源，基本来者不拒），拉您进【前端视野交流群】，长期交流学习~"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"若川视野",src:a})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(h,e)})):h(e)}let j=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["underscore%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-链式调用",text:"2. 链式调用",depth:2},{id:"3_-函数对象-支持oop",text:"3.`_` 函数对象 支持`OOP`",depth:2},{id:"4-基于流的编程",text:"4. 基于流的编程",depth:2},{id:"5_mixin-挂载所有的静态方法到_prototype-也可以挂载自定义的方法",text:"5.`_.mixin` 挂载所有的静态方法到`_.prototype`， 也可以挂载自定义的方法",depth:2},{id:"51-_mixin-挂载自定义方法",text:"5.1 _.mixin 挂载自定义方法",depth:3},{id:"52-_functionsobj",text:"5.2 _.functions(obj)",depth:3},{id:"53underscorejs-究竟在_和_prototype挂载了多少方法和属性",text:"5.3`underscore.js` 究竟在`_`和`_.prototype`挂载了多少方法和属性",depth:3},{id:"6-整体架构概览",text:"6. 整体架构概览",depth:2},{id:"61-匿名函数自执行",text:"6.1 匿名函数自执行",depth:3},{id:"62-root-处理",text:"6.2 root 处理",depth:3},{id:"63-导出",text:"6.3 导出",depth:3},{id:"64-支持amd-模块化规范",text:"6.4 支持`amd` 模块化规范",depth:3},{id:"65-_noconflict-防冲突函数",text:"6.5 _.noConflict 防冲突函数",depth:3},{id:"7-总结",text:"7. 总结",depth:2},{id:"8-推荐阅读",text:"8. 推荐阅读",depth:2},{id:"笔者往期文章",text:"笔者往期文章",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"学习`underscore`源码整体架构，打造属于自己的函数式编程类库",headingTitle:"学习`underscore`源码整体架构，打造属于自己的函数式编程类库",frontmatter:{}}},20713:function(e,n,r){r.d(n,{Z:()=>d});var s=r(52676),c=r(75271),o=r(92815);r(18544);let i={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function t(e,n,r){let s=Object.keys(i).includes(n)?n:r;return i[s](e)}let d=e=>{let{defaultLocale:n="en-US"}=e,r=(0,o.Vi)().page.readingTimeData,i=(0,o.Jr)(),d=(0,o.e7)(),[a,h]=(0,c.useState)(t(r,i,n));return(0,c.useEffect)(()=>{h(t(r,i,n))},[i,r]),(0,s.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:a})}}}]);