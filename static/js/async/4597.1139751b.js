"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["4597"],{60332:function(n,e,r){n.exports=r.p+"static/image/wechat-official-accounts-mini.44481959.png"},65949:function(n,e,r){r.r(e),r.d(e,{default:()=>t});var s=r(52676),l=r(40453),c=r(20713),i=r(60332);function d(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",code:"code",h2:"h2",strong:"strong",pre:"pre",ul:"ul",li:"li",input:"input",img:"img"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"面试官问能否模拟实现js的call和apply方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#面试官问能否模拟实现js的call和apply方法",children:"#"}),"面试官问：能否模拟实现JS的call和apply方法"]}),"\n",(0,s.jsx)(c.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"写于2018年11月30日"})}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"前言",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"}),"前言"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["大家好，我是",(0,s.jsx)(e.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,s.jsx)(e.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(e.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(e.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(e.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["这是面试官问系列的第三篇，旨在帮助读者提升",(0,s.jsx)(e.code,{children:"JS"}),"基础知识，包含",(0,s.jsx)(e.code,{children:"new、call、apply、this、继承"}),"相关知识。","\n",(0,s.jsx)(e.code,{children:"面试官问系列"}),"文章如下：感兴趣的读者可以点击阅读。","\n1.",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n2.",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n3.",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n4.",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n5.",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"})]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["之前写过两篇",(0,s.jsxs)(e.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:["《面试官问：能否模拟实现",(0,s.jsx)(e.code,{children:"JS"}),"的",(0,s.jsx)(e.code,{children:"new"}),"操作符》"]}),"和",(0,s.jsxs)(e.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:["《面试官问：能否模拟实现",(0,s.jsx)(e.code,{children:"JS"}),"的",(0,s.jsx)(e.code,{children:"bind"}),"方法》"]})]}),"\n",(0,s.jsxs)(e.p,{children:["其中模拟",(0,s.jsx)(e.code,{children:"bind"}),"方法时是使用的",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"修改",(0,s.jsx)(e.code,{children:"this"}),"指向。但面试官可能问：能否不用",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"来实现呢。意思也就是需要模拟实现",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"的了。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["附上之前写文章写过的一段话：已经有很多模拟实现",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"先通过mdn认识下call和apply",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#先通过mdn认识下call和apply",children:"#"}),"先通过",(0,s.jsx)(e.code,{children:"MDN"}),"认识下",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call",rel:"noopener noreferrer",target:"_blank",children:"MDN 文档：Function.prototype.call()"}),"\n",(0,s.jsx)(e.strong,{children:"语法"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"fun.call(thisArg, arg1, arg2, ...)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"thisArg"}),"\n在",(0,s.jsx)(e.code,{children:"fun"}),"函数运行时指定的",(0,s.jsx)(e.code,{children:"this"}),"值。需要注意的是，指定的",(0,s.jsx)(e.code,{children:"this"}),"值并不一定是该函数执行时真正的",(0,s.jsx)(e.code,{children:"this"}),"值，如果这个函数处于",(0,s.jsx)(e.strong,{children:"非严格模式"}),"下，则指定为",(0,s.jsx)(e.code,{children:"null"}),"和",(0,s.jsx)(e.code,{children:"undefined"}),"的",(0,s.jsx)(e.code,{children:"this"}),"值会自动指向全局对象(浏览器中就是",(0,s.jsx)(e.code,{children:"window"}),"对象)，同时值为原始值(数字，字符串，布尔值)的",(0,s.jsx)(e.code,{children:"this"}),"会指向该原始值的自动包装对象。","\n",(0,s.jsx)(e.strong,{children:"arg1, arg2, ..."}),"\n指定的参数列表","\n",(0,s.jsx)(e.strong,{children:"返回值"}),"\n返回值是你调用的方法的返回值，若该方法没有返回值，则返回",(0,s.jsx)(e.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply",rel:"noopener noreferrer",target:"_blank",children:"MDN 文档：Function.prototype.apply()"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"func.apply(thisArg, [argsArray])\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"thisArg"}),"\n可选的。在 ",(0,s.jsx)(e.code,{children:"func"})," 函数运行时使用的 ",(0,s.jsx)(e.code,{children:"this"})," 值。请注意，",(0,s.jsx)(e.code,{children:"this"}),"可能不是该方法看到的实际值：如果这个函数处于",(0,s.jsx)(e.strong,{children:"非严格模式"}),"下，则指定为 ",(0,s.jsx)(e.code,{children:"null"})," 或 ",(0,s.jsx)(e.code,{children:"undefined"})," 时会自动替换为指向全局对象，原始值会被包装。","\n",(0,s.jsx)(e.strong,{children:"argsArray"}),"\n可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 ",(0,s.jsx)(e.code,{children:"func"})," 函数。如果该参数的值为 ",(0,s.jsx)(e.code,{children:"null"})," 或  ",(0,s.jsx)(e.code,{children:"undefined"}),"，则表示不需要传入任何参数。从",(0,s.jsx)(e.code,{children:"ECMAScript 5"})," 开始可以使用类数组对象。","\n",(0,s.jsx)(e.strong,{children:"返回值"}),"\n调用有指定this值和参数的函数的结果。\n直接先看",(0,s.jsx)(e.strong,{children:"例子1"})]}),"\n",(0,s.jsxs)(e.h2,{id:"call-和apply-的异同",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#call-和apply-的异同",children:"#"}),(0,s.jsx)(e.code,{children:"call"})," 和",(0,s.jsx)(e.code,{children:"apply"})," 的异同"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"相同点："}),"\n1、",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"的第一个参数",(0,s.jsx)(e.code,{children:"thisArg"}),"，都是",(0,s.jsx)(e.code,{children:"func"}),"运行时指定的",(0,s.jsx)(e.code,{children:"this"}),"。而且，",(0,s.jsx)(e.code,{children:"this"}),"可能不是该方法看到的实际值：如果这个函数处于",(0,s.jsx)(e.strong,{children:"非严格模式"}),"下，则指定为 ",(0,s.jsx)(e.code,{children:"null"})," 或 ",(0,s.jsx)(e.code,{children:"undefined"})," 时会自动替换为指向全局对象，原始值会被包装。","\n2、都可以只传递一个参数。","\n",(0,s.jsx)(e.strong,{children:"不同点："}),(0,s.jsx)(e.code,{children:"apply"}),"只接收两个参数，第二个参数可以是数组也可以是类数组，其实也可以是对象，后续的参数忽略不计。",(0,s.jsx)(e.code,{children:"call"}),"接收第二个及以后一系列的参数。","\n看两个简单例子1和2**："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 例子1：浏览器环境 非严格模式下\nvar doSth = function(a, b){\n    console.log(this);\n    console.log([a, b]);\n}\ndoSth.apply(null, [1, 2]); // this是window  // [1, 2]\ndoSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]\ndoSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]\ndoSth.call(undefined, 1, 2); // this 是 window // [1, 2]\ndoSth.call('0', 1, {a: 1}); // this 是 String('0') // [1, {a: 1}]\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 例子2：浏览器环境 严格模式下\n'use strict';\nvar doSth2 = function(a, b){\n    console.log(this);\n    console.log([a, b]);\n}\ndoSth2.call(0, 1, 2); // this 是 0 // [1, 2]\ndoSth2.apply('1'); // this 是 '1' // [undefined, undefined]\ndoSth2.apply(null, [1, 2]); // this 是 null // [1, 2]\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"typeof"})," 有",(0,s.jsx)(e.code,{children:"7"}),"种类型（",(0,s.jsx)(e.code,{children:"undefined number string boolean symbol object function"}),"），笔者都验证了一遍：",(0,s.jsxs)(e.strong,{children:["更加验证了相同点第一点，严格模式下，函数的",(0,s.jsx)(e.code,{children:"this"}),"值就是",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"的第一个参数",(0,s.jsx)(e.code,{children:"thisArg"}),"，非严格模式下，",(0,s.jsx)(e.code,{children:"thisArg"}),"值被指定为 ",(0,s.jsx)(e.code,{children:"null"})," 或 ",(0,s.jsx)(e.code,{children:"undefined"})," 时",(0,s.jsx)(e.code,{children:"this"}),"值会自动替换为指向全局对象，原始值则会被自动包装，也就是",(0,s.jsx)(e.code,{children:"new Object()"})]}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["重新认识了",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"会发现：",(0,s.jsxs)(e.strong,{children:["它们作用都是一样的，改变函数里的",(0,s.jsx)(e.code,{children:"this"}),"指向为第一个参数",(0,s.jsx)(e.code,{children:"thisArg"}),"，如果明确有多少参数，那可以用",(0,s.jsx)(e.code,{children:"call"}),"，不明确则可以使用",(0,s.jsx)(e.code,{children:"apply"}),"。也就是说完全可以不使用",(0,s.jsx)(e.code,{children:"call"}),"，而使用",(0,s.jsx)(e.code,{children:"apply"}),"代替。"]}),"\n也就是说，我们只需要模拟实现",(0,s.jsx)(e.code,{children:"apply"}),"，",(0,s.jsx)(e.code,{children:"call"}),"可以根据参数个数都放在一个数组中，给到",(0,s.jsx)(e.code,{children:"apply"}),"即可。"]}),"\n",(0,s.jsxs)(e.h2,{id:"模拟实现apply",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模拟实现apply",children:"#"}),"模拟实现",(0,s.jsx)(e.code,{children:"apply"})]}),"\n",(0,s.jsxs)(e.p,{children:["既然准备模拟实现",(0,s.jsx)(e.code,{children:"apply"}),"，那先得看看",(0,s.jsx)(e.code,{children:"ES5"}),"规范。",(0,s.jsx)(e.a,{href:"http://es5.github.io/#x15.3.4.3",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(e.code,{children:"ES5规范 英文版"})}),"，",(0,s.jsx)(e.a,{href:"http://yanhaijing.com/es5/#322",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(e.code,{children:"ES5规范 中文版"})}),"。",(0,s.jsx)(e.code,{children:"apply"}),"的规范下一个就是",(0,s.jsx)(e.code,{children:"call"}),"的规范，可以点击打开新标签页去查看，这里摘抄一部分。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Function.prototype.apply (thisArg, argArray)"}),"\n当以 ",(0,s.jsx)(e.code,{children:"thisArg"})," 和 ",(0,s.jsx)(e.code,{children:"argArray"})," 为参数在一个 ",(0,s.jsx)(e.code,{children:"func"})," 对象上调用 ",(0,s.jsx)(e.code,{children:"apply"})," 方法，采用如下步骤："]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["1.如果 ",(0,s.jsx)(e.code,{children:"IsCallable(func)"})," 是 ",(0,s.jsx)(e.code,{children:"false"}),", 则抛出一个 ",(0,s.jsx)(e.code,{children:"TypeError"})," 异常。","\n2.如果 ",(0,s.jsx)(e.code,{children:"argArray"})," 是 ",(0,s.jsx)(e.code,{children:"null"})," 或 ",(0,s.jsx)(e.code,{children:"undefined"}),", 则返回提供 ",(0,s.jsx)(e.code,{children:"thisArg"})," 作为 ",(0,s.jsx)(e.code,{children:"this"})," 值并以空参数列表调用 ",(0,s.jsx)(e.code,{children:"func"})," 的 ",(0,s.jsx)(e.code,{children:"[[Call]]"})," 内部方法的结果。","\n3.返回提供 ",(0,s.jsx)(e.code,{children:"thisArg"})," 作为 ",(0,s.jsx)(e.code,{children:"this"})," 值并以空参数列表调用 ",(0,s.jsx)(e.code,{children:"func"})," 的 ",(0,s.jsx)(e.code,{children:"[[Call]]"})," 内部方法的结果。","\n4.如果 ",(0,s.jsx)(e.code,{children:"Type(argArray)"})," 不是 ",(0,s.jsx)(e.code,{children:"Object"}),", 则抛出一个 ",(0,s.jsx)(e.code,{children:"TypeError"})," 异常。","\n5~8 略","\n9.提供 ",(0,s.jsx)(e.code,{children:"thisArg"})," 作为 ",(0,s.jsx)(e.code,{children:"this"})," 值并以 ",(0,s.jsx)(e.code,{children:"argList"})," 作为参数列表，调用 ",(0,s.jsx)(e.code,{children:"func"})," 的 ",(0,s.jsx)(e.code,{children:"[[Call]]"})," 内部方法，返回结果。","\n",(0,s.jsx)(e.code,{children:"apply"})," 方法的 ",(0,s.jsx)(e.code,{children:"length"})," 属性是 ",(0,s.jsx)(e.code,{children:"2"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["在外面传入的 ",(0,s.jsx)(e.code,{children:"thisArg"})," 值会修改并成为 ",(0,s.jsx)(e.code,{children:"this"})," 值。",(0,s.jsx)(e.code,{children:"thisArg"})," 是 ",(0,s.jsx)(e.code,{children:"undefined"})," 或 ",(0,s.jsx)(e.code,{children:"null"})," 时它会被替换成全局对象，所有其他值会被应用 ",(0,s.jsx)(e.code,{children:"ToObject"})," 并将结果作为 ",(0,s.jsx)(e.code,{children:"this"})," 值，这是第三版引入的更改。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["结合上文和规范，如何将函数里的",(0,s.jsx)(e.code,{children:"this"}),"指向第一个参数",(0,s.jsx)(e.code,{children:"thisArg"}),"呢，这是一个问题。\n这时候请出",(0,s.jsx)(e.strong,{children:"例子3"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 浏览器环境 非严格模式下\nvar doSth = function(a, b){\n    console.log(this);\n    console.log(this.name);\n    console.log([a, b]);\n}\nvar student = {\n    name: '若川',\n    doSth: doSth,\n};\nstudent.doSth(1, 2); // this === student // true // '若川' // [1, 2]\ndoSth.apply(student, [1, 2]); // this === student // true // '若川' // [1, 2]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["可以",(0,s.jsx)(e.strong,{children:"得出结论1"}),"：在对象",(0,s.jsx)(e.code,{children:"student"}),"上加一个函数",(0,s.jsx)(e.code,{children:"doSth"}),"，再执行这个函数，这个函数里的",(0,s.jsx)(e.code,{children:"this"}),"就指向了这个对象。那也就是可以在",(0,s.jsx)(e.code,{children:"thisArg"}),"上新增调用函数，执行后删除这个函数即可。\n知道这些后，我们试着容易实现第一版本："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 浏览器环境 非严格模式\nfunction getGlobalObject(){\n    return this;\n}\nFunction.prototype.applyFn = function apply(thisArg, argsArray){ // `apply` 方法的 `length` 属性是 `2`。\n    // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。\n    if(typeof this !== 'function'){\n        throw new TypeError(this + ' is not a function');\n    }\n\n    // 2.如果 argArray 是 null 或 undefined, 则\n    // 返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。\n    if(typeof argsArray === 'undefined' || argsArray === null){\n        argsArray = [];\n    }\n\n    // 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .\n    if(argsArray !== new Object(argsArray)){\n        throw new TypeError('CreateListFromArrayLike called on non-object');\n    }\n\n    if(typeof thisArg === 'undefined' || thisArg === null){\n        // 在外面传入的 thisArg 值会修改并成为 this 值。\n        // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window\n        thisArg = getGlobalObject();\n    }\n\n    // ES3: 所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。\n    thisArg = new Object(thisArg);\n    var __fn = '__fn';\n    thisArg[__fn] = this;\n    // 9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果\n    var result = thisArg[__fn](...argsArray);\n    delete thisArg[__fn];\n    return result;\n};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"实现第一版后很容易找出两个问题",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现第一版后很容易找出两个问题",children:"#"}),"实现第一版后，很容易找出两个问题："]}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","1.",(0,s.jsx)(e.code,{children:"__fn"})," 同名覆盖问题，",(0,s.jsx)(e.code,{children:"thisArg"}),"对象上有",(0,s.jsx)(e.code,{children:"__fn"}),"，那就被覆盖了然后被删除了。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"针对问题1"}),"\n解决方案一：采用",(0,s.jsx)(e.code,{children:"ES6"})," ",(0,s.jsx)(e.code,{children:"Sybmol()"})," 独一无二的。可以本来就是模拟",(0,s.jsx)(e.code,{children:"ES3"}),"的方法。如果面试官不允许用呢。\n解决方案二：自己用",(0,s.jsx)(e.code,{children:"Math.random()"}),"模拟实现独一无二的",(0,s.jsx)(e.code,{children:"key"}),"。面试时可以直接用生成时间戳即可。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 生成UUID 通用唯一识别码\n// 大概生成 这样一串 '18efca2d-6e25-42bf-a636-30b8f9f2de09'\nfunction generateUUID(){\n    var i, random;\n    var uuid = '';\n    for (i = 0; i < 32; i++) {\n        random = Math.random() * 16 | 0;\n        if (i === 8 || i === 12 || i === 16 || i === 20) {\n            uuid += '-';\n        }\n        uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random))\n            .toString(16);\n    }\n    return uuid;\n}\n// 简单实现\n// '__' + new Date().getTime();\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如果这个",(0,s.jsx)(e.code,{children:"key"}),"万一这对象中还是有，为了保险起见，可以做一次缓存操作。比如如下代码："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"var student = {\n    name: '若川',\n    doSth: 'doSth',\n};\nvar originalVal = student.doSth;\nvar hasOriginalVal = student.hasOwnProperty('doSth');\nstudent.doSth = function(){};\ndelete student.doSth;\n// 如果没有，`originalVal`则为undefined，直接赋值新增了一个undefined，这是不对的，所以需判断一下。\nif(hasOriginalVal){\n    student.doSth = originalVal;\n}\nconsole.log('student:', student); // { name: '若川', doSth: 'doSth' }\n"})}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","2.使用了",(0,s.jsx)(e.code,{children:"ES6"}),"扩展符",(0,s.jsx)(e.code,{children:"..."}),"\n解决方案一：采用",(0,s.jsx)(e.code,{children:"eval"}),"来执行函数。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"eval"}),"把字符串解析成代码执行。","\n",(0,s.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval",rel:"noopener noreferrer",target:"_blank",children:"MDN 文档：eval"}),"\n",(0,s.jsx)(e.strong,{children:"语法"})]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"eval(string)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"参数"}),"\n",(0,s.jsx)(e.strong,{children:"string"}),"\n表示",(0,s.jsx)(e.code,{children:"JavaScript"}),"表达式，语句或一系列语句的字符串。表达式可以包含变量以及已存在对象的属性。","\n",(0,s.jsx)(e.strong,{children:"返回值"}),"\n执行指定代码之后的返回值。如果返回值为空，返回",(0,s.jsx)(e.code,{children:"undefined"}),"\n解决方案二：但万一面试官不允许用",(0,s.jsx)(e.code,{children:"eval"}),"呢，毕竟",(0,s.jsx)(e.code,{children:"eval"}),"是魔鬼。可以采用",(0,s.jsx)(e.code,{children:"new Function()"}),"来生成执行函数。\n",(0,s.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function",rel:"noopener noreferrer",target:"_blank",children:"MDN 文档：Function"}),"\n",(0,s.jsx)(e.strong,{children:"语法"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"new Function ([arg1[, arg2[, ...argN]],] functionBody)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"参数"}),"\n",(0,s.jsx)(e.strong,{children:"arg1, arg2, ... argN"}),"\n被函数使用的参数的名称必须是合法命名的。参数名称是一个有效的",(0,s.jsx)(e.code,{children:"JavaScript"}),"标识符的字符串，或者一个用逗号分隔的有效字符串的列表;例如",(0,s.jsx)(e.code,{children:"“\xd7”"}),"，",(0,s.jsx)(e.code,{children:"“theValue”"}),"，或",(0,s.jsx)(e.code,{children:"“A，B”"}),"。","\n",(0,s.jsx)(e.strong,{children:"functionBody"}),"\n一个含有包括函数定义的",(0,s.jsx)(e.code,{children:"JavaScript"}),"语句的字符串。","\n接下来看两个例子："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"简单例子：\nvar sum = new Function('a', 'b', 'return a + b');\nconsole.log(sum(2, 6));\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 稍微复杂点的例子：\nvar student = {\n    name: '若川',\n    doSth: function(argsArray){\n        console.log(argsArray);\n        console.log(this.name);\n    }\n};\n// var result = student.doSth(['若川i', 18]);\n// 用new Function()生成函数并执行返回结果\nvar result = new Function('return arguments[0][arguments[1]](arguments[2][0], arguments[2][1])')(student, 'doSth', ['若川i', 18]);\n// 个数不定\n// 所以可以写一个函数生成函数代码：\nfunction generateFunctionCode(argsArrayLength){\n    var code = 'return arguments[0][arguments[1]](';\n    for(var i = 0; i < argsArrayLength; i++){\n        if(i > 0){\n            code += ',';\n        }\n        code += 'arguments[2][' + i + ']';\n    }\n    code += ')';\n    // return arguments[0][arguments[1]](arg1, arg2, arg3...)\n    return code;\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"你可能不知道在es3es5中undefined-是能修改的",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#你可能不知道在es3es5中undefined-是能修改的",children:"#"}),"你可能不知道在",(0,s.jsx)(e.code,{children:"ES3、ES5"}),"中",(0,s.jsx)(e.code,{children:"undefined"})," 是能修改的"]}),"\n",(0,s.jsxs)(e.p,{children:["可能大部分人不知道。",(0,s.jsx)(e.code,{children:"ES5"}),"中虽然在全局作用域下不能修改，但在局部作用域中也是能修改的，不信可以复制以下测试代码在控制台执行下。虽然一般情况下是不会的去修改它。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function test(){\n    var undefined = 3;\n    console.log(undefined); // chrome下也是 3\n}\ntest();\n"})}),"\n",(0,s.jsxs)(e.p,{children:["所以判断一个变量",(0,s.jsx)(e.code,{children:"a"}),"是不是",(0,s.jsx)(e.code,{children:"undefined"}),"，更严谨的方案是",(0,s.jsx)(e.code,{children:"typeof a === 'undefined'"}),"或者",(0,s.jsx)(e.code,{children:"a === void 0;"}),"\n这里面用的是",(0,s.jsx)(e.code,{children:"void"}),"，",(0,s.jsx)(e.code,{children:"void"}),"的作用是计算表达式，始终返回",(0,s.jsx)(e.code,{children:"undefined"}),"，也可以这样写",(0,s.jsx)(e.code,{children:"void(0)"}),"。\n更多可以查看",(0,s.jsx)(e.code,{children:"韩子迟"}),"的这篇文章：",(0,s.jsx)(e.a,{href:"https://github.com/hanzichi/underscore-analysis/issues/1",rel:"noopener noreferrer",target:"_blank",children:"为什么用「void 0」代替「undefined」"}),"\n解决了这几个问题，比较容易实现如下代码。"]}),"\n",(0,s.jsxs)(e.h2,{id:"使用new-function-模拟实现的apply",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用new-function-模拟实现的apply",children:"#"}),"使用",(0,s.jsx)(e.code,{children:"new Function()"})," 模拟实现的",(0,s.jsx)(e.code,{children:"apply"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 浏览器环境 非严格模式\nfunction getGlobalObject(){\n    return this;\n}\nfunction generateFunctionCode(argsArrayLength){\n    var code = 'return arguments[0][arguments[1]](';\n    for(var i = 0; i < argsArrayLength; i++){\n        if(i > 0){\n            code += ',';\n        }\n        code += 'arguments[2][' + i + ']';\n    }\n    code += ')';\n    // return arguments[0][arguments[1]](arg1, arg2, arg3...)\n    return code;\n}\nFunction.prototype.applyFn = function apply(thisArg, argsArray){ // `apply` 方法的 `length` 属性是 `2`。\n    // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。\n    if(typeof this !== 'function'){\n        throw new TypeError(this + ' is not a function');\n    }\n    // 2.如果 argArray 是 null 或 undefined, 则\n    // 返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。\n    if(typeof argsArray === 'undefined' || argsArray === null){\n        argsArray = [];\n    }\n    // 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 .\n    if(argsArray !== new Object(argsArray)){\n        throw new TypeError('CreateListFromArrayLike called on non-object');\n    }\n    if(typeof thisArg === 'undefined' || thisArg === null){\n        // 在外面传入的 thisArg 值会修改并成为 this 值。\n        // ES3: thisArg 是 undefined 或 null 时它会被替换成全局对象 浏览器里是window\n        thisArg = getGlobalObject();\n    }\n    // ES3: 所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。\n    thisArg = new Object(thisArg);\n    var __fn = '__' + new Date().getTime();\n    // 万一还是有 先存储一份，删除后，再恢复该值\n    var originalVal = thisArg[__fn];\n    // 是否有原始值\n    var hasOriginalVal = thisArg.hasOwnProperty(__fn);\n    thisArg[__fn] = this;\n    // 9.提供 `thisArg` 作为 `this` 值并以 `argList` 作为参数列表，调用 `func` 的 `[[Call]]` 内部方法，返回结果。\n    // ES6版\n    // var result = thisArg[__fn](...args);\n    var code = generateFunctionCode(argsArray.length);\n    var result = (new Function(code))(thisArg, __fn, argsArray);\n    delete thisArg[__fn];\n    if(hasOriginalVal){\n        thisArg[__fn] = originalVal;\n    }\n    return result;\n};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"利用模拟实现的apply模拟实现call",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#利用模拟实现的apply模拟实现call",children:"#"}),"利用模拟实现的",(0,s.jsx)(e.code,{children:"apply"}),"模拟实现",(0,s.jsx)(e.code,{children:"call"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"Function.prototype.callFn = function call(thisArg){\n    var argsArray = [];\n    var argumentsLength = arguments.length;\n    for(var i = 0; i < argumentsLength - 1; i++){\n        // argsArray.push(arguments[i + 1]);\n        argsArray[i] = arguments[i + 1];\n    }\n    console.log('argsArray:', argsArray);\n    return this.applyFn(thisArg, argsArray);\n}\n// 测试例子\nvar doSth = function (name, age){\n    var type = Object.prototype.toString.call(this);\n    console.log(typeof doSth);\n    console.log(this === firstArg);\n    console.log('type:', type);\n    console.log('this:', this);\n    console.log('args:', [name, age], arguments);\n    return 'this--';\n};\n\nvar name = 'window';\n\nvar student = {\n    name: '若川',\n    age: 18,\n    doSth: 'doSth',\n    __fn: 'doSth',\n};\nvar firstArg = student;\nvar result = doSth.applyFn(firstArg, [1, {name: '若川i'}]);\nvar result2 = doSth.callFn(firstArg, 1, {name: '若川i'});\nconsole.log('result:', result);\nconsole.log('result2:', result2);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["细心的你会发现注释了这一句",(0,s.jsx)(e.code,{children:"argsArray.push(arguments[i + 1]);"}),"，事实上",(0,s.jsx)(e.code,{children:"push"}),"方法，内部也有一层循环。所以理论上不使用",(0,s.jsx)(e.code,{children:"push"}),"性能会更好些。面试官也可能根据这点来问时间复杂度和空间复杂度的问题。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 看看V8引擎中的具体实现：\nfunction ArrayPush() {\n    var n = TO_UINT32( this.length );    // 被push的对象的length\n    var m = %_ArgumentsLength();     // push的参数个数\n    for (var i = 0; i < m; i++) {\n        this[ i + n ] = %_Arguments( i );   // 复制元素     (1)\n    }\n    this.length = n + m;      // 修正length属性的值    (2)\n    return this.length;\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["行文至此，就基本结束了，你可能还发现就是写的非严格模式下，",(0,s.jsx)(e.code,{children:"thisArg"}),"原始值会包装成对象，添加函数并执行，再删除。而严格模式下还是原始值这个没有实现，而且万一这个对象是冻结对象呢，",(0,s.jsx)(e.code,{children:"Object.freeze({})"}),"，是无法在这个对象上添加属性的。所以这个方法只能算是非严格模式下的简版实现。最后来总结一下。"]}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,s.jsxs)(e.p,{children:["通过",(0,s.jsx)(e.code,{children:"MDN"}),"认识",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),"，阅读",(0,s.jsx)(e.code,{children:"ES5"}),"规范，到模拟实现",(0,s.jsx)(e.code,{children:"apply"}),"，再实现",(0,s.jsx)(e.code,{children:"call"}),"。","\n就是使用在对象上添加调用",(0,s.jsx)(e.code,{children:"apply"}),"的函数执行，这时的调用函数的",(0,s.jsx)(e.code,{children:"this"}),"就指向了这个",(0,s.jsx)(e.code,{children:"thisArg"}),"，再返回结果。引出了",(0,s.jsx)(e.code,{children:"ES6 Symbol"}),"，",(0,s.jsx)(e.code,{children:"ES6"}),"的扩展符",(0,s.jsx)(e.code,{children:"..."}),"、",(0,s.jsx)(e.code,{children:"eval"}),"、",(0,s.jsx)(e.code,{children:"new Function()"}),"，严格模式等。","\n事实上，现实业务场景不需要去模拟实现",(0,s.jsx)(e.code,{children:"call"}),"和",(0,s.jsx)(e.code,{children:"apply"}),",毕竟是",(0,s.jsx)(e.code,{children:"ES3"}),"就提供的方法。但面试官可以通过这个面试题考察候选人很多基础知识。如：",(0,s.jsx)(e.code,{children:"call"}),"、",(0,s.jsx)(e.code,{children:"apply"}),"的使用。",(0,s.jsx)(e.code,{children:"ES6 Symbol"}),"，",(0,s.jsx)(e.code,{children:"ES6"}),"的扩展符",(0,s.jsx)(e.code,{children:"..."}),"，",(0,s.jsx)(e.code,{children:"eval"}),"，",(0,s.jsx)(e.code,{children:"new Function()"}),"，严格模式，甚至时间复杂度和空间复杂度等。","\n读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 最终版版 删除注释版，详细注释看文章\n// 浏览器环境 非严格模式\nfunction getGlobalObject(){\n    return this;\n}\nfunction generateFunctionCode(argsArrayLength){\n    var code = 'return arguments[0][arguments[1]](';\n    for(var i = 0; i < argsArrayLength; i++){\n        if(i > 0){\n            code += ',';\n        }\n        code += 'arguments[2][' + i + ']';\n    }\n    code += ')';\n    return code;\n}\nFunction.prototype.applyFn = function apply(thisArg, argsArray){\n    if(typeof this !== 'function'){\n        throw new TypeError(this + ' is not a function');\n    }\n    if(typeof argsArray === 'undefined' || argsArray === null){\n        argsArray = [];\n    }\n    if(argsArray !== new Object(argsArray)){\n        throw new TypeError('CreateListFromArrayLike called on non-object');\n    }\n    if(typeof thisArg === 'undefined' || thisArg === null){\n        thisArg = getGlobalObject();\n    }\n    thisArg = new Object(thisArg);\n    var __fn = '__' + new Date().getTime();\n    var originalVal = thisArg[__fn];\n    var hasOriginalVal = thisArg.hasOwnProperty(__fn);\n    thisArg[__fn] = this;\n    var code = generateFunctionCode(argsArray.length);\n    var result = (new Function(code))(thisArg, __fn, argsArray);\n    delete thisArg[__fn];\n    if(hasOriginalVal){\n        thisArg[__fn] = originalVal;\n    }\n    return result;\n};\nFunction.prototype.callFn = function call(thisArg){\n    var argsArray = [];\n    var argumentsLength = arguments.length;\n    for(var i = 0; i < argumentsLength - 1; i++){\n        argsArray[i] = arguments[i + 1];\n    }\n    return this.applyFn(thisArg, argsArray);\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"扩展阅读",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"}),"扩展阅读"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"http://www.ituring.com.cn/book/tupubarticle/7768",rel:"noopener noreferrer",target:"_blank",children:"《JavaScript设计模式与开发实践》- 第二章 第 2 章　this、call和apply"}),"\n",(0,s.jsx)(e.a,{href:"https://cloud.tencent.com/developer/article/1023535",rel:"noopener noreferrer",target:"_blank",children:"JS魔法堂：再次认识Function.prototype.call"}),"\n",(0,s.jsx)(e.a,{href:"https://github.com/jawil/blog/issues/16",rel:"noopener noreferrer",target:"_blank",children:"不用call和apply方法模拟实现ES5的bind方法"}),"\n",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5907eb99570c3500582ca23c",rel:"noopener noreferrer",target:"_blank",children:"JavaScript深入之call和apply的模拟实现"})]}),"\n",(0,s.jsxs)(e.h2,{id:"关于",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,s.jsxs)(e.p,{children:["作者：常以",(0,s.jsx)(e.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,s.jsx)(e.a,{href:"https://ruochuan12.github.io/",rel:"noopener noreferrer",target:"_blank",children:"个人博客"}),"\n",(0,s.jsx)(e.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,s.jsxs)(e.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(e.code,{children:"segmentfault"}),"前端视野专栏"]}),"，开通了",(0,s.jsx)(e.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,s.jsx)(e.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，开通了",(0,s.jsx)(e.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,s.jsx)(e.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,s.jsx)(e.code,{children:"star"}),"^_^~"]}),"\n",(0,s.jsxs)(e.h2,{id:"微信公众号--若川视野",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,s.jsxs)(e.p,{children:["可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ",(0,s.jsx)(e.code,{children:"ruochuan12"}),"，注明来源，拉您进【前端视野交流群】。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"若川视野",src:i})})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(d,n)})):d(n)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["js-implement-call-apply%2Findex.md"]={toc:[{id:"前言",text:"前言",depth:2},{id:"先通过mdn认识下call和apply",text:"先通过`MDN`认识下`call`和`apply`",depth:2},{id:"call-和apply-的异同",text:"`call` 和`apply` 的异同",depth:2},{id:"模拟实现apply",text:"模拟实现`apply`",depth:2},{id:"实现第一版后很容易找出两个问题",text:"实现第一版后，很容易找出两个问题：",depth:2},{id:"你可能不知道在es3es5中undefined-是能修改的",text:"你可能不知道在`ES3、ES5`中`undefined` 是能修改的",depth:2},{id:"使用new-function-模拟实现的apply",text:"使用`new Function()` 模拟实现的`apply`",depth:2},{id:"利用模拟实现的apply模拟实现call",text:"利用模拟实现的`apply`模拟实现`call`",depth:2},{id:"总结",text:"总结",depth:2},{id:"扩展阅读",text:"扩展阅读",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"面试官问：能否模拟实现JS的call和apply方法",headingTitle:"面试官问：能否模拟实现JS的call和apply方法",frontmatter:{}}},20713:function(n,e,r){r.d(e,{Z:()=>a});var s=r(52676),l=r(75271),c=r(92815);r(18544);let i={"zh-CN":n=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${n.minutes>=1?`${Math.ceil(n.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function d(n,e,r){let s=Object.keys(i).includes(e)?e:r;return i[s](n)}let a=n=>{let{defaultLocale:e="en-US"}=n,r=(0,c.Vi)().page.readingTimeData,i=(0,c.Jr)(),a=(0,c.e7)(),[t,h]=(0,l.useState)(d(r,i,e));return(0,l.useEffect)(()=>{h(d(r,i,e))},[i,r]),(0,s.jsx)("span",{"data-dark":String(a),className:"rp-reading-time",children:t})}}}]);