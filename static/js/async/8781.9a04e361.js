"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["8781"],{60135:function(e,n,s){s.r(n),s.d(n,{default:()=>b});var r=s(52676),i=s(40453),t=s(20713);let l=s.p+"static/image/kernal-this.9936ddba.png",c=s.p+"static/image/kernal.69916d38.png",o=s.p+"static/image/presets.c9cb6431.png",a=s.p+"static/image/hooks.dc29e3b6.jpeg",d=s.p+"static/image/ctx.registerMethod.2a44b61f.png",h=s.p+"static/image/ctx.registerMethod-2.418aea4a.png",g=s.p+"static/image/resolvedCliAndProjectPresets.28d52fb7.png",p=s.p+"static/image/methods.9d390fe5.png",u=s.p+"static/image/command-hooks.d940b169.png",x=s.p+"static/image/plugins.6ad48e10.png",j=s.p+"static/image/applyCliCommandPlugin.ae951da6.png",m=s.p+"static/image/applyPlugins.aabe9b2c.png";function P(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",input:"input",pre:"pre",strong:"strong",img:"img",blockquote:"blockquote",ol:"ol",h3:"h3",h4:"h4",hr:"hr"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"taro-源码揭秘2-揭开整个架构的插件系统的秘密",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘2-揭开整个架构的插件系统的秘密",children:"#"}),"Taro 源码揭秘：2. 揭开整个架构的插件系统的秘密"]}),"\n",(0,r.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,r.jsxs)(n.p,{children:["大家好，我是",(0,r.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,r.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,r.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,r.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,r.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,r.jsxs)(n.p,{children:["截至目前（",(0,r.jsx)(n.code,{children:"2024-07-17"}),"），",(0,r.jsx)(n.code,{children:"taro"})," 正式版是 ",(0,r.jsx)(n.code,{children:"3.6.34"}),"，",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。文章提到将于 2024 年第二季度，发布 ",(0,r.jsx)(n.code,{children:"4.x"}),"。目前已经发布 ",(0,r.jsx)(n.code,{children:"4.x"}),"。所以我们直接学习 ",(0,r.jsx)(n.code,{children:"main"})," 分支最新版本是 ",(0,r.jsx)(n.code,{children:"4.0.2"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,r.jsx)(n.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,r.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"学完本文，你将学到："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"1. 如何合并预设插件集合和插件（CLI、用户项目（config/index.ts）、全局插件`/Users/用户名/.taro-global-config`）\n2. 插件是如何注册的\n3. 插件如何调用的\n等等\n"})}),"\n",(0,r.jsxs)(n.p,{children:["关于克隆项目、环境准备、如何调试代码等，参考",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章-准备工作、调试"}),"。后续文章基本不再过多赘述。"]}),"\n",(0,r.jsxs)(n.p,{children:["上一篇文章中提到 ",(0,r.jsx)(n.code,{children:"CLI"})," 最终执行的是 ",(0,r.jsx)(n.code,{children:"Kernel"})," (内核) 中的 ",(0,r.jsx)(n.code,{children:"run"})," 函数，其中 ",(0,r.jsx)(n.code,{children:"this.initPresetsAndPlugins"})," 初始化预设插件集合和插件没讲述。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们先来回顾一下上文中的 ",(0,r.jsx)(n.code,{children:"Kernal"})," 构造函数。",(0,r.jsx)(n.strong,{children:"文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。"})]}),"\n",(0,r.jsxs)(n.h2,{id:"2-new-kernal-构造函数",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-new-kernal-构造函数",children:"#"}),"2. new Kernal 构造函数"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'interface IKernelOptions {\n	appPath: string;\n	config: Config;\n	presets?: PluginItem[];\n	plugins?: PluginItem[];\n}\n\nexport default class Kernel extends EventEmitter {\n	constructor(options: IKernelOptions) {\n		super();\n		this.debugger =\n			process.env.DEBUG === "Taro:Kernel"\n				? helper.createDebug("Taro:Kernel")\n				: function () {};\n		this.appPath = options.appPath || process.cwd();\n		this.optsPresets = options.presets;\n		this.optsPlugins = options.plugins;\n		this.config = options.config;\n		this.hooks = new Map();\n		this.methods = new Map();\n		this.commands = new Map();\n		this.platforms = new Map();\n		this.initHelper();\n		this.initConfig();\n		this.initPaths();\n		this.initRunnerUtils();\n	}\n	async run(args: string | { name: string; opts?: any }) {\n		// 省略若干代码\n		this.debugger("initPresetsAndPlugins");\n		this.initPresetsAndPlugins();\n		console.log(\'initPresetsAndPlugins\', this);\n\n		await this.applyPlugins("onReady");\n		// 省略若干代码\n	}\n	// initPresetsAndPlugins\n	initPresetsAndPlugins() {\n		// 初始化插件集和插件\n	}\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["执行完  ",(0,r.jsx)(n.code,{children:"initPresetsAndPlugins"})," 之后，这里以 ",(0,r.jsx)(n.code,{children:"init"})," 为例。\n使用 ",(0,r.jsx)(n.code,{children:"JavaScript 调试终端"}),"，输入 ",(0,r.jsx)(n.code,{children:"node ./packages/taro-cli/bin/taro init taro-init-debug"})," 调试。\n我们可以在 ",(0,r.jsx)(n.code,{children:"packages/taro-service/dist/Kernel.js"})," 打印 ",(0,r.jsx)(n.code,{children:"this"})," 出来。"]}),"\n",(0,r.jsx)(n.p,{children:"如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Kernal 实例对象",src:l})}),"\n",(0,r.jsxs)(n.p,{children:["本文我们主要是学习 ",(0,r.jsx)(n.code,{children:"initPresetsAndPlugins"})," 具体实现。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们继续来分析这个函数的具体实现，也就是说来看 ",(0,r.jsx)(n.code,{children:"Taro"})," 的插件机制是如何实现的。可以打开",(0,r.jsx)(n.a,{href:"https://docs.taro.zone/docs/plugin",rel:"noopener noreferrer",target:"_blank",children:"Taro文档 - 使用插件和编写插件"})," 配合看可能效果更佳。"]}),"\n",(0,r.jsxs)(n.p,{children:["本文讲述的函数源码位置是 ",(0,r.jsx)(n.code,{children:"packages/taro-service/src/Kernel.ts"}),"。\n基本包含在下图中。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"函数",src:c})}),"\n",(0,r.jsxs)(n.p,{children:["我们来看 CLI 调用 ",(0,r.jsx)(n.code,{children:"new Kernal"})," 的地方，源码所在位置 ",(0,r.jsx)(n.code,{children:"packages/taro-cli/src/cli.ts"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// packages/taro-cli/src/cli.ts\nconst kernel = new Kernel({\n	appPath,\n	presets: [path.resolve(__dirname, ".", "presets", "index.js")],\n	config,\n	plugins: [],\n});\nkernel.optsPlugins ||= [];\nconst commandsPath = path.resolve(presetsPath, \'commands\')\nconst commandPlugins = fs.readdirSync(commandsPath)\nconst targetPlugin = `${command}.js`\nif (commandPlugins.includes(targetPlugin)) {\n	// 针对不同的内置命令注册对应的命令插件\n	kernel.optsPlugins.push(path.resolve(commandsPath, targetPlugin))\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["本文以 ",(0,r.jsx)(n.code,{children:"init"})," 命令为例，那么 ",(0,r.jsx)(n.code,{children:"kernel.optsPlugins"})," 这里则注入的是 ",(0,r.jsx)(n.code,{children:"command/init.js"})," 插件。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// packages/taro-cli/src/presets/commands/init.ts\nimport type { IPluginContext } from '@tarojs/service'\n\nexport default (ctx: IPluginContext) => {\n  ctx.registerCommand({\n    name: 'init',\n    optionsMap: {\n    //   省略若干代码\n    },\n    async fn (opts) {\n    //   省略若干代码\n    }\n  })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["传入的参数 ",(0,r.jsx)(n.code,{children:"presets"})," 预设插件集合如下图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"presets",src:o})}),"\n",(0,r.jsxs)(n.p,{children:["其中 ",(0,r.jsx)(n.code,{children:"hooks/build.js"})," 如下图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"build 钩子",src:a})}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.a,{href:"https://docs.taro.zone/docs/plugin-custom#ctxregistermethodarg-string---name-string-fn-function--fn-function",rel:"noopener noreferrer",target:"_blank",children:"ctx.registerMethod"})," 注册方法。其中 ",(0,r.jsx)(n.code,{children:"ctx"})," 就是 ",(0,r.jsx)(n.code,{children:"Kernal"})," 实例对象。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"ctx.registerMethod",src:d})}),"\n",(0,r.jsxs)(n.p,{children:["源码实现如下，存入到 ",(0,r.jsx)(n.code,{children:"methods Map"})," 中。后面我们会再次遇到它。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"registerMethod",src:h})}),"\n",(0,r.jsxs)(n.h2,{id:"3-initpresetsandplugins-初始化预设插件集合和插件",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-initpresetsandplugins-初始化预设插件集合和插件",children:"#"}),"3. initPresetsAndPlugins 初始化预设插件集合和插件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'initPresetsAndPlugins() {\n  const initialConfig = this.initialConfig;\n  const initialGlobalConfig = this.initialGlobalConfig;\n  const cliAndProjectConfigPresets = mergePlugins(\n   this.optsPresets || [],\n   initialConfig.presets || []\n  )();\n  const cliAndProjectPlugins = mergePlugins(\n   this.optsPlugins || [],\n   initialConfig.plugins || []\n  )();\n  const globalPlugins = convertPluginsToObject(\n   initialGlobalConfig.plugins || []\n  )();\n  const globalPresets = convertPluginsToObject(\n   initialGlobalConfig.presets || []\n  )();\n  this.debugger(\n   "initPresetsAndPlugins",\n   cliAndProjectConfigPresets,\n   cliAndProjectPlugins\n  );\n  this.debugger("globalPresetsAndPlugins", globalPlugins, globalPresets);\n  process.env.NODE_ENV !== "test" &&\n   helper.createSwcRegister({\n    only: [\n     ...Object.keys(cliAndProjectConfigPresets),\n     ...Object.keys(cliAndProjectPlugins),\n     ...Object.keys(globalPresets),\n     ...Object.keys(globalPlugins),\n    ],\n   });\n  this.plugins = new Map();\n  this.extraPlugins = {};\n  this.globalExtraPlugins = {};\n  this.resolvePresets(cliAndProjectConfigPresets, globalPresets);\n  this.resolvePlugins(cliAndProjectPlugins, globalPlugins);\n }\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"mergePlugins 合并预设插件集合和插件"}),"\n",(0,r.jsx)(n.li,{children:"convertPluginsToObject 转换全局配置里的插件集和插件为对象"}),"\n",(0,r.jsxs)(n.li,{children:["非测试环境，",(0,r.jsx)(n.code,{children:"createSwcRegister"})," 使用了 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/@swc/register",rel:"noopener noreferrer",target:"_blank",children:"@swc/register"})," 来编译 ",(0,r.jsx)(n.code,{children:"ts"})," 等转换成 ",(0,r.jsx)(n.code,{children:"commonjs"}),"。可以直接用 ",(0,r.jsx)(n.code,{children:"require"})," 读取文件。"]}),"\n",(0,r.jsx)(n.li,{children:"resolvePresets 解析预设插件集合和 resolvePlugins 解析插件"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"31-工具函数-mergepluginsconvertpluginstoobject",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-工具函数-mergepluginsconvertpluginstoobject",children:"#"}),"3.1 工具函数 mergePlugins、convertPluginsToObject"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const isNpmPkg: (name: string) => boolean = (name) =>\n	!/^(\\.|\\/)/.test(name);\n\nexport function getPluginPath(pluginPath: string) {\n	if (isNpmPkg(pluginPath) || path.isAbsolute(pluginPath)) return pluginPath;\n	throw new Error("plugin 和 preset 配置必须为绝对路径或者包名");\n}\n\nexport function convertPluginsToObject(\n	items: PluginItem[]\n): () => IPluginsObject {\n	return () => {\n		const obj: IPluginsObject = {};\n		if (Array.isArray(items)) {\n			items.forEach((item) => {\n				if (typeof item === "string") {\n					const name = getPluginPath(item);\n					obj[name] = null;\n				} else if (Array.isArray(item)) {\n					const name = getPluginPath(item[0]);\n					obj[name] = item[1];\n				}\n			});\n		}\n		return obj;\n	};\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function mergePlugins(dist: PluginItem[], src: PluginItem[]) {\n	return () => {\n		const srcObj = convertPluginsToObject(src)();\n		const distObj = convertPluginsToObject(dist)();\n		return merge(distObj, srcObj);\n	};\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们来看解析插件集合 ",(0,r.jsx)(n.code,{children:"resolvePresets"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"4-resolvepresets-解析预设插件集合",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-resolvepresets-解析预设插件集合",children:"#"}),"4. resolvePresets 解析预设插件集合"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:" resolvePresets(\n  cliAndProjectPresets: IPluginsObject,\n  globalPresets: IPluginsObject\n ) {\n  const resolvedCliAndProjectPresets = resolvePresetsOrPlugins(\n   this.appPath,\n   cliAndProjectPresets,\n   PluginType.Preset\n  );\n  while (resolvedCliAndProjectPresets.length) {\n   this.initPreset(resolvedCliAndProjectPresets.shift()!);\n  }\n\n  const globalConfigRootPath = path.join(\n   helper.getUserHomeDir(),\n   helper.TARO_GLOBAL_CONFIG_DIR\n  );\n  const resolvedGlobalPresets = resolvePresetsOrPlugins(\n   globalConfigRootPath,\n   globalPresets,\n   PluginType.Plugin,\n   true\n  );\n  while (resolvedGlobalPresets.length) {\n   this.initPreset(resolvedGlobalPresets.shift()!, true);\n  }\n }\n"})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"resolvedCliAndProjectPresets 解析 cli 和项目配置的预设插件集合"}),"\n",(0,r.jsx)(n.li,{children:"resolvedGlobalPresets 解析全局的预设插件集合"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["其中主要有两个函数，我们分开讲述 ",(0,r.jsx)(n.code,{children:"resolvePresetsOrPlugins"})," ",(0,r.jsx)(n.code,{children:"initPreset"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["执行后 ",(0,r.jsx)(n.code,{children:"resolvePresetsOrPlugins"})," 函数得到的 ",(0,r.jsx)(n.code,{children:"resolvedCliAndProjectPresets"})," 如图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"得到的 resolvedCliAndProjectPresets",src:g})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"globalConfigRootPath"})," 路径是： ",(0,r.jsx)(n.code,{children:"/Users/用户名/.taro-global-config"})]}),"\n",(0,r.jsxs)(n.p,{children:["全局 ",(0,r.jsx)(n.code,{children:".taro-global-config/index.json"})," 我们默认是没有配置预设插件集合的。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"// .taro-global-config/index.json\n{\n	presets: [],\n	plugins: []\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们接着具体断点调试来看 ",(0,r.jsx)(n.code,{children:"resolvePresetsOrPlugins"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"41-resolvepresetsorplugins-解析插件集或者插件",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-resolvepresetsorplugins-解析插件集或者插件",children:"#"}),"4.1 resolvePresetsOrPlugins 解析插件集或者插件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// getModuleDefaultExport\nexport function resolvePresetsOrPlugins(\n	root: string,\n	args: IPluginsObject,\n	type: PluginType,\n	skipError?: boolean\n): IPlugin[] {\n	// 全局的插件引入报错，不抛出 Error 影响主流程，而是通过 log 提醒然后把插件 filter 掉，保证主流程不变\n	const resolvedPresetsOrPlugins: IPlugin[] = [];\n	const presetsOrPluginsNames = Object.keys(args) || [];\n	for (let i = 0; i < presetsOrPluginsNames.length; i++) {\n		const item = presetsOrPluginsNames[i];\n		let fPath;\n		try {\n			fPath = resolve.sync(item, {\n				basedir: root,\n				extensions: [".js", ".ts"],\n			});\n		} catch (err) {\n			if (args[item]?.backup) {\n				// 如果项目中没有，可以使用 CLI 中的插件\n				fPath = args[item]?.backup;\n			} else if (skipError) {\n				// 如果跳过报错，那么 log 提醒，并且不使用该插件\n				console.log(\n					chalk.yellow(\n						`找不到插件依赖 "${item}"，请先在项目中安装，项目路径：${root}`\n					)\n				);\n				continue;\n			} else {\n				console.log(\n					chalk.red(\n						`找不到插件依赖 "${item}"，请先在项目中安装，项目路径：${root}`\n					)\n				);\n				process.exit(1);\n			}\n		}\n		const resolvedItem = {\n			id: fPath,\n			path: fPath,\n			type,\n			opts: args[item] || {},\n			apply() {\n				try {\n					return getModuleDefaultExport(require(fPath));\n				} catch (error) {\n					console.error(error);\n					// 全局的插件运行报错，不抛出 Error 影响主流程，而是通过 log 提醒然后把插件 filter 掉，保证主流程不变\n					if (skipError) {\n						console.error(\n							`插件依赖 "${item}" 加载失败，请检查插件配置`\n						);\n					} else {\n						throw new Error(\n							`插件依赖 "${item}" 加载失败，请检查插件配置`\n						);\n					}\n				}\n			},\n		};\n		resolvedPresetsOrPlugins.push(resolvedItem);\n	}\n\n	return resolvedPresetsOrPlugins;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["代码看起来很长，但主要就是使用 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/resolve#resolvesyncid-opts",rel:"noopener noreferrer",target:"_blank",children:"resolve.sync"})," 获取路径。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const resolvedPresetsOrPlugins = [];\nconst resolvedItem = {\n	id: fPath,\n	path: fPath,\n	type,\n	opts: args[item] || {},\n	apply() {\n		// 插件内容 require()\n		try{\n			return getModuleDefaultExport(require(fPath));\n		} catch(e){\n			// 省略\n		}\n	}\n}\nresolvedPresetsOrPlugins.push(resolvedItem);\n"})}),"\n",(0,r.jsx)(n.p,{children:"组成这样的数组对象返回。"}),"\n",(0,r.jsxs)(n.p,{children:["我们接着来看 ",(0,r.jsx)(n.code,{children:"this.initPreset"})," 的具体实现。"]}),"\n",(0,r.jsxs)(n.h2,{id:"5-initpreset-初始化预设插件集合",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-initpreset-初始化预设插件集合",children:"#"}),"5. initPreset 初始化预设插件集合"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'initPreset(preset: IPreset, isGlobalConfigPreset?: boolean) {\n  this.debugger("initPreset", preset);\n  const { id, path, opts, apply } = preset;\n  const pluginCtx = this.initPluginCtx({ id, path, ctx: this });\n  const { presets, plugins } = apply()(pluginCtx, opts) || {};\n  this.registerPlugin(preset);\n  if (Array.isArray(presets)) {\n   const _presets = resolvePresetsOrPlugins(\n    this.appPath,\n    convertPluginsToObject(presets)(),\n    PluginType.Preset,\n    isGlobalConfigPreset\n   );\n   while (_presets.length) {\n    this.initPreset(_presets.shift()!, isGlobalConfigPreset);\n   }\n  }\n  if (Array.isArray(plugins)) {\n   isGlobalConfigPreset\n    ? (this.globalExtraPlugins = merge(\n      this.globalExtraPlugins,\n      convertPluginsToObject(plugins)()\n      ))\n    : (this.extraPlugins = merge(\n      this.extraPlugins,\n      convertPluginsToObject(plugins)()\n      ));\n  }\n }\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"initPluginCtx 初始化插件 ctx"}),"\n",(0,r.jsx)(n.li,{children:"执行插件，获得预设插件集合和插件。"}),"\n",(0,r.jsx)(n.li,{children:"注册插件"}),"\n",(0,r.jsx)(n.li,{children:"如果预设插件集合是数组继续递归调用。"}),"\n",(0,r.jsxs)(n.li,{children:["如果插件是数组，是全局插件就合并到全局额外的插件 ",(0,r.jsx)(n.code,{children:"globalExtraPlugins"})," 中，否则就合并到额外的插件 ",(0,r.jsx)(n.code,{children:"extraPlugins"})," 中。后面统一处理插件。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["我们分别来看 ",(0,r.jsx)(n.code,{children:"initPluginCtx"}),"、",(0,r.jsx)(n.code,{children:"registerPlugin"})," 的实现。"]}),"\n",(0,r.jsxs)(n.h2,{id:"6-initpluginctx-初始化插件-ctx",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-initpluginctx-初始化插件-ctx",children:"#"}),"6. initPluginCtx 初始化插件 ctx"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:' initPluginCtx({\n  id,\n  path,\n  ctx,\n }: {\n  id: string;\n  path: string;\n  ctx: Kernel;\n }) {\n  const pluginCtx = new Plugin({ id, path, ctx });\n  const internalMethods = ["onReady", "onStart"];\n  const kernelApis = [\n   "appPath",\n   "plugins",\n   "platforms",\n   "paths",\n   "helper",\n   "runOpts",\n   "runnerUtils",\n   "initialConfig",\n   "applyPlugins",\n   "applyCliCommandPlugin",\n  ];\n  internalMethods.forEach((name) => {\n   if (!this.methods.has(name)) {\n    pluginCtx.registerMethod(name);\n   }\n  });\n  return new Proxy(pluginCtx, {\n   get: (target, name: string) => {\n    if (this.methods.has(name)) {\n     const method = this.methods.get(name);\n     if (Array.isArray(method)) {\n      return (...arg) => {\n       method.forEach((item) => {\n        item.apply(this, arg);\n       });\n      };\n     }\n     return method;\n    }\n    if (kernelApis.includes(name)) {\n     return typeof this[name] === "function"\n      ? this[name].bind(this)\n      : this[name];\n    }\n    return target[name];\n   },\n  });\n }\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"new Plugin 生成插件的 pluginCtx"}),"\n",(0,r.jsxs)(n.li,{children:["internalMethods 内部方法 注册到 ",(0,r.jsx)(n.code,{children:"ctx.onReady"})," ",(0,r.jsx)(n.code,{children:"ctx.onStart"})]}),"\n",(0,r.jsx)(n.li,{children:"this.methods 数组绑定  this 指向到 Kernal 实例对象上"}),"\n",(0,r.jsx)(n.li,{children:"kernelApis 的方法，代理绑定下 this 指向到 Kernal 实例对象上。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"methods",src:p}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["因为 ",(0,r.jsx)(n.code,{children:"new Proxy"})," 代理后，可以直接使用 ",(0,r.jsx)(n.code,{children:"ctx.methodName"})," 直接调用相应方法。"]}),"\n",(0,r.jsx)(n.p,{children:"我们接着来看，class Plugin 的具体实现。"}),"\n",(0,r.jsxs)(n.h3,{id:"61-new-plugin-id-path-ctx-",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-new-plugin-id-path-ctx-",children:"#"}),"6.1 new Plugin({ id, path, ctx })"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { addPlatforms } from "@tarojs/helper";\n\nimport type { Func } from "@tarojs/taro/types/compile";\nimport type Kernel from "./Kernel";\nimport type { ICommand, IHook, IPlatform } from "./utils/types";\n\nexport default class Plugin {\n	id: string;\n	path: string;\n	ctx: Kernel;\n	optsSchema: Func;\n\n	constructor(opts) {\n		this.id = opts.id;\n		this.path = opts.path;\n		this.ctx = opts.ctx;\n	}\n	//  拆分到下部分\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"611-register-注册-hook",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#611-register-注册-hook",children:"#"}),"6.1.1 register 注册 hook"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"register (hook: IHook) {\n	if (typeof hook.name !== 'string') {\n		throw new Error(`插件 ${this.id} 中注册 hook 失败， hook.name 必须是 string 类型`)\n	}\n	if (typeof hook.fn !== 'function') {\n		throw new Error(`插件 ${this.id} 中注册 hook 失败， hook.fn 必须是 function 类型`)\n	}\n	const hooks = this.ctx.hooks.get(hook.name) || []\n	hook.plugin = this.id\n	this.ctx.hooks.set(hook.name, hooks.concat(hook))\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["判断下 ",(0,r.jsx)(n.code,{children:"name"})," 和 ",(0,r.jsx)(n.code,{children:"fn"}),"，最后存入 ",(0,r.jsx)(n.code,{children:"hooks"})," 的值。可以通过 ",(0,r.jsx)(n.code,{children:"this.applyPlugins()触发插件"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178#heading-19",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章 kernal.applyPlugins 触发插件"}),"，有提到，此处就不在赘述。"]}),"\n",(0,r.jsxs)(n.h4,{id:"612-registercommand-注册方法",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#612-registercommand-注册方法",children:"#"}),"6.1.2 registerCommand 注册方法"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"registerCommand (command: ICommand) {\n	if (this.ctx.commands.has(command.name)) {\n		throw new Error(`命令 ${command.name} 已存在`)\n	}\n	this.ctx.commands.set(command.name, command)\n	this.register(command)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["存入到 ",(0,r.jsx)(n.code,{children:"commands Map"})," 中。而且再通过 ",(0,r.jsx)(n.code,{children:"this.register(command)"})," 存入到 hooks 中。便于在 ",(0,r.jsx)(n.code,{children:"this.applyPlugins()"})," 使用。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"command"})," 和 ",(0,r.jsx)(n.code,{children:"hooks"})," 如下图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"command-hooks",src:u})}),"\n",(0,r.jsxs)(n.h4,{id:"613-registerplatform-注册平台",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#613-registerplatform-注册平台",children:"#"}),"6.1.3 registerPlatform 注册平台"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  registerPlatform (platform: IPlatform) {\n    if (this.ctx.platforms.has(platform.name)) {\n      throw new Error(`适配平台 ${platform.name} 已存在`)\n    }\n    addPlatforms(platform.name)\n    this.ctx.platforms.set(platform.name, platform)\n    this.register(platform)\n  }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["同样存入到 ",(0,r.jsx)(n.code,{children:"platforms"})," 中。同时存入到 ",(0,r.jsx)(n.code,{children:"hooks"})," 中。"]}),"\n",(0,r.jsxs)(n.h4,{id:"614-registermethod-注册方法",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#614-registermethod-注册方法",children:"#"}),"6.1.4 registerMethod 注册方法"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"registerMethod (...args) {\n	const { name, fn } = processArgs(args)\n	const methods = this.ctx.methods.get(name) || []\n	methods.push(fn || function (fn: Func) {\n		this.register({\n			name,\n			fn\n		})\n	}.bind(this))\n	this.ctx.methods.set(name, methods)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"前文提到。没有函数，则会存入到 hooks 中。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'function processArgs(args) {\n	let name, fn;\n	if (!args.length) {\n		throw new Error("参数为空");\n	} else if (args.length === 1) {\n		if (typeof args[0] === "string") {\n			name = args[0];\n		} else {\n			name = args[0].name;\n			fn = args[0].fn;\n		}\n	} else {\n		name = args[0];\n		fn = args[1];\n	}\n	return { name, fn };\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"processArgs"})," 函数主要就是统一下不同传参形式，最终都是返回 ",(0,r.jsx)(n.code,{children:"name"})," 和 ",(0,r.jsx)(n.code,{children:"fn"}),"。"]}),"\n",(0,r.jsxs)(n.h4,{id:"615-addpluginoptsschema-添加插件的参数-schema",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#615-addpluginoptsschema-添加插件的参数-schema",children:"#"}),"6.1.5 addPluginOptsSchema 添加插件的参数 Schema"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"addPluginOptsSchema (schema) {\n	this.optsSchema = schema\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们接着来看，注册插件函数。"}),"\n",(0,r.jsxs)(n.h2,{id:"7-registerplugin-注册插件",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-registerplugin-注册插件",children:"#"}),"7. registerPlugin 注册插件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:' registerPlugin(plugin: IPlugin) {\n  this.debugger("registerPlugin", plugin);\n  if (this.plugins.has(plugin.id)) {\n   throw new Error(`插件 ${plugin.id} 已被注册`);\n  }\n  this.plugins.set(plugin.id, plugin);\n }\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["注册插件到 ",(0,r.jsx)(n.code,{children:"plugins Map"})," 中。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["最终的插件 ",(0,r.jsx)(n.code,{children:"plugins"})," 如图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"plugins",src:x})}),"\n",(0,r.jsxs)(n.h2,{id:"8-resolveplugins-解析插件",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-resolveplugins-解析插件",children:"#"}),"8. resolvePlugins 解析插件"]}),"\n",(0,r.jsx)(n.p,{children:"解析插件和解析预设插件集合类似。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"resolvePlugins(\n  cliAndProjectPlugins: IPluginsObject,\n  globalPlugins: IPluginsObject\n ) {\n  cliAndProjectPlugins = merge(this.extraPlugins, cliAndProjectPlugins);\n  const resolvedCliAndProjectPlugins = resolvePresetsOrPlugins(\n   this.appPath,\n   cliAndProjectPlugins,\n   PluginType.Plugin\n  );\n\n  globalPlugins = merge(this.globalExtraPlugins, globalPlugins);\n  const globalConfigRootPath = path.join(\n   helper.getUserHomeDir(),\n   helper.TARO_GLOBAL_CONFIG_DIR\n  );\n  const resolvedGlobalPlugins = resolvePresetsOrPlugins(\n   globalConfigRootPath,\n   globalPlugins,\n   PluginType.Plugin,\n   true\n  );\n\n  const resolvedPlugins = resolvedCliAndProjectPlugins.concat(\n   resolvedGlobalPlugins\n  );\n\n  while (resolvedPlugins.length) {\n   this.initPlugin(resolvedPlugins.shift()!);\n  }\n\n  this.extraPlugins = {};\n  this.globalExtraPlugins = {};\n }\n"})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"合并预设插件集合中的插件、CLI 和项目中配置的插件"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"resolvedCliAndProjectPlugins"})," CLI 和项目中配置的插件"]}),"\n",(0,r.jsx)(n.li,{children:"合并全局预设插件集合中的插件、全局配置的插件"}),"\n",(0,r.jsxs)(n.li,{children:["最后遍历所有解析后的插件一次调用 ",(0,r.jsx)(n.code,{children:"this.initPlugin"})," 初始化插件"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"9-initplugin-初始化插件",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-initplugin-初始化插件",children:"#"}),"9. initPlugin 初始化插件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'initPlugin(plugin: IPlugin) {\n  const { id, path, opts, apply } = plugin;\n  const pluginCtx = this.initPluginCtx({ id, path, ctx: this });\n  this.debugger("initPlugin", plugin);\n  this.registerPlugin(plugin);\n  apply()(pluginCtx, opts);\n  this.checkPluginOpts(pluginCtx, opts);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"initPluginCtx 初始化插件的 ctx"}),"\n",(0,r.jsx)(n.li,{children:"注册插件"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apply"})," 执行插件，插件本身也是一个函数，传入插件 ",(0,r.jsx)(n.code,{children:"pluginCtx"})," 对象（包含 ",(0,r.jsx)(n.code,{children:"register"}),"、",(0,r.jsx)(n.code,{children:"registerCommand"}),"、",(0,r.jsx)(n.code,{children:"registerMethods"})," 等方法的对象），作为 ",(0,r.jsx)(n.code,{children:"ctx"}),"，传入参数 ",(0,r.jsx)(n.code,{children:"opts"})]}),"\n",(0,r.jsx)(n.li,{children:"校验插件的参数是否符合要求"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"10-checkpluginopts-校验插件的参数",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-checkpluginopts-校验插件的参数",children:"#"}),"10. checkPluginOpts 校验插件的参数"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:' checkPluginOpts(pluginCtx, opts) {\n  if (typeof pluginCtx.optsSchema !== "function") {\n   return;\n  }\n  this.debugger("checkPluginOpts", pluginCtx);\n  const joi = require("joi");\n  const schema = pluginCtx.optsSchema(joi);\n  if (!joi.isSchema(schema)) {\n   throw new Error(\n    `插件${pluginCtx.id}中设置参数检查 schema 有误，请检查！`\n   );\n  }\n  const { error } = schema.validate(opts);\n  if (error) {\n   error.message = `插件${pluginCtx.id}获得的参数不符合要求，请检查！`;\n   throw error;\n  }\n }\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个方法主要做了如下几件事："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/joi",rel:"noopener noreferrer",target:"_blank",children:"joi"})," 最强大的 JavaScript 模式描述语言和数据验证器。校验插件参数 ",(0,r.jsx)(n.code,{children:"schema"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["搜索整个项目中，好像只有 ",(0,r.jsx)(n.code,{children:"plugin-mini-ci"})," 插件中加了这个参数校验。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 参数验证，支持传入配置对象、返回配置对象的异步函数\nctx.addPluginOptsSchema((joi) => {\n	return joi.alternatives().try(\n		joi.function().required(),\n		joi\n		.object()\n		.keys({\n			/** 微信小程序上传配置 */\n			weapp: joi.object({\n				appid: joi.string().required(),\n				privateKeyPath: joi.string().required(),\n				type: joi.string().valid('miniProgram', 'miniProgramPlugin', 'miniGame', 'miniGamePlugin'),\n				ignores: joi.array().items(joi.string().required()),\n				robot: joi.number(),\n				setting: joi.object()\n			}),\n			// 省略了一些其他平台的代码...\n			version: joi.string(),\n			desc: joi.string(),\n			projectPath: joi.string()\n		})\n		.required()\n	)\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"Kernal 实例对象中还有一个方法，顺便提一下。"}),"\n",(0,r.jsxs)(n.h2,{id:"11-applyclicommandplugin-暴露-taro-cli-内部命令插件",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-applyclicommandplugin-暴露-taro-cli-内部命令插件",children:"#"}),"11. applyCliCommandPlugin 暴露 taro cli 内部命令插件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"applyCliCommandPlugin(commandNames: string[] = []) {\n	const existsCliCommand: string[] = [];\n	for (let i = 0; i < commandNames.length; i++) {\n		const commandName = commandNames[i];\n		const commandFilePath = path.resolve(\n			this.cliCommandsPath,\n			`${commandName}.js`\n		);\n		if (this.cliCommands.includes(commandName))\n			existsCliCommand.push(commandFilePath);\n	}\n	const commandPlugins = convertPluginsToObject(existsCliCommand || [])();\n	helper.createSwcRegister({ only: [...Object.keys(commandPlugins)] });\n	const resolvedCommandPlugins = resolvePresetsOrPlugins(\n		this.appPath,\n		commandPlugins,\n		PluginType.Plugin\n	);\n	while (resolvedCommandPlugins.length) {\n		this.initPlugin(resolvedCommandPlugins.shift()!);\n	}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"applyCliCommandPlugin",src:j})}),"\n",(0,r.jsxs)(n.h2,{id:"12-总结",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-总结",children:"#"}),"12. 总结"]}),"\n",(0,r.jsx)(n.p,{children:"我们学了"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"1. 如何合并预设插件集合和插件（CLI、用户项目（config/index.ts）、全局插件`/Users/用户名/.taro-global-config`）\n2. 插件是如何注册的\n3. 插件如何调用的\n等等\n"})}),"\n",(0,r.jsxs)(n.p,{children:["以 ",(0,r.jsx)(n.code,{children:"command/init.ts"})," 插件为例。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// packages/taro-cli/src/presets/commands/init.ts\nimport type { IPluginContext } from '@tarojs/service'\n\nexport default (ctx: IPluginContext) => {\n  ctx.registerCommand({\n    name: 'init',\n    optionsMap: {\n    //   省略若干代码\n    },\n    async fn (opts) {\n    //   省略若干代码\n    }\n  })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["非测试环境，先通过 ",(0,r.jsx)(n.code,{children:"createSwcRegister"})," 使用了 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/@swc/register",rel:"noopener noreferrer",target:"_blank",children:"@swc/register"})," 来编译 ",(0,r.jsx)(n.code,{children:"ts"})," 等转换成 ",(0,r.jsx)(n.code,{children:"commonjs"}),"。可以直接用 ",(0,r.jsx)(n.code,{children:"require"})," 读取文件。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const resolvedPresetsOrPlugins = [];\nconst resolvedItem = {\n	id: fPath,\n	path: fPath,\n	type,\n	opts: args[item] || {},\n	apply() {\n		// 插件内容 require()\n		try{\n			return getModuleDefaultExport(require(fPath));\n		} catch(e){\n			// 省略\n		}\n	}\n}\nresolvedPresetsOrPlugins.push(resolvedItem);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["最终的插件 ",(0,r.jsx)(n.code,{children:"plugins"})," 如图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"plugins",src:x})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'initPlugin(plugin: IPlugin) {\n  const { id, path, opts, apply } = plugin;\n  const pluginCtx = this.initPluginCtx({ id, path, ctx: this });\n  this.debugger("initPlugin", plugin);\n  this.registerPlugin(plugin);\n  apply()(pluginCtx, opts);\n  this.checkPluginOpts(pluginCtx, opts);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["再 ",(0,r.jsx)(n.code,{children:"apply"})," 执行插件，插件本身也是一个函数，传入插件 ",(0,r.jsx)(n.code,{children:"pluginCtx"})," 对象（包含 ",(0,r.jsx)(n.code,{children:"register"}),"、",(0,r.jsx)(n.code,{children:"registerCommand"}),"、",(0,r.jsx)(n.code,{children:"registerMethods"})," 等方法的对象），作为 ",(0,r.jsx)(n.code,{children:"ctx"}),"，传入参数 ",(0,r.jsx)(n.code,{children:"opts"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["而这三个方法最终都是会调用 Plugin 实例对象的 register 方法，把方法存入到 Kernal 实例对象中的 ",(0,r.jsx)(n.code,{children:"hooks"})," 属性中。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"register(){\n	// 省略若干判断代码\n	const hooks = this.ctx.hooks.get(hook.name) || []\n	hook.plugin = this.id\n	this.ctx.hooks.set(hook.name, hooks.concat(hook))\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后再通过 ",(0,r.jsx)(n.code,{children:"Kernal"})," 实例对象中的 ",(0,r.jsx)(n.code,{children:"run"})," 函数里的 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178#heading-19",rel:"noopener noreferrer",target:"_blank",children:"applyPlugins 链接里有函数具体实现"})," 方法。"]}),"\n",(0,r.jsxs)(n.p,{children:["从 ",(0,r.jsx)(n.code,{children:"Kernal"})," 的实例对象中，取出相应的 ",(0,r.jsx)(n.code,{children:"hooks"}),"，使用 ",(0,r.jsx)(n.a,{href:"https://github.com/webpack/tapable",rel:"noopener noreferrer",target:"_blank",children:"tapable"})," 的 ",(0,r.jsx)(n.code,{children:"AsyncSeriesWaterfallHook"})," 钩子串联起来，依次执行 ",(0,r.jsx)(n.code,{children:"hook.fn"})," 方法。"]}),"\n",(0,r.jsxs)(n.p,{children:["调试如图所示：\n",(0,r.jsx)(n.img,{alt:"applyPlugins",src:m})]}),"\n",(0,r.jsxs)(n.p,{children:["从而达到调用的是 ",(0,r.jsx)(n.code,{children:"command/init.ts"})," 中的 ",(0,r.jsx)(n.code,{children:"fn"})," 函数。",(0,r.jsx)(n.strong,{children:"不得不惊叹一声：Taro 插件机制设计的妙啊"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"强烈建议读者朋友们，空闲时自己看着文章，多尝试调试源码。单看文章，可能觉得看懂了，但自己调试可能会发现更多细节，收获更多。"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["作者：常以",(0,r.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,r.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,r.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,r.jsx)(n.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后可以持续关注我",(0,r.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,r.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,r.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,r.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,r.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（5.8k+人）第一的专栏，写有几十篇源码文章。"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(P,e)})):P(e)}let b=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["taro%2Fcli-plugins%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-new-kernal-构造函数",text:"2. new Kernal 构造函数",depth:2},{id:"3-initpresetsandplugins-初始化预设插件集合和插件",text:"3. initPresetsAndPlugins 初始化预设插件集合和插件",depth:2},{id:"31-工具函数-mergepluginsconvertpluginstoobject",text:"3.1 工具函数 mergePlugins、convertPluginsToObject",depth:3},{id:"4-resolvepresets-解析预设插件集合",text:"4. resolvePresets 解析预设插件集合",depth:2},{id:"41-resolvepresetsorplugins-解析插件集或者插件",text:"4.1 resolvePresetsOrPlugins 解析插件集或者插件",depth:3},{id:"5-initpreset-初始化预设插件集合",text:"5. initPreset 初始化预设插件集合",depth:2},{id:"6-initpluginctx-初始化插件-ctx",text:"6. initPluginCtx 初始化插件 ctx",depth:2},{id:"61-new-plugin-id-path-ctx-",text:"6.1 new Plugin({ id, path, ctx })",depth:3},{id:"611-register-注册-hook",text:"6.1.1 register 注册 hook",depth:4},{id:"612-registercommand-注册方法",text:"6.1.2 registerCommand 注册方法",depth:4},{id:"613-registerplatform-注册平台",text:"6.1.3 registerPlatform 注册平台",depth:4},{id:"614-registermethod-注册方法",text:"6.1.4 registerMethod 注册方法",depth:4},{id:"615-addpluginoptsschema-添加插件的参数-schema",text:"6.1.5 addPluginOptsSchema 添加插件的参数 Schema",depth:4},{id:"7-registerplugin-注册插件",text:"7. registerPlugin 注册插件",depth:2},{id:"8-resolveplugins-解析插件",text:"8. resolvePlugins 解析插件",depth:2},{id:"9-initplugin-初始化插件",text:"9. initPlugin 初始化插件",depth:2},{id:"10-checkpluginopts-校验插件的参数",text:"10. checkPluginOpts 校验插件的参数",depth:2},{id:"11-applyclicommandplugin-暴露-taro-cli-内部命令插件",text:"11. applyCliCommandPlugin 暴露 taro cli 内部命令插件",depth:2},{id:"12-总结",text:"12. 总结",depth:2}],title:"Taro 源码揭秘：2. 揭开整个架构的插件系统的秘密",headingTitle:"Taro 源码揭秘：2. 揭开整个架构的插件系统的秘密",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(e,n,s){s.d(n,{Z:()=>o});var r=s(52676),i=s(75271),t=s(92815);s(18544);let l={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function c(e,n,s){let r=Object.keys(l).includes(n)?n:s;return l[r](e)}let o=e=>{let{defaultLocale:n="en-US"}=e,s=(0,t.Vi)().page.readingTimeData,l=(0,t.Jr)(),o=(0,t.e7)(),[a,d]=(0,i.useState)(c(s,l,n));return(0,i.useEffect)(()=>{d(c(s,l,n))},[l,s]),(0,r.jsx)("span",{"data-dark":String(o),className:"rp-reading-time",children:a})}}}]);