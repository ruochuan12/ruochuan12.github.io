"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["8985"],{67271:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var s=r(52676),c=r(40453),o=r(20713);let i=r.p+"static/image/axios-instance.edfbbf71.png",a=r.p+"static/image/request-promise-chain.60e34aba.png",t=r.p+"static/image/axios-promise-chain.52800534.png",d=r.p+"static/image/umi-request-image.7e546aa7.png",l=r.p+"static/image/axios-all.77e188f9.png";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",blockquote:"blockquote",p:"p",code:"code",strong:"strong",h3:"h3",pre:"pre",img:"img",ol:"ol",li:"li",h4:"h4"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"学习-axios-源码整体架构打造属于自己的请求库",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#学习-axios-源码整体架构打造属于自己的请求库",children:"#"}),"学习 axios 源码整体架构，打造属于自己的请求库"]}),"\n",(0,s.jsx)(o.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这是",(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"第六篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章学习的是实际仓库的代码。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/axios-analysis.git",rel:"noopener noreferrer",target:"_blank",children:"本文仓库地址"}),"：",(0,s.jsx)(n.code,{children:"git clone https://github.com/ruochuan12/axios-analysis.git"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"学习源码整体架构系列"}),"文章如下："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d39d2cbf265da1bc23fbd42",rel:"noopener noreferrer",target:"_blank",children:"学习 jQuery 源码整体架构，打造属于自己的 js 类库"}),"\n2.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d4bf94de51d453bb13b65dc",rel:"noopener noreferrer",target:"_blank",children:"学习 underscore 源码整体架构，打造属于自己的函数式编程类库"}),"\n3.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d767e1d6fb9a06b032025ea",rel:"noopener noreferrer",target:"_blank",children:"学习 lodash 源码整体架构，打造属于自己的函数式编程类库"}),"\n4.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dba5a39e51d452a2378348a",rel:"noopener noreferrer",target:"_blank",children:"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK"}),"\n5.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5dd4e61a6fb9a05a5c010af0",rel:"noopener noreferrer",target:"_blank",children:"学习 vuex 源码整体架构，打造属于自己的状态管理库"}),"\n6.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5df349b5518825123751ba66",rel:"noopener noreferrer",target:"_blank",children:"学习 axios 源码整体架构，打造属于自己的请求库"}),"\n7.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5e69925cf265da571e262fe6",rel:"noopener noreferrer",target:"_blank",children:"学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理"}),"\n8.",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5ee63b7d51882542fc6265ad",rel:"noopener noreferrer",target:"_blank",children:"学习 redux 源码整体架构，深入理解 redux 及其中间件原理"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["感兴趣的读者可以点击阅读。","\n其他源码计划中的有：",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/express-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"express"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/vue-router-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-rotuer"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/react-redux-analysis",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"react-redux"})})," 等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。"]}),"\n",(0,s.jsxs)(n.p,{children:["源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。","\n所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。"]}),"\n",(0,s.jsx)(n.p,{children:"本文比较长，手机上阅读，可以划到有图的地方直接看文中的几张图即可。建议点赞或收藏后在电脑上阅读，按照文中调试方式自己调试或许更容易吸收消化。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"导读"}),"\n文章详细介绍了 ",(0,s.jsx)(n.code,{children:"axios"})," 调试方法。详细介绍了 ",(0,s.jsx)(n.code,{children:"axios"})," 构造函数，拦截器，取消等功能的实现。最后还对比了其他请求库。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文学习的版本是",(0,s.jsx)(n.code,{children:"v0.19.0"}),"。克隆的官方仓库的",(0,s.jsx)(n.code,{children:"master"}),"分支。\n截至目前（2019年12月14日），最新一次",(0,s.jsx)(n.code,{children:"commit"}),"是",(0,s.jsx)(n.code,{children:"2019-12-09 15:52 ZhaoXC"})," ",(0,s.jsx)(n.code,{children:"dc4bc49673943e352"}),"，",(0,s.jsx)(n.code,{children:"fix: fix ignore set withCredentials false (#2582)"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["本文仓库在这里",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/axios-analysis",rel:"noopener noreferrer",target:"_blank",children:"若川的 axios-analysis github 仓库"}),"。求个",(0,s.jsx)(n.code,{children:"star"}),"呀。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果你是求职者，项目写了运用了",(0,s.jsx)(n.code,{children:"axios"}),"，面试官可能会问你："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.为什么 ",(0,s.jsx)(n.code,{children:"axios"})," 既可以当函数调用，也可以当对象使用，比如",(0,s.jsx)(n.code,{children:"axios({})"}),"、",(0,s.jsx)(n.code,{children:"axios.get"}),"。","\n2.简述 ",(0,s.jsx)(n.code,{children:"axios"})," 调用流程。","\n3.有用过拦截器吗？原理是怎样的？","\n4.有使用",(0,s.jsx)(n.code,{children:"axios"}),"的取消功能吗？是怎么实现的？","\n5.为什么支持浏览器中发送请求也支持",(0,s.jsx)(n.code,{children:"node"}),"发送请求？","\n诸如这类问题。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-chrome-和-vscode-调试-axios-源码方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-chrome-和-vscode-调试-axios-源码方法",children:"#"}),"2. chrome 和 vscode 调试 axios 源码方法"]}),"\n",(0,s.jsxs)(n.p,{children:["前不久，笔者在知乎回答了一个问题",(0,s.jsx)(n.a,{href:"https://www.zhihu.com/question/350289336/answer/910970733",rel:"noopener noreferrer",target:"_blank",children:"一年内的前端看不懂前端框架源码怎么办？"}),"\n推荐了一些资料，阅读量还不错，大家有兴趣可以看看。主要有四点："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.借助调试","\n2.搜索查阅相关高赞文章","\n3.把不懂的地方记录下来，查阅相关文档","\n4.总结"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["看源码，调试很重要，所以笔者详细写下 ",(0,s.jsx)(n.code,{children:"axios"})," 源码调试方法，帮助一些可能不知道如何调试的读者。"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-chrome-调试浏览器环境的-axios",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-chrome-调试浏览器环境的-axios",children:"#"}),"2.1 chrome 调试浏览器环境的 axios"]}),"\n",(0,s.jsx)(n.p,{children:"调试方法"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios"}),"打包后有",(0,s.jsx)(n.code,{children:"sourcemap"}),"文件。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 可以克隆笔者的这个仓库代码\ngit clone https://github.com/ruochuan12/axios-analysis.git\ncd axios-analaysis/axios\nnpm install\nnpm start\n# open [http://localhost:3000](http://localhost:3000)\n# chrome F12 source 控制面板  webpack//   .  lib 目录下，根据情况自行断点调试\n"})}),"\n",(0,s.jsxs)(n.p,{children:["本文就是通过上述的例子",(0,s.jsx)(n.code,{children:"axios/sandbox/client.html"}),"来调试的。"]}),"\n",(0,s.jsxs)(n.p,{children:["顺便简单提下调试",(0,s.jsx)(n.code,{children:"example"}),"的例子，虽然文章最开始时写了这部分，后来又删了，最后想想还是写下。"]}),"\n",(0,s.jsxs)(n.p,{children:["找到文件",(0,s.jsx)(n.code,{children:"axios/examples/server.js"}),"，修改代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"server = http.createServer(function (req, res) {\n  var url = req.url;\n  // 调试 examples\n  console.log(url);\n  // Process axios itself\n  if (/axios\\.min\\.js$/.test(url)) {\n    // 原来的代码 是 axios.min.js\n    // pipeFileToResponse(res, '../dist/axios.min.js', 'text/javascript');\n    pipeFileToResponse(res, '../dist/axios.js', 'text/javascript');\n    return;\n  }\n  // 原来的代码 是 axios.min.map\n  // if (/axios\\.min.map$/.test(url)) {\n  if (/axios\\.map$/.test(url)) {\n    // 原来的代码 是 axios.min.map\n    // pipeFileToResponse(res, '../dist/axios.min.map', 'text/javascript');\n    pipeFileToResponse(res, '../dist/axios.map', 'text/javascript');\n    return;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 上述安装好依赖后\n# npm run examples 不能同时开启，默认都是3000端口\n# 可以指定端口 5000\n# npm run examples ===  node ./examples/server.js\nnode ./examples/server.js -p 5000\n"})}),"\n",(0,s.jsxs)(n.p,{children:["打开",(0,s.jsx)(n.a,{href:"http://localhost:5000",rel:"noopener noreferrer",target:"_blank",children:"http://localhost:5000"}),"，然后就可以开心的在",(0,s.jsx)(n.code,{children:"Chrome"}),"浏览器中调试",(0,s.jsx)(n.code,{children:"examples"}),"里的例子了。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios"})," 是支持 ",(0,s.jsx)(n.code,{children:"node"})," 环境发送请求的。接下来看如何用 ",(0,s.jsx)(n.code,{children:"vscode"})," 调试 ",(0,s.jsx)(n.code,{children:"node"})," 环境下的",(0,s.jsx)(n.code,{children:"axios"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"22-vscode-调试-node-环境的-axios",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-vscode-调试-node-环境的-axios",children:"#"}),"2.2 vscode 调试 node 环境的 axios"]}),"\n",(0,s.jsxs)(n.p,{children:["在根目录下 ",(0,s.jsx)(n.code,{children:"axios-analysis/"}),"\n创建",(0,s.jsx)(n.code,{children:".vscode/launch.json"}),"文件如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    // 使用 IntelliSense 了解相关属性。\n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "node",\n            "request": "launch",\n            "name": "Launch Program",\n            "program": "${workspaceFolder}/axios/sandbox/client.js",\n            "skipFiles": [\n                "<node_internals>/**"\n            ]\n        },\n    ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["按",(0,s.jsx)(n.code,{children:"F5"}),"开始调试即可，按照自己的情况，单步跳过",(0,s.jsx)(n.code,{children:"（F10）"}),"、单步调试",(0,s.jsx)(n.code,{children:"（F11）"}),"断点调试。"]}),"\n",(0,s.jsxs)(n.p,{children:["其实开源项目一般都有贡献指南",(0,s.jsx)(n.code,{children:"axios/CONTRIBUTING.md"}),"，笔者只是把这个指南的基础上修改为引用",(0,s.jsx)(n.code,{children:"sourcemap"}),"的文件可调试。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-先看-axios-结构是怎样的",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-先看-axios-结构是怎样的",children:"#"}),"3. 先看 axios 结构是怎样的"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/ruochuan12/axios-analysis.git\ncd axios-analaysis/axios\nnpm install\nnpm start\n"})}),"\n",(0,s.jsxs)(n.p,{children:["按照上文说的调试方法， ",(0,s.jsx)(n.code,{children:"npm start"})," 后，直接在 ",(0,s.jsx)(n.code,{children:"chrome"})," 浏览器中调试。\n打开 ",(0,s.jsx)(n.a,{href:"http://localhost:3000",rel:"noopener noreferrer",target:"_blank",children:"http://localhost:3000"}),"，在控制台打印出",(0,s.jsx)(n.code,{children:"axios"}),"，估计很多人都没打印出来看过。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"console.log({axios: axios});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["层层点开来看，",(0,s.jsx)(n.code,{children:"axios"})," 的结构是怎样的，先有一个大概印象。"]}),"\n",(0,s.jsx)(n.p,{children:"笔者画了一张比较详细的图表示。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"axios 结构关系图",src:i})}),"\n",(0,s.jsxs)(n.p,{children:["看完结构图，如果看过",(0,s.jsx)(n.code,{children:"jQuery"}),"、",(0,s.jsx)(n.code,{children:"underscore"}),"和",(0,s.jsx)(n.code,{children:"lodash"}),"源码，会发现其实跟",(0,s.jsx)(n.code,{children:"axios"}),"源码设计类似。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"jQuery"})," 别名 ",(0,s.jsx)(n.code,{children:"$"}),"，",(0,s.jsx)(n.code,{children:"underscore"})," ",(0,s.jsx)(n.code,{children:"loadsh"})," 别名 ",(0,s.jsx)(n.code,{children:"_"})," 也既是函数，也是对象。比如",(0,s.jsx)(n.code,{children:"jQuery"}),"使用方式。",(0,s.jsx)(n.code,{children:"$('#id')"}),", ",(0,s.jsx)(n.code,{children:"$.ajax"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来看具体源码的实现。可以跟着断点调试一下。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"断点调试要领："}),"\n",(0,s.jsx)(n.strong,{children:"赋值语句可以一步跳过，看返回值即可，后续详细再看。"}),"\n",(0,s.jsx)(n.strong,{children:"函数执行需要断点跟着看，也可以结合注释和上下文倒推这个函数做了什么。"})]}),"\n",(0,s.jsxs)(n.h2,{id:"4-axios-源码-初始化",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-axios-源码-初始化",children:"#"}),"4. axios 源码 初始化"]}),"\n",(0,s.jsxs)(n.p,{children:["看源码第一步，先看",(0,s.jsx)(n.code,{children:"package.json"}),"。一般都会申明 ",(0,s.jsx)(n.code,{children:"main"})," 主入口文件。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n  "name": "axios",\n  "version": "0.19.0",\n  "description": "Promise based HTTP client for the browser and node.js",\n  "main": "index.js",\n  // ...\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"主入口文件"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// index.js\nmodule.exports = require('./lib/axios');\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"41libaxiosjs主文件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41libaxiosjs主文件",children:"#"}),"4.1",(0,s.jsx)(n.code,{children:"lib/axios.js"}),"主文件"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios.js"}),"文件 代码相对比较多。分为三部分展开叙述。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["第一部分：引入一些工具函数",(0,s.jsx)(n.code,{children:"utils"}),"、",(0,s.jsx)(n.code,{children:"Axios"}),"构造函数、默认配置",(0,s.jsx)(n.code,{children:"defaults"}),"等。"]}),"\n",(0,s.jsxs)(n.li,{children:["第二部分：是生成实例对象 ",(0,s.jsx)(n.code,{children:"axios"}),"、",(0,s.jsx)(n.code,{children:"axios.Axios"}),"、",(0,s.jsx)(n.code,{children:"axios.create"}),"等。"]}),"\n",(0,s.jsxs)(n.li,{children:["第三部分取消相关API实现，还有",(0,s.jsx)(n.code,{children:"all"}),"、",(0,s.jsx)(n.code,{children:"spread"}),"、导出等实现。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"411-第一部分",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#411-第一部分",children:"#"}),"4.1.1 第一部分"]}),"\n",(0,s.jsxs)(n.p,{children:["引入一些工具函数",(0,s.jsx)(n.code,{children:"utils"}),"、",(0,s.jsx)(n.code,{children:"Axios"}),"构造函数、默认配置",(0,s.jsx)(n.code,{children:"defaults"}),"等。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 第一部分：\n// lib/axios\n// 严格模式\n'use strict';\n// 引入 utils 对象，有很多工具方法。\nvar utils = require('./utils');\n// 引入 bind 方法\nvar bind = require('./helpers/bind');\n// 核心构造函数 Axios\nvar Axios = require('./core/Axios');\n// 合并配置方法\nvar mergeConfig = require('./core/mergeConfig');\n// 引入默认配置\nvar defaults = require('./defaults');\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"412-第二部分",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#412-第二部分",children:"#"}),"4.1.2 第二部分"]}),"\n",(0,s.jsxs)(n.p,{children:["是生成实例对象 ",(0,s.jsx)(n.code,{children:"axios"}),"、",(0,s.jsx)(n.code,{children:"axios.Axios"}),"、",(0,s.jsx)(n.code,{children:"axios.create"}),"等。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  // new 一个 Axios 生成实例对象\n  var context = new Axios(defaultConfig);\n  // bind 返回一个新的 wrap 函数，\n  // 也就是为什么调用 axios 是调用 Axios.prototype.request 函数的原因\n  var instance = bind(Axios.prototype.request, context);\n  // Copy axios.prototype to instance\n  // 复制 Axios.prototype 到实例上。\n  // 也就是为什么 有 axios.get 等别名方法，\n  // 且调用的是 Axios.prototype.get 等别名方法。\n  utils.extend(instance, Axios.prototype, context);\n  // Copy context to instance\n  // 复制 context 到 intance 实例\n  // 也就是为什么默认配置 axios.defaults 和拦截器  axios.interceptors 可以使用的原因\n  // 其实是new Axios().defaults 和 new Axios().interceptors\n  utils.extend(instance, context);\n  // 最后返回实例对象，以上代码，在上文的图中都有体现。这时可以仔细看下上图。\n  return instance;\n}\n\n// Create the default instance to be exported\n// 导出 创建默认实例\nvar axios = createInstance(defaults);\n// Expose Axios class to allow class inheritance\n// 暴露 Axios class 允许 class 继承 也就是可以 new axios.Axios()\n// 但  axios 文档中 并没有提到这个，我们平时也用得少。\naxios.Axios = Axios;\n\n// Factory for creating new instances\n// 工厂模式 创建新的实例 用户可以自定义一些参数\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里简述下工厂模式。",(0,s.jsx)(n.code,{children:"axios.create"}),"，也就是用户不需要知道内部是怎么实现的。","\n举个生活的例子，我们买手机，不需要知道手机是怎么做的，就是工厂模式。","\n看完第二部分，里面涉及几个工具函数，如",(0,s.jsx)(n.code,{children:"bind"}),"、",(0,s.jsx)(n.code,{children:"extend"}),"。接下来讲述这几个工具方法。"]}),"\n",(0,s.jsxs)(n.h4,{id:"413-工具方法之-bind",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#413-工具方法之-bind",children:"#"}),"4.1.3 工具方法之 bind"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"axios/lib/helpers/bind.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"'use strict';\n// 返回一个新的函数 wrap\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    // 把 argument 对象放在数组 args 里\n    return fn.apply(thisArg, args);\n  };\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["传递两个参数函数和",(0,s.jsx)(n.code,{children:"thisArg"}),"指向。","\n把参数",(0,s.jsx)(n.code,{children:"arguments"}),"生成数组，最后调用返回参数结构。","\n其实现在 ",(0,s.jsx)(n.code,{children:"apply"})," 支持 ",(0,s.jsx)(n.code,{children:"arguments"}),"这样的类数组对象了，不需要手动转数组。","\n那么为啥作者要转数组，为了性能？当时不支持？抑或是作者不知道？这就不得而知了。有读者知道欢迎评论区告诉笔者呀。"]}),"\n",(0,s.jsxs)(n.p,{children:["关于",(0,s.jsx)(n.code,{children:"apply"}),"、",(0,s.jsx)(n.code,{children:"call"}),"和",(0,s.jsx)(n.code,{children:"bind"}),"等不是很熟悉的读者，可以看笔者的另一个",(0,s.jsx)(n.code,{children:"面试官问系列"}),"。","\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"})]}),"\n",(0,s.jsx)(n.p,{children:"举个例子"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function fn(){\n  console.log.apply(console, arguments);\n}\nfn(1,2,3,4,5,6, '若川');\n// 1 2 3 4 5 6 '若川'\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"414-工具方法之-utilsextend",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#414-工具方法之-utilsextend",children:"#"}),"4.1.4 工具方法之 utils.extend"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"axios/lib/utils.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其实就是遍历参数 ",(0,s.jsx)(n.code,{children:"b"})," 对象，复制到 ",(0,s.jsx)(n.code,{children:"a"})," 对象上，如果是函数就是则用 ",(0,s.jsx)(n.code,{children:"bind"})," 调用。"]}),"\n",(0,s.jsxs)(n.h4,{id:"415-工具方法之-utilsforeach",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#415-工具方法之-utilsforeach",children:"#"}),"4.1.5 工具方法之 utils.forEach"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"axios/lib/utils.js"})}),"\n",(0,s.jsxs)(n.p,{children:["遍历数组和对象。设计模式称之为迭代器模式。很多源码都有类似这样的遍历函数。比如大家熟知的",(0,s.jsx)(n.code,{children:"jQuery"})," ",(0,s.jsx)(n.code,{children:"$.each"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  // 判断 null 和 undefined 直接返回\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  // 如果不是对象，放在数组里。\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  // 是数组 则用for 循环，调用 fn 函数。参数类似 Array.prototype.forEach 的前三个参数。\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    // 用 for in 遍历对象，但 for in 会遍历原型链上可遍历的属性。\n    // 所以用 hasOwnProperty 来过滤自身属性了。\n    // 其实也可以用Object.keys来遍历，它不遍历原型链上可遍历的属性。\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果对",(0,s.jsx)(n.code,{children:"Object"}),"相关的",(0,s.jsx)(n.code,{children:"API"}),"不熟悉，可以查看笔者之前写过的一篇文章。",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/js-object-api/",rel:"noopener noreferrer",target:"_blank",children:"JavaScript 对象所有API解析"})]}),"\n",(0,s.jsxs)(n.h4,{id:"416-第三部分",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#416-第三部分",children:"#"}),"4.1.6 第三部分"]}),"\n",(0,s.jsxs)(n.p,{children:["取消相关API实现，还有",(0,s.jsx)(n.code,{children:"all"}),"、",(0,s.jsx)(n.code,{children:"spread"}),"、导出等实现。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Expose Cancel & CancelToken\n// 导出 Cancel 和 CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\n// 导出 all 和 spread API\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\n// 也就是可以以下方式引入\n// import axios from 'axios';\nmodule.exports.default = axios;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里介绍下 ",(0,s.jsx)(n.code,{children:"spread"}),"，取消的",(0,s.jsx)(n.code,{children:"API"}),"暂时不做分析，后文再详细分析。"]}),"\n",(0,s.jsx)(n.p,{children:"假设你有这样的需求。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function f(x, y, z) {}\nvar args = [1, 2, 3];\nf.apply(null, args);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["那么可以用",(0,s.jsx)(n.code,{children:"spread"}),"方法。用法："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"axios.spread(function(x, y, z) {})([1, 2, 3]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"实现也比较简单。源码实现："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上文",(0,s.jsx)(n.code,{children:"var context = new Axios(defaultConfig);"}),"，接下来介绍核心构造函数",(0,s.jsx)(n.code,{children:"Axios"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"42-核心构造函数-axios",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-核心构造函数-axios",children:"#"}),"4.2 核心构造函数 Axios"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"axios/lib/core/Axios.js"})}),"\n",(0,s.jsxs)(n.p,{children:["构造函数",(0,s.jsx)(n.code,{children:"Axios"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function Axios(instanceConfig) {\n  // 默认参数\n  this.defaults = instanceConfig;\n  // 拦截器 请求和响应拦截器\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Axios.prototype.request = function(config){\n  // 省略，这个是核心方法，后文结合例子详细描述\n  // code ...\n  var promise = Promise.resolve(config);\n  // code ...\n  return promise;\n}\n// 这是获取 Uri 的函数，这里省略\nAxios.prototype.getUri = function(){}\n// 提供一些请求方法的别名\n// Provide aliases for supported request methods\n// 遍历执行\n// 也就是为啥我们可以 axios.get 等别名的方式调用，而且调用的是 Axios.prototype.request 方法\n// 这个也在上面的 axios 结构图上有所体现。\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来看拦截器部分。"}),"\n",(0,s.jsxs)(n.h3,{id:"43-拦截器管理构造函数-interceptormanager",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-拦截器管理构造函数-interceptormanager",children:"#"}),"4.3 拦截器管理构造函数 InterceptorManager"]}),"\n",(0,s.jsxs)(n.p,{children:["请求前拦截，和请求后拦截。","\n在",(0,s.jsx)(n.code,{children:"Axios.prototype.request"}),"函数里使用，具体怎么实现的拦截的，后文配合例子详细讲述。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/axios/axios#interceptors",rel:"noopener noreferrer",target:"_blank",children:"axios github 仓库 拦截器文档"})}),"\n",(0,s.jsx)(n.p,{children:"如何使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Add a request interceptor\n// 添加请求前拦截器\naxios.interceptors.request.use(function (config) {\n  // Do something before request is sent\n  return config;\n}, function (error) {\n  // Do something with request error\n  return Promise.reject(error);\n});\n\n// Add a response interceptor\n// 添加请求后拦截器\naxios.interceptors.response.use(function (response) {\n  // Any status code that lie within the range of 2xx cause this function to trigger\n  // Do something with response data\n  return response;\n}, function (error) {\n  // Any status codes that falls outside the range of 2xx cause this function to trigger\n  // Do something with response error\n  return Promise.reject(error);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果想把拦截器移除，可以用",(0,s.jsx)(n.code,{children:"eject"}),"方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const myInterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n"})}),"\n",(0,s.jsx)(n.p,{children:"拦截器也可以添加自定义的实例上。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n"})}),"\n",(0,s.jsx)(n.p,{children:"源码实现："}),"\n",(0,s.jsxs)(n.p,{children:["构造函数，",(0,s.jsx)(n.code,{children:"handles"})," 用于存储拦截器函数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function InterceptorManager() {\n  this.handlers = [];\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来声明了三个方法：使用、移除、遍历。"}),"\n",(0,s.jsxs)(n.h4,{id:"431-interceptormanagerprototypeuse-使用",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#431-interceptormanagerprototypeuse-使用",children:"#"}),"4.3.1 InterceptorManager.prototype.use 使用"]}),"\n",(0,s.jsxs)(n.p,{children:["传递两个函数作为参数，数组中的一项存储的是",(0,s.jsx)(n.code,{children:"{fulfilled: function(){}, rejected: function(){}}"}),"。返回数字 ",(0,s.jsx)(n.code,{children:"ID"}),"，用于移除拦截器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} 返回ID 是为了用 eject 移除\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"432-interceptormanagerprototypeeject-移除",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#432-interceptormanagerprototypeeject-移除",children:"#"}),"4.3.2 InterceptorManager.prototype.eject 移除"]}),"\n",(0,s.jsxs)(n.p,{children:["根据 ",(0,s.jsx)(n.code,{children:"use"})," 返回的 ",(0,s.jsx)(n.code,{children:"ID"})," 移除 拦截器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["有点类似定时器",(0,s.jsx)(n.code,{children:"setTimeout"})," 和 ",(0,s.jsx)(n.code,{children:"setInterval"}),"，返回值是",(0,s.jsx)(n.code,{children:"id"}),"。用",(0,s.jsx)(n.code,{children:"clearTimeout"})," 和",(0,s.jsx)(n.code,{children:"clearInterval"}),"来清除定时器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 提一下 定时器回调函数是可以传参的，返回值 timer 是数字\nvar timer = setInterval((name) => {\n  console.log(name);\n}, 1000, '若川');\nconsole.log(timer); // 数字 ID\n// 在控制台等会再输入执行这句，定时器就被清除了\nclearInterval(timer);\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"433-interceptormanagerprototypeforeach-遍历",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#433-interceptormanagerprototypeforeach-遍历",children:"#"}),"4.3.3 InterceptorManager.prototype.forEach 遍历"]}),"\n",(0,s.jsxs)(n.p,{children:["遍历执行所有拦截器，传递一个回调函数（每一个拦截器函数作为参数）调用，被移除的一项是",(0,s.jsx)(n.code,{children:"null"}),"，所以不会执行，也就达到了移除的效果。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"5-实例结合",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-实例结合",children:"#"}),"5. 实例结合"]}),"\n",(0,s.jsxs)(n.p,{children:["上文叙述的调试时运行",(0,s.jsx)(n.code,{children:"npm start"})," 是用",(0,s.jsx)(n.code,{children:"axios/sandbox/client.html"}),"路径的文件作为示例的，读者可以自行调试。"]}),"\n",(0,s.jsx)(n.p,{children:"以下是一段这个文件中的代码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"axios(options)\n.then(function (res) {\n  response.innerHTML = JSON.stringify(res.data, null, 2);\n})\n.catch(function (res) {\n  response.innerHTML = JSON.stringify(res.data, null, 2);\n});\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"51-先看调用栈流程",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-先看调用栈流程",children:"#"}),"5.1 先看调用栈流程"]}),"\n",(0,s.jsxs)(n.p,{children:["如果不想一步步调试，有个偷巧的方法。","\n知道 ",(0,s.jsx)(n.code,{children:"axios"})," 使用了",(0,s.jsx)(n.code,{children:"XMLHttpRequest"}),"。","\n可以在项目中搜索：",(0,s.jsx)(n.code,{children:"new XMLHttpRequest"}),"。","\n定位到文件 ",(0,s.jsx)(n.code,{children:"axios/lib/adapters/xhr.js"}),"\n在这条语句 ",(0,s.jsx)(n.code,{children:"var request = new XMLHttpRequest();"}),"\n",(0,s.jsx)(n.code,{children:"chrome"})," 浏览器中 打个断点调试下，再根据调用栈来细看具体函数等实现。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Call Stack"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"dispatchXhrRequest (xhr.js:19)\nxhrAdapter (xhr.js:12)\ndispatchRequest (dispatchRequest.js:60)\nPromise.then (async)\nrequest (Axios.js:54)\nwrap (bind.js:10)\nsubmit.onclick ((index):138)\n"})}),"\n",(0,s.jsx)(n.p,{children:"简述下流程："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Send Request"})," 按钮点击 ",(0,s.jsx)(n.code,{children:"submit.onclick"})]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"axios"})," 函数实际上是调用 ",(0,s.jsx)(n.code,{children:"Axios.prototype.request"})," 函数，而这个函数使用 ",(0,s.jsx)(n.code,{children:"bind"})," 返回的一个名为",(0,s.jsx)(n.code,{children:"wrap"}),"的函数。"]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"Axios.prototype.request"})]}),"\n",(0,s.jsxs)(n.li,{children:["（有请求拦截器的情况下执行请求拦截器），中间会执行 ",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"方法"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dispatchRequest"})," 之后调用 ",(0,s.jsx)(n.code,{children:"adapter (xhrAdapter)"})]}),"\n",(0,s.jsxs)(n.li,{children:["最后调用 ",(0,s.jsx)(n.code,{children:"Promise"})," 中的函数",(0,s.jsx)(n.code,{children:"dispatchXhrRequest"}),"，（有响应拦截器的情况下最后会再调用响应拦截器）"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果仔细看了文章开始的",(0,s.jsx)(n.code,{children:"axios 结构关系图"}),"，其实对这个流程也有大概的了解。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来看 ",(0,s.jsx)(n.code,{children:"Axios.prototype.request"})," 具体实现。"]}),"\n",(0,s.jsxs)(n.h3,{id:"52-axiosprototyperequest-请求核心方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-axiosprototyperequest-请求核心方法",children:"#"}),"5.2 Axios.prototype.request 请求核心方法"]}),"\n",(0,s.jsx)(n.p,{children:"这个函数是核心函数。\n主要做了这几件事："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.判断第一个参数是字符串，则设置 url,也就是支持",(0,s.jsx)(n.code,{children:"axios('example/url', [, config])"}),"，也支持",(0,s.jsx)(n.code,{children:"axios({})"}),"。","\n2.合并默认参数和用户传递的参数","\n3.设置请求的方法，默认是是",(0,s.jsx)(n.code,{children:"get"}),"方法","\n4.将用户设置的请求和响应拦截器、发送请求的",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"组成",(0,s.jsx)(n.code,{children:"Promise"}),"链，最后返回还是",(0,s.jsx)(n.code,{children:"Promise"}),"实例。","\n也就是保证了请求前拦截器先执行，然后发送请求，再响应拦截器执行这样的顺序。","\n也就是为啥最后还是可以",(0,s.jsx)(n.code,{children:"then"}),"，",(0,s.jsx)(n.code,{children:"catch"}),"方法的缘故。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Axios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  // 这一段代码 其实就是 使 axios('example/url', [, config])\n  // config 参数可以省略\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  // 合并默认参数和用户传递的参数\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  // 设置 请求方法，默认 get 。\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n  // Hook up interceptors middleware\n  // 组成`Promise`链 这段拆开到后文再讲述\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"521-组成promise链返回promise实例",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#521-组成promise链返回promise实例",children:"#"}),"5.2.1 组成",(0,s.jsx)(n.code,{children:"Promise"}),"链，返回",(0,s.jsx)(n.code,{children:"Promise"}),"实例"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这部分：用户设置的请求和响应拦截器、发送请求的",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"组成",(0,s.jsx)(n.code,{children:"Promise"}),"链。也就是保证了请求前拦截器先执行，然后发送请求，再响应拦截器执行这样的顺序","\n也就是保证了请求前拦截器先执行，然后发送请求，再响应拦截器执行这样的顺序","\n也就是为啥最后还是可以",(0,s.jsx)(n.code,{children:"then"}),"，",(0,s.jsx)(n.code,{children:"catch"}),"方法的缘故。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果读者对",(0,s.jsx)(n.code,{children:"Promise"}),"不熟悉，建议读阮老师的书籍《ES6 标准入门》。\n",(0,s.jsx)(n.a,{href:"http://es6.ruanyifeng.com/#docs/promise",rel:"noopener noreferrer",target:"_blank",children:"阮一峰老师 的 ES6 Promise-resolve"})," 和 ",(0,s.jsx)(n.a,{href:"http://liubin.org/promises-book/",rel:"noopener noreferrer",target:"_blank",children:"JavaScript Promise迷你书（中文版）"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  // 组成`Promise`链\n  // Hook up interceptors middleware\n  // 把 xhr 请求 的 dispatchRequest 和 undefined 放在一个数组里\n  var chain = [dispatchRequest, undefined];\n  // 创建 Promise 实例\n  var promise = Promise.resolve(config);\n\n // 遍历用户设置的请求拦截器 放到数组的 chain 前面\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n // 遍历用户设置的响应拦截器 放到数组的 chain 后面\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n // 遍历 chain 数组，直到遍历 chain.length 为 0\n  while (chain.length) {\n    // 两两对应移出来 放到 then 的两个参数里。\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var promise = Promise.resolve(config);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["解释下这句。作用是生成",(0,s.jsx)(n.code,{children:"Promise"}),"实例。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var promise = Promise.resolve({name: '若川'})\n// 等价于\n// new Promise(resolve => resolve({name: '若川'}))\npromise.then(function (config){\n  console.log(config)\n});\n// {name: \"若川\"}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同样解释下后文会出现的",(0,s.jsx)(n.code,{children:"Promise.reject(error);"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Promise.reject(error);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var promise = Promise.reject({name: '若川'})\n// 等价于\n// new Promise(reject => reject({name: '若川'}))\n\n// promise.then(null, function (config){\n//   console.log(config)\n// });\n// 等价于\npromise.catch(function (config){\n  console.log(config)\n});\n// {name: \"若川\"}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来结合例子，来理解这段代码。","\n很遗憾，在",(0,s.jsx)(n.code,{children:"example"}),"文件夹没有拦截器的例子。笔者在",(0,s.jsx)(n.code,{children:"example"}),"中在",(0,s.jsx)(n.code,{children:"example/get"}),"的基础上添加了一个拦截器的示例。",(0,s.jsx)(n.code,{children:"axios/examples/interceptors"}),"，便于读者调试。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node ./examples/server.js -p 5000\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"promise = promise.then(chain.shift(), chain.shift());"}),"这段代码打个断点。"]}),"\n",(0,s.jsxs)(n.p,{children:["会得到这样的这张图。\n",(0,s.jsx)(n.img,{alt:"request方法中promise链",src:a})]}),"\n",(0,s.jsxs)(n.p,{children:["特别关注下，右侧，",(0,s.jsx)(n.code,{children:"local"}),"中的",(0,s.jsx)(n.code,{children:"chain"}),"数组。也就是这样的结构。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var chain = [\n  '请求成功拦截2', '请求失败拦截2',\n  '请求成功拦截1', '请求失败拦截1',\n  dispatch,  undefined,\n  '响应成功拦截1', '响应失败拦截1',\n  '响应成功拦截2', '响应失败拦截2',\n]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这段代码相对比较绕。也就是会生成如下类似的代码，中间会调用",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// config 是 用户配置和默认配置合并的\nvar promise = Promise.resolve(config);\npromise.then('请求成功拦截2', '请求失败拦截2')\n.then('请求成功拦截1', '请求失败拦截1')\n.then(dispatchRequest, undefined)\n.then('响应成功拦截1', '响应失败拦截1')\n.then('响应成功拦截2', '响应失败拦截2')\n\n.then('用户写的业务处理函数')\n.catch('用户写的报错业务处理函数');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里提下",(0,s.jsx)(n.code,{children:"promise"})," ",(0,s.jsx)(n.code,{children:"then"}),"和",(0,s.jsx)(n.code,{children:"catch"}),"知识：","\n",(0,s.jsx)(n.code,{children:"Promise.prototype.then"}),"方法的第一个参数是",(0,s.jsx)(n.code,{children:"resolved"}),"状态的回调函数，第二个参数（可选）是",(0,s.jsx)(n.code,{children:"rejected"}),"状态的回调函数。所以是成对出现的。","\n",(0,s.jsx)(n.code,{children:"Promise.prototype.catch"}),"方法是",(0,s.jsx)(n.code,{children:".then(null, rejection)"}),"或",(0,s.jsx)(n.code,{children:".then(undefined, rejection)"}),"的别名，用于指定发生错误时的回调函数。","\n",(0,s.jsx)(n.code,{children:"then"}),"方法返回的是一个新的",(0,s.jsx)(n.code,{children:"Promise"}),"实例（注意，不是原来那个",(0,s.jsx)(n.code,{children:"Promise"}),"实例）。因此可以采用链式写法，即",(0,s.jsx)(n.code,{children:"then"}),"方法后面再调用另一个",(0,s.jsx)(n.code,{children:"then"}),"方法。"]}),"\n",(0,s.jsx)(n.p,{children:"结合上述的例子更详细一点，代码则是这样的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var promise = Promise.resolve(config);\n// promise.then('请求成功拦截2', '请求失败拦截2')\npromise.then(function requestSuccess2(config) {\n  console.log('------request------success------2');\n  return config;\n}, function requestError2(error) {\n  console.log('------response------error------2');\n  return Promise.reject(error);\n})\n\n// .then('请求成功拦截1', '请求失败拦截1')\n.then(function requestSuccess1(config) {\n  console.log('------request------success------1');\n  return config;\n}, function requestError1(error) {\n  console.log('------response------error------1');\n  return Promise.reject(error);\n})\n\n// .then(dispatchRequest, undefined)\n.then( function dispatchRequest(config) {\n  /**\n    * 适配器返回的也是Promise 实例\n      adapter = function xhrAdapter(config) {\n            return new Promise(function dispatchXhrRequest(resolve, reject) {})\n      }\n    **/\n  return adapter(config).then(function onAdapterResolution(response) {\n    // 省略代码 ...\n    return response;\n  }, function onAdapterRejection(reason) {\n    // 省略代码 ...\n    return Promise.reject(reason);\n  });\n}, undefined)\n\n// .then('响应成功拦截1', '响应失败拦截1')\n.then(function responseSuccess1(response) {\n  console.log('------response------success------1');\n  return response;\n}, function responseError1(error) {\n  console.log('------response------error------1');\n  return Promise.reject(error);\n})\n\n// .then('响应成功拦截2', '响应失败拦截2')\n.then(function responseSuccess2(response) {\n  console.log('------response------success------2');\n  return response;\n}, function responseError2(error) {\n  console.log('------response------error------2');\n  return Promise.reject(error);\n})\n\n// .then('用户写的业务处理函数')\n// .catch('用户写的报错业务处理函数');\n.then(function (response) {\n  console.log('哈哈哈，终于获取到数据了', response);\n})\n.catch(function (err) {\n  console.log('哎呀，怎么报错了', err);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["仔细看这段",(0,s.jsx)(n.code,{children:"Promise"}),"链式调用，代码都类似。",(0,s.jsx)(n.code,{children:"then"}),"方法最后返回的参数，就是下一个",(0,s.jsx)(n.code,{children:"then"}),"方法第一个参数。","\n",(0,s.jsx)(n.code,{children:"catch"}),"错误捕获，都返回",(0,s.jsx)(n.code,{children:"Promise.reject(error)"}),"，这是为了便于用户",(0,s.jsx)(n.code,{children:"catch"}),"时能捕获到错误。"]}),"\n",(0,s.jsx)(n.p,{children:"举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var p1 = new Promise((resolve, reject) => {\n reject(new Error({name: '若川'}));\n});\n\np1.catch(err => {\n    console.log(res, 'err');\n    return Promise.reject(err)\n})\n.catch(err => {\n console.log(err, 'err1');\n})\n.catch(err => {\n console.log(err, 'err2');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"err2"}),"不会捕获到，也就是不会执行，但如果都返回了",(0,s.jsx)(n.code,{children:"return Promise.reject(err)"}),"，则可以捕获到。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后画个图总结下 ",(0,s.jsx)(n.code,{children:"Promise"})," 链式调用。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"axios promise 链式调用",src:t})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["小结：1. 请求和响应的拦截器可以写",(0,s.jsx)(n.code,{children:"Promise"}),"。","\n2. 如果设置了多个请求响应器，后设置的先执行。","\n3. 如果设置了多个响应拦截器，先设置的先执行。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dispatchRequest(config)"})," 这里的",(0,s.jsx)(n.code,{children:"config"}),"是请求成功拦截器返回的。接下来看",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"53-dispatchrequest-最终派发请求",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53-dispatchrequest-最终派发请求",children:"#"}),"5.3 dispatchRequest 最终派发请求"]}),"\n",(0,s.jsx)(n.p,{children:"这个函数主要做了如下几件事情："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.如果已经取消，则 ",(0,s.jsx)(n.code,{children:"throw"})," 原因报错，使",(0,s.jsx)(n.code,{children:"Promise"}),"走向",(0,s.jsx)(n.code,{children:"rejected"}),"。","\n2.确保 ",(0,s.jsx)(n.code,{children:"config.header"})," 存在。","\n3.利用用户设置的和默认的请求转换器转换数据。","\n4.拍平 ",(0,s.jsx)(n.code,{children:"config.header"}),"。","\n5.删除一些 ",(0,s.jsx)(n.code,{children:"config.header"}),"。","\n6.返回适配器",(0,s.jsx)(n.code,{children:"adapter"}),"（",(0,s.jsx)(n.code,{children:"Promise"}),"实例）执行后 ",(0,s.jsx)(n.code,{children:"then"}),"执行后的 ",(0,s.jsx)(n.code,{children:"Promise"}),"实例。返回结果传递给响应拦截器处理。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"'use strict';\n// utils 工具函数\nvar utils = require('./../utils');\n// 转换数据\nvar transformData = require('./transformData');\n// 取消状态\nvar isCancel = require('../cancel/isCancel');\n// 默认参数\nvar defaults = require('../defaults');\n\n/**\n * 抛出 错误原因，使`Promise`走向`rejected`\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  // 取消相关\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  // 确保 headers 存在\n  config.headers = config.headers || {};\n\n  // Transform request data\n  // 转换请求的数据\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  // 拍平 headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  // 以下这些方法 删除 headers\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n  // adapter 适配器部分 拆开 放在下文讲\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"531-dispatchrequest-之-transformdata-转换数据",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#531-dispatchrequest-之-transformdata-转换数据",children:"#"}),"5.3.1 dispatchRequest 之 transformData 转换数据"]}),"\n",(0,s.jsxs)(n.p,{children:["上文的代码里有个函数 ",(0,s.jsx)(n.code,{children:"transformData"})," ，这里解释下。其实就是遍历传递的函数数组 对数据操作，最后返回数据。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios.defaults.transformResponse"})," 数组中默认就有一个函数，所以使用",(0,s.jsx)(n.code,{children:"concat"}),"链接自定义的函数。"]}),"\n",(0,s.jsx)(n.p,{children:"使用："}),"\n",(0,s.jsxs)(n.p,{children:["文件路径\n",(0,s.jsx)(n.code,{children:"axios/examples/transform-response/index.html"})]}),"\n",(0,s.jsxs)(n.p,{children:["这段代码其实就是对时间格式的字符串转换成时间对象，可以直接调用",(0,s.jsx)(n.code,{children:"getMonth"}),"等方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var ISO_8601 = /(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2})Z/;\nfunction formatDate(d) {\n  return (d.getMonth() + 1) + '/' + d.getDate() + '/' + d.getFullYear();\n}\n\naxios.get('https://api.github.com/users/mzabriskie', {\n  transformResponse: axios.defaults.transformResponse.concat(function (data, headers) {\n    Object.keys(data).forEach(function (k) {\n      if (ISO_8601.test(data[k])) {\n        data[k] = new Date(Date.parse(data[k]));\n      }\n    });\n    return data;\n  })\n})\n.then(function (res) {\n  document.getElementById('created').innerHTML = formatDate(res.data.created_at);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"源码："}),"\n",(0,s.jsxs)(n.p,{children:["就是遍历数组，调用数组里的传递 ",(0,s.jsx)(n.code,{children:"data"})," 和 ",(0,s.jsx)(n.code,{children:"headers"})," 参数调用函数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"532-dispatchrequest-之-adapter-适配器执行部分",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#532-dispatchrequest-之-adapter-适配器执行部分",children:"#"}),"5.3.2 dispatchRequest 之 adapter 适配器执行部分"]}),"\n",(0,s.jsx)(n.p,{children:"适配器，在设计模式中称之为适配器模式。讲个生活中简单的例子，大家就容易理解。"}),"\n",(0,s.jsxs)(n.p,{children:["我们常用以前手机耳机孔都是圆孔，而现在基本是耳机孔和充电接口合二为一。统一为",(0,s.jsx)(n.code,{children:"typec"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这时我们需要需要一个",(0,s.jsx)(n.code,{children:"typec转圆孔的转接口"}),"，这就是适配器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  // adapter 适配器部分\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    // 转换响应的数据\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      // 取消相关\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      // 转换响应的数据\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来看具体的 ",(0,s.jsx)(n.code,{children:"adapter"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"54-adapter-适配器-真正发送请求",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#54-adapter-适配器-真正发送请求",children:"#"}),"5.4 adapter 适配器 真正发送请求"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var adapter = config.adapter || defaults.adapter;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["看了上文的 ",(0,s.jsx)(n.code,{children:"adapter"}),"，可以知道支持用户自定义。比如可以通过微信小程序 ",(0,s.jsx)(n.code,{children:"wx.request"})," 按照要求也写一个 ",(0,s.jsx)(n.code,{children:"adapter"}),"。","\n接着来看下 ",(0,s.jsx)(n.code,{children:"defaults.ddapter"}),"。","\n文件路径：",(0,s.jsx)(n.code,{children:"axios/lib/defaults.js"})]}),"\n",(0,s.jsxs)(n.p,{children:["根据当前环境引入，如果是浏览器环境引入",(0,s.jsx)(n.code,{children:"xhr"}),"，是",(0,s.jsx)(n.code,{children:"node"}),"环境则引入",(0,s.jsx)(n.code,{children:"http"}),"。","\n类似判断",(0,s.jsx)(n.code,{children:"node"}),"环境，也在",(0,s.jsx)(n.a,{href:"https://github.com/getsentry/sentry-javascript/blob/a876d46c61e2618e3c3a3e1710f77419331a9248/packages/utils/src/misc.ts#L37-L40",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"sentry-javascript"})}),"源码中有看到。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getDefaultAdapter() {\n  var adapter;\n  // 根据 XMLHttpRequest 判断\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n    // 根据 process 判断\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\nvar defaults = {\n  adapter: getDefaultAdapter(),\n  // ...\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"xhr"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来就是我们熟悉的 ",(0,s.jsx)(n.code,{children:"XMLHttpRequest"})," 对象。"]}),"\n",(0,s.jsxs)(n.p,{children:["可能读者不了解可以参考",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest",rel:"noopener noreferrer",target:"_blank",children:"XMLHttpRequest MDN 文档"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["主要提醒下：",(0,s.jsx)(n.code,{children:"onabort"}),"是请求取消事件，",(0,s.jsx)(n.code,{children:"withCredentials"}),"是一个布尔值，用来指定跨域 ",(0,s.jsx)(n.code,{children:"Access-Control"})," 请求是否应带有授权信息，如 ",(0,s.jsx)(n.code,{children:"cookie"})," 或授权 ",(0,s.jsx)(n.code,{children:"header"})," 头。"]}),"\n",(0,s.jsxs)(n.p,{children:["这块代码有删减，具体可以看",(0,s.jsxs)(n.a,{href:"https://github.com/ruochuan12/axios-analysis/blob/master/axios/lib/adapters/xhr.js",rel:"noopener noreferrer",target:"_blank",children:["若川的",(0,s.jsx)(n.code,{children:"axios-analysis"}),"仓库"]}),"，也可以克隆笔者的",(0,s.jsx)(n.code,{children:"axios-analysis"}),"仓库调试时再具体分析。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    // 这块代码有删减\n    var request = new XMLHttpRequest();\n    request.open()\n    request.timeout = config.timeout;\n    // 监听 state 改变\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n      // ...\n    }\n    // 取消\n    request.onabort = function(){};\n    // 错误\n    request.onerror = function(){};\n    // 超时\n    request.ontimeout = function(){};\n    // cookies 跨域携带 cookies 面试官常喜欢考这个\n    // 一个布尔值，用来指定跨域 Access-Control 请求是否应带有授权信息，如 cookie 或授权 header 头。\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // 上传下载进度相关\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    // Send the request\n    // 发送请求\n    request.send(requestData);\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而实际上现在 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"fetch"})})," 支持的很好了，阿里开源的 ",(0,s.jsx)(n.a,{href:"https://github.com/umijs/umi-request/blob/master/README_zh-CN.md",rel:"noopener noreferrer",target:"_blank",children:"umi-request"})," 请求库，就是用",(0,s.jsx)(n.code,{children:"fetch"}),"封装的，而不是用",(0,s.jsx)(n.code,{children:"XMLHttpRequest"}),"。\n文章末尾，大概讲述下 ",(0,s.jsx)(n.code,{children:"umi-request"})," 和 ",(0,s.jsx)(n.code,{children:"axios"})," 的区别。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"http"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"http"}),"这里就不详细叙述了，感兴趣的读者可以自行查看，",(0,s.jsxs)(n.a,{href:"https://github.com/ruochuan12/axios-analysis/blob/master/axios/lib/adapters/http.js",rel:"noopener noreferrer",target:"_blank",children:["若川的",(0,s.jsx)(n.code,{children:"axios-analysis"}),"仓库"]}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n  });\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上文 ",(0,s.jsx)(n.code,{children:"dispatchRequest"})," 有取消模块，我觉得是重点，所以放在最后来细讲："]}),"\n",(0,s.jsxs)(n.h3,{id:"55-dispatchrequest-之-取消模块",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#55-dispatchrequest-之-取消模块",children:"#"}),"5.5 dispatchRequest 之 取消模块"]}),"\n",(0,s.jsxs)(n.p,{children:["可以使用",(0,s.jsx)(n.code,{children:"cancel token"}),"取消请求。"]}),"\n",(0,s.jsxs)(n.p,{children:["axios cancel token API 是基于撤销的 ",(0,s.jsx)(n.code,{children:"promise"})," 取消提议。"]}),"\n",(0,s.jsxs)(n.p,{children:["The axios cancel token API is based on the withdrawn ",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-cancelable-promises",rel:"noopener noreferrer",target:"_blank",children:"cancelable promises proposal."})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/axios/axios#cancellation",rel:"noopener noreferrer",target:"_blank",children:"axios 文档 cancellation"})}),"\n",(0,s.jsx)(n.p,{children:"文档上详细描述了两种使用方式。"}),"\n",(0,s.jsxs)(n.p,{children:["很遗憾，在",(0,s.jsx)(n.code,{children:"example"}),"文件夹也没有取消的例子。笔者在",(0,s.jsx)(n.code,{children:"example"}),"中在",(0,s.jsx)(n.code,{children:"example/get"}),"的基础上添加了一个取消的示例。",(0,s.jsx)(n.code,{children:"axios/examples/cancel"}),"，便于读者调试。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node ./examples/server.js -p 5000\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"request"}),"中的拦截器和",(0,s.jsx)(n.code,{children:"dispatch"}),"中的取消这两个模块相对复杂，可以多调试调试，吸收消化。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/get/server', {\n  cancelToken: source.token\n}).catch(function (err) {\n  if (axios.isCancel(err)) {\n    console.log('Request canceled', err.message);\n  } else {\n    // handle error\n  }\n});\n\n// cancel the request (the message parameter is optional)\n// 取消函数。\nsource.cancel('哎呀，我被若川取消了');\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"551-取消请求模块代码示例",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#551-取消请求模块代码示例",children:"#"}),"5.5.1 取消请求模块代码示例"]}),"\n",(0,s.jsxs)(n.p,{children:["结合源码取消流程大概是这样的。这段放在代码在",(0,s.jsx)(n.code,{children:"axios/examples/cancel-token/index.html"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["参数的 ",(0,s.jsx)(n.code,{children:"config.cancelToken"})," 是触发了",(0,s.jsx)(n.code,{children:"source.cancel('哎呀，我被若川取消了');"}),"才生成的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// source.cancel('哎呀，我被若川取消了');\n// 点击取消时才会 生成 cancelToken 实例对象。\n// 点击取消后，会生成原因，看懂了这段在看之后的源码，可能就好理解了。\nvar config = {\n  name: '若川',\n  // 这里简化了\n  cancelToken: {\n        promise: new Promise(function(resolve){\n            resolve({ message: '哎呀，我被若川取消了'})\n        }),\n        reason: { message: '哎呀，我被若川取消了' }\n  },\n};\n// 取消 抛出异常方法\nfunction throwIfCancellationRequested(config){\n  // 取消的情况下执行这句\n  if(config.cancelToken){\n    //   这里源代码 便于执行，我改成具体代码\n    // config.cancelToken.throwIfRequested();\n    // if (this.reason) {\n    //     throw this.reason;\n    //   }\n    if(config.cancelToken.reason){\n        throw config.cancelToken.reason;\n    }\n  }\n}\n\nfunction dispatchRequest(config){\n  // 有可能是执行到这里就取消了，所以抛出错误会被err2 捕获到\n  throwIfCancellationRequested(config);\n  //  adapter xhr适配器\n  return new Promise((resovle, reject) => {\n    var request = new XMLHttpRequest();\n    console.log('request', request);\n    if (config.cancelToken) {\n        // Handle cancellation\n        config.cancelToken.promise.then(function onCanceled(cancel) {\n            if (!request) {\n                return;\n            }\n\n            request.abort();\n            reject(cancel);\n            // Clean up request\n            request = null;\n        });\n    }\n  })\n  .then(function(res){\n    // 有可能是执行到这里就才取消 取消的情况下执行这句\n    throwIfCancellationRequested(config);\n    console.log('res', res);\n    return res;\n  })\n  .catch(function(reason){\n    // 有可能是执行到这里就才取消 取消的情况下执行这句\n    throwIfCancellationRequested(config);\n    console.log('reason', reason);\n    return Promise.reject(reason);\n  });\n}\n\nvar promise = Promise.resolve(config);\n\n// 没设置拦截器的情况下是这样的\npromise\n.then(dispatchRequest, undefined)\n// 用户定义的then 和 catch\n.then(function(res){\n  console.log('res1', res);\n  return res;\n})\n.catch(function(err){\n  console.log('err2', err);\n  return Promise.reject(err);\n});\n// err2 {message: \"哎呀，我被若川取消了\"}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"552-接下来看取消模块的源码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#552-接下来看取消模块的源码",children:"#"}),"5.5.2 接下来看取消模块的源码"]}),"\n",(0,s.jsxs)(n.p,{children:["看如何通过生成",(0,s.jsx)(n.code,{children:"config.cancelToken"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"文件路径："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"axios/lib/cancel/CancelToken.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\nsource.cancel('哎呀，我被若川取消了');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["由示例看 ",(0,s.jsx)(n.code,{children:"CancelToken.source"}),"的实现，"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"CancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  // token\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["执行后",(0,s.jsx)(n.code,{children:"source"}),"的大概结构是这样的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n    token: {\n    promise: new Promise(function(resolve){\n      resolve({ message: '哎呀，我被若川取消了'})\n    }),\n    reason: { message: '哎呀，我被若川取消了' }\n  },\n  cancel: function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      // 已经取消\n      return;\n    }\n    token.reason = {message: '哎呀，我被若川取消了'};\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接着看 ",(0,s.jsx)(n.code,{children:"new CancelToken"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// CancelToken\n// 通过 CancelToken 来取消请求操作\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      // 已经取消\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\nmodule.exports = CancelToken;\n"})}),"\n",(0,s.jsx)(n.p,{children:"发送请求的适配器里是这样使用的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// xhr\nif (config.cancelToken) {\n  // Handle cancellation\n  config.cancelToken.promise.then(function onCanceled(cancel) {\n    if (!request) {\n      return;\n    }\n\n    request.abort();\n    reject(cancel);\n    // Clean up request\n    request = null;\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dispatchRequest"})," 中的",(0,s.jsx)(n.code,{children:"throwIfCancellationRequested"}),"具体实现：throw 抛出异常。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 抛出异常函数\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n// 抛出异常 用户 { message: '哎呀，我被若川取消了' }\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"取消流程调用栈"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.source.cancel()","\n2.resolvePromise(token.reason);","\n3.config.cancelToken.promise.then(function onCanceled(cancel) {})"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["最后进入",(0,s.jsx)(n.code,{children:"request.abort();``reject(cancel);"})]}),"\n",(0,s.jsxs)(n.p,{children:["到这里取消的流程就介绍完毕了。主要就是通过传递配置参数",(0,s.jsx)(n.code,{children:"cancelToken"}),"，取消时才会生成",(0,s.jsx)(n.code,{children:"cancelToken"}),"，判断有，则抛出错误，使",(0,s.jsx)(n.code,{children:"Promise"})," 走向",(0,s.jsx)(n.code,{children:"rejected"}),"，让用户捕获到消息{message: '用户设置的取消信息'}。"]}),"\n",(0,s.jsx)(n.p,{children:"文章写到这里就基本到接近尾声了。"}),"\n",(0,s.jsx)(n.p,{children:"能读到最后，说明你已经超过很多人啦^_^"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios"}),"是非常优秀的请求库，但肯定也不能满足所有开发者的需求，接下来对比下其他库，看看其他开发者有什么具体需求。"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-对比其他请求库",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-对比其他请求库",children:"#"}),"6. 对比其他请求库"]}),"\n",(0,s.jsxs)(n.h3,{id:"61-koajax",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-koajax",children:"#"}),"6.1 KoAjax"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fCC"}),"成都社区负责人水歌开源的",(0,s.jsx)(n.a,{href:"https://github.com/EasyWebApp/KoAJAX",rel:"noopener noreferrer",target:"_blank",children:"KoAJAX"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/hxCwiokl4uPXJscTQi42-A",rel:"noopener noreferrer",target:"_blank",children:"如何用开源软件办一场技术大会？"}),"\n以下这篇文章中摘抄的一段。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"前端请求库 —— KoAJAX\n国内前端同学最常用的 HTTP 请求库应该是 axios 了吧？虽然它的 Interceptor（拦截器）API 是 .use()，但和 Node.js 的 Express、Koa 等框架的中间件模式完全不同，相比 jQuery .ajaxPrefilter()、dataFilter() 并没什么实质改进；上传、下载进度比 jQuery.Deferred() 还简陋，只是两个专门的回调选项。所以，它还是要对特定的需求记忆特定的 API，不够简洁。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["幸运的是，水歌在研究如何",(0,s.jsx)(n.a,{href:"https://tech-query.me/onion-stack/",rel:"noopener noreferrer",target:"_blank",children:"用 ES 2018 异步迭代器实现一个类 Koa 中间件引擎"}),"的过程中，做出了一个更有实际价值的上层应用 —— KoAJAX。它的整个执行过程基于 Koa 式的中间件，而且它自己就是一个中间件调用栈。除了 RESTful API 常用的 .get()、.post()、.put()、.delete() 等快捷方法外，开发者就只需记住 .use() 和 next()，其它都是 ES 标准语法和 TS 类型推导。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"62-umi-request-阿里开源的请求库",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-umi-request-阿里开源的请求库",children:"#"}),"6.2 umi-request 阿里开源的请求库"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/umijs/umi-request/blob/master/README_zh-CN.md",rel:"noopener noreferrer",target:"_blank",children:"umi-request github 仓库"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"umi-request"})," 与 ",(0,s.jsx)(n.code,{children:"fetch"}),", ",(0,s.jsx)(n.code,{children:"axios"})," 异同。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"umi-request 与 fetch, axios 异同",src:d})}),"\n",(0,s.jsxs)(n.p,{children:["不得不说，",(0,s.jsx)(n.code,{children:"umi-request"})," 确实强大，有兴趣的读者可以阅读下其源码。"]}),"\n",(0,s.jsxs)(n.p,{children:["看懂",(0,s.jsx)(n.code,{children:"axios"}),"的基础上，看懂",(0,s.jsx)(n.code,{children:"umi-request"}),"源码应该不难。"]}),"\n",(0,s.jsxs)(n.p,{children:["比如 ",(0,s.jsx)(n.code,{children:"umi-request"})," 取消模块代码几乎与",(0,s.jsx)(n.code,{children:"axios"}),"一模一样。"]}),"\n",(0,s.jsxs)(n.h2,{id:"7-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-总结",children:"#"}),"7. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["文章详细介绍了 ",(0,s.jsx)(n.code,{children:"axios"})," 调试方法。详细介绍了 ",(0,s.jsx)(n.code,{children:"axios"})," 构造函数，拦截器，取消等功能的实现。最后还对比了其他请求库。"]}),"\n",(0,s.jsx)(n.p,{children:"最后画个图总结一下axios的总体大致流程。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"axios的总体大致流程",src:l})}),"\n",(0,s.jsx)(n.p,{children:"解答下文章开头提的问题："}),"\n",(0,s.jsxs)(n.p,{children:["如果你是求职者，项目写了运用了",(0,s.jsx)(n.code,{children:"axios"}),"，面试官可能会问你："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["1.为什么 ",(0,s.jsx)(n.code,{children:"axios"})," 既可以当函数调用，也可以当对象使用，比如",(0,s.jsx)(n.code,{children:"axios({})"}),"、",(0,s.jsx)(n.code,{children:"axios.get"}),"。","\n答：",(0,s.jsx)(n.code,{children:"axios"}),"本质是函数，赋值了一些别名方法，比如",(0,s.jsx)(n.code,{children:"get"}),"、",(0,s.jsx)(n.code,{children:"post"}),"方法，可被调用，最终调用的还是",(0,s.jsx)(n.code,{children:"Axios.prototype.request"}),"函数。","\n2.简述 ",(0,s.jsx)(n.code,{children:"axios"})," 调用流程。","\n答：实际是调用的",(0,s.jsx)(n.code,{children:"Axios.prototype.request"}),"方法，最终返回的是",(0,s.jsx)(n.code,{children:"promise"}),"链式调用，实际请求是在",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"中派发的。","\n3.有用过拦截器吗？原理是怎样的？","\n答：用过，用",(0,s.jsx)(n.code,{children:"axios.interceptors.request.use"}),"添加请求成功和失败拦截器函数，用",(0,s.jsx)(n.code,{children:"axios.interceptors.response.use"}),"添加响应成功和失败拦截器函数。在",(0,s.jsx)(n.code,{children:"Axios.prototype.request"}),"函数组成",(0,s.jsx)(n.code,{children:"promise"}),"链式调用时，",(0,s.jsx)(n.code,{children:"Interceptors.protype.forEach"}),"遍历请求和响应拦截器添加到真正发送请求",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"的两端，从而做到请求前拦截和响应后拦截。拦截器也支持用",(0,s.jsx)(n.code,{children:"Interceptors.protype.eject"}),"方法移除。","\n4.有使用",(0,s.jsx)(n.code,{children:"axios"}),"的取消功能吗？是怎么实现的？","\n答：用过，通过传递",(0,s.jsx)(n.code,{children:"config"}),"配置",(0,s.jsx)(n.code,{children:"cancelToken"}),"的形式，来取消的。判断有传",(0,s.jsx)(n.code,{children:"cancelToken"}),"，在",(0,s.jsx)(n.code,{children:"promise"}),"链式调用的",(0,s.jsx)(n.code,{children:"dispatchRequest"}),"抛出错误，在",(0,s.jsx)(n.code,{children:"adapter"}),"中",(0,s.jsx)(n.code,{children:"request.abort()"}),"取消请求，使",(0,s.jsx)(n.code,{children:"promise"}),"走向",(0,s.jsx)(n.code,{children:"rejected"}),"，被用户捕获取消信息。","\n5.为什么支持浏览器中发送请求也支持",(0,s.jsx)(n.code,{children:"node"}),"发送请求？","\n答：",(0,s.jsx)(n.code,{children:"axios.defaults.adapter"}),"默认配置中根据环境判断是浏览器还是",(0,s.jsx)(n.code,{children:"node"}),"环境，使用对应的适配器。适配器支持自定义。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"回答面试官的问题，读者也可以根据自己的理解，组织语言，笔者的回答只是做一个参考。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios"})," 源码相对不多，打包后一千多行，比较容易看完，非常值得学习。"]}),"\n",(0,s.jsxs)(n.p,{children:["建议 ",(0,s.jsx)(n.code,{children:"clone"})," ",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/axios-analysis",rel:"noopener noreferrer",target:"_blank",children:"若川的 axios-analysis github 仓库"}),"，按照文中方法自己调试，印象更深刻。"]}),"\n",(0,s.jsxs)(n.p,{children:["基于",(0,s.jsx)(n.code,{children:"Promise"}),"，构成",(0,s.jsx)(n.code,{children:"Promise"}),"链，巧妙的设置请求拦截，发送请求，再试试响应拦截器。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"request"}),"中的拦截器和",(0,s.jsx)(n.code,{children:"dispatch"}),"中的取消这两个模块相对复杂，可以多调试调试，吸收消化。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios"})," 既是函数，是函数时调用的是",(0,s.jsx)(n.code,{children:"Axios.prototype.request"}),"函数，又是对象，其上面有",(0,s.jsx)(n.code,{children:"get"}),"、",(0,s.jsx)(n.code,{children:"post"}),"等请求方法，最终也是调用",(0,s.jsx)(n.code,{children:"Axios.prototype.request"}),"函数。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"axios"})," 源码中使用了挺多设计模式。比如工厂模式、迭代器模式、适配器模式等。如果想系统学习设计模式，一般比较推荐豆瓣评分9.1的",(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/26382780/",rel:"noopener noreferrer",target:"_blank",children:"JavaScript设计模式与开发实践"})]}),"\n",(0,s.jsx)(n.p,{children:"如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持，非常感谢呀。"}),"\n",(0,s.jsxs)(n.h2,{id:"推荐阅读",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#推荐阅读",children:"#"}),"推荐阅读"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/axios/axios",rel:"noopener noreferrer",target:"_blank",children:"官方axios github 仓库"})}),"\n",(0,s.jsx)(n.p,{children:"写文章前，搜索了以下几篇文章泛读了一下。有兴趣再对比看看以下这几篇，有代码调试的基础上，看起来也快。"}),"\n",(0,s.jsx)(n.p,{children:"一直觉得多搜索几篇文章看，对自己学习知识更有用。有个词语叫主题阅读。大概意思就是一个主题一系列阅读。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://juejin.im/post/5cb5d9bde51d456e62545abc",rel:"noopener noreferrer",target:"_blank",children:"@叫我小明呀：Axios 源码解析"}),"\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/37962469",rel:"noopener noreferrer",target:"_blank",children:"@尼库尼库桑：深入浅出 axios 源码"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5b0ba2d56fb9a00a1357a334",rel:"noopener noreferrer",target:"_blank",children:"@小贼先生_ronffy：Axios源码深度剖析 - AJAX新王者"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d501512518825159e3d7be6",rel:"noopener noreferrer",target:"_blank",children:"逐行解析Axios源码"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5d906269f265da5ba7451b02",rel:"noopener noreferrer",target:"_blank",children:"[译]axios 是如何封装 HTTP 请求的"}),"\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/50859466",rel:"noopener noreferrer",target:"_blank",children:"知乎@Lee : TypeScript 重构 Axios 经验分享"})]}),"\n",(0,s.jsxs)(n.h2,{id:"笔者另一个系列",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔者另一个系列",children:"#"}),"笔者另一个系列"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n",(0,s.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"})]}),"\n",(0,s.jsxs)(n.h2,{id:"关于",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，使用",(0,s.jsx)(n.code,{children:"vuepress"}),"重构了，阅读体验可能更好些","\n",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,s.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://www.yuque.com/lxchuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"语雀前端视野专栏"}),"，新增语雀专栏，欢迎关注~","\n",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,s.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,s.jsxs)(n.h2,{id:"欢迎加微信交流-微信公众号",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#欢迎加微信交流-微信公众号",children:"#"}),"欢迎加微信交流 微信公众号"]}),"\n",(0,s.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注（",(0,s.jsx)(n.strong,{children:"回复pdf获取前端优质书籍pdf"}),"）。欢迎加笔者微信",(0,s.jsx)(n.code,{children:"ruochuan12"}),"（注明来源，基本来者不拒），拉您进【前端视野交流群】，长期交流学习~"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://github.com/ruochuan12/blog/raw/master/docs/about/wechat-official-accounts-mini.jpg",alt:"若川视野"})})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(h,e)})):h(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["axios%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-chrome-和-vscode-调试-axios-源码方法",text:"2. chrome 和 vscode 调试 axios 源码方法",depth:2},{id:"21-chrome-调试浏览器环境的-axios",text:"2.1 chrome 调试浏览器环境的 axios",depth:3},{id:"22-vscode-调试-node-环境的-axios",text:"2.2 vscode 调试 node 环境的 axios",depth:3},{id:"3-先看-axios-结构是怎样的",text:"3. 先看 axios 结构是怎样的",depth:2},{id:"4-axios-源码-初始化",text:"4. axios 源码 初始化",depth:2},{id:"41libaxiosjs主文件",text:"4.1`lib/axios.js`主文件",depth:3},{id:"411-第一部分",text:"4.1.1 第一部分",depth:4},{id:"412-第二部分",text:"4.1.2 第二部分",depth:4},{id:"413-工具方法之-bind",text:"4.1.3 工具方法之 bind",depth:4},{id:"414-工具方法之-utilsextend",text:"4.1.4 工具方法之 utils.extend",depth:4},{id:"415-工具方法之-utilsforeach",text:"4.1.5 工具方法之 utils.forEach",depth:4},{id:"416-第三部分",text:"4.1.6 第三部分",depth:4},{id:"42-核心构造函数-axios",text:"4.2 核心构造函数 Axios",depth:3},{id:"43-拦截器管理构造函数-interceptormanager",text:"4.3 拦截器管理构造函数 InterceptorManager",depth:3},{id:"431-interceptormanagerprototypeuse-使用",text:"4.3.1 InterceptorManager.prototype.use 使用",depth:4},{id:"432-interceptormanagerprototypeeject-移除",text:"4.3.2 InterceptorManager.prototype.eject 移除",depth:4},{id:"433-interceptormanagerprototypeforeach-遍历",text:"4.3.3 InterceptorManager.prototype.forEach 遍历",depth:4},{id:"5-实例结合",text:"5. 实例结合",depth:2},{id:"51-先看调用栈流程",text:"5.1 先看调用栈流程",depth:3},{id:"52-axiosprototyperequest-请求核心方法",text:"5.2 Axios.prototype.request 请求核心方法",depth:3},{id:"521-组成promise链返回promise实例",text:"5.2.1 组成`Promise`链，返回`Promise`实例",depth:4},{id:"53-dispatchrequest-最终派发请求",text:"5.3 dispatchRequest 最终派发请求",depth:3},{id:"531-dispatchrequest-之-transformdata-转换数据",text:"5.3.1 dispatchRequest 之 transformData 转换数据",depth:4},{id:"532-dispatchrequest-之-adapter-适配器执行部分",text:"5.3.2 dispatchRequest 之 adapter 适配器执行部分",depth:4},{id:"54-adapter-适配器-真正发送请求",text:"5.4 adapter 适配器 真正发送请求",depth:3},{id:"55-dispatchrequest-之-取消模块",text:"5.5 dispatchRequest 之 取消模块",depth:3},{id:"551-取消请求模块代码示例",text:"5.5.1 取消请求模块代码示例",depth:4},{id:"552-接下来看取消模块的源码",text:"5.5.2 接下来看取消模块的源码",depth:4},{id:"6-对比其他请求库",text:"6. 对比其他请求库",depth:2},{id:"61-koajax",text:"6.1 KoAjax",depth:3},{id:"62-umi-request-阿里开源的请求库",text:"6.2 umi-request 阿里开源的请求库",depth:3},{id:"7-总结",text:"7. 总结",depth:2},{id:"推荐阅读",text:"推荐阅读",depth:2},{id:"笔者另一个系列",text:"笔者另一个系列",depth:2},{id:"关于",text:"关于",depth:2},{id:"欢迎加微信交流-微信公众号",text:"欢迎加微信交流 微信公众号",depth:2}],title:"学习 axios 源码整体架构，打造属于自己的请求库",headingTitle:"学习 axios 源码整体架构，打造属于自己的请求库",frontmatter:{}}},20713:function(e,n,r){r.d(n,{Z:()=>t});var s=r(52676),c=r(75271),o=r(92815);r(18544);let i={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,r){let s=Object.keys(i).includes(n)?n:r;return i[s](e)}let t=e=>{let{defaultLocale:n="en-US"}=e,r=(0,o.Vi)().page.readingTimeData,i=(0,o.Jr)(),t=(0,o.e7)(),[d,l]=(0,c.useState)(a(r,i,n));return(0,c.useEffect)(()=>{l(a(r,i,n))},[i,r]),(0,s.jsx)("span",{"data-dark":String(t),className:"rp-reading-time",children:d})}}}]);