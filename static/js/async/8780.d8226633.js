"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["8780"],{27741:function(e,r,n){n.r(r),n.d(r,{default:()=>p});var s=n(52676),t=n(40453),i=n(20713);let c=n.p+"static/image/addInterceptor.7030d237.png",a=n.p+"static/image/clearInterceptor.5af2e5ad.png",o=n.p+"static/image/dir.555cd8ed.png",d=n.p+"static/image/debugger.48114b77.png";function l(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",input:"input",blockquote:"blockquote",pre:"pre",img:"img",h3:"h3",strong:"strong",hr:"hr"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"taro-源码揭秘7-tarorequest-和请求响应拦截器是如何实现的",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘7-tarorequest-和请求响应拦截器是如何实现的",children:"#"}),"Taro 源码揭秘：7. Taro.request 和请求响应拦截器是如何实现的"]}),"\n",(0,s.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(r.h2,{id:"1-前言",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(r.p,{children:["大家好，我是",(0,s.jsx)(r.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,s.jsx)(r.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(r.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(r.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(r.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,s.jsxs)(r.p,{children:["截至目前（",(0,s.jsx)(r.code,{children:"2024-09-18"}),"），",(0,s.jsxs)(r.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.3",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(r.code,{children:"taro 4.0"})," 正式版已经发布"]}),"，目前最新是 ",(0,s.jsx)(r.code,{children:"4.0.5"}),"，官方",(0,s.jsx)(r.code,{children:"4.0"}),"正式版本的介绍文章暂未发布。官方之前发过",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,s.jsx)(r.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,s.jsx)(r.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,s.jsxs)(r.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,s.jsxs)(r.li,{className:"task-list-item",children:[(0,s.jsx)(r.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。第 7 篇我们来讲些相对简单的，Taro.request 和请求响应拦截器是如何实现的？文章以微信小程序为例。"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["关于请求响应拦截器，我曾在 2019年 写过 ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/6844904019987529735#heading-21",rel:"noopener noreferrer",target:"_blank",children:"axios 源码文章"}),"（575赞、761收藏、2.5w阅读），还画了 ",(0,s.jsx)(r.code,{children:"axios"})," 拦截器的图。虽然之前文章写的版本是",(0,s.jsx)(r.code,{children:"v0.19.x"})," ，但是相比现在的源码整体结构基本没有太大变化，感兴趣的可以看看。"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["关于克隆项目、环境准备、如何调试代码等，参考",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章-准备工作、调试"}),"。后续文章基本不再过多赘述。"]}),"\n",(0,s.jsx)(r.p,{children:"学完本文，你将学到："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"1. Taro.request 的实现\n2. Taro.addInterceptor 请求和响应拦截器的使用和具体实现\n等等\n"})}),"\n",(0,s.jsxs)(r.p,{children:["我们先来看文档，熟悉 ",(0,s.jsx)(r.code,{children:"Taro.request"})," 的使用。"]}),"\n",(0,s.jsxs)(r.h2,{id:"2-taro-request-相关文档",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2-taro-request-相关文档",children:"#"}),"2. Taro request 相关文档"]}),"\n",(0,s.jsx)(r.p,{children:"平常业务开发"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"import Taro from '@tarojs/taro'\n\nTaro.request(url).then(function (res) {\n  console.log(res)\n})\n"})}),"\n",(0,s.jsxs)(r.p,{children:["我们来看下 ",(0,s.jsx)(r.code,{children:"Taro"})," 拦截器相关的文档："]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{alt:"添加拦截器",src:c})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Taro.addInterceptor"})," 示例代码1"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"const interceptor = function (chain) {\n  const requestParams = chain.requestParams\n  const { method, data, url } = requestParams\n\n  console.log(`http ${method || 'GET'} --\x3e ${url} data: `, data)\n\n  return chain.proceed(requestParams)\n    .then(res => {\n      console.log(`http <-- ${url} result:`, res)\n      return res\n    })\n  }\nTaro.addInterceptor(interceptor)\nTaro.request({ url })\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsxs)(r.a,{href:"https://taro-docs.jd.com/docs/next/apis/network/request/addInterceptor",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(r.code,{children:"Taro.addInterceptor"}),"文档"]})," 示例代码2"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"Taro.addInterceptor(Taro.interceptors.logInterceptor)\nTaro.addInterceptor(Taro.interceptors.timeoutInterceptor)\nTaro.request({ url })\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{alt:"清除所有拦截器",src:a})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Taro.cleanInterceptors"})," 清除所有拦截器"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"Taro.cleanInterceptors()\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"@tarojs/taro"})," 对应的源码。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro/index.js\nconst { hooks } = require('@tarojs/runtime')\nconst taro = require('@tarojs/api').default\n\nif (hooks.isExist('initNativeApi')) {\n  hooks.call('initNativeApi', taro)\n}\n\nmodule.exports = taro\nmodule.exports.default = module.exports\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"@tarojs/api"})," 源码暂时先不讲述。"]}),"\n",(0,s.jsxs)(r.p,{children:["我们来回顾下上篇文章中 ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7407648740926291968#heading-11",rel:"noopener noreferrer",target:"_blank",children:"Taro 源码揭秘 - 6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(r.p,{children:["在端平台插件运行时 ",(0,s.jsx)(r.code,{children:"runtime"})," 中，",(0,s.jsx)(r.code,{children:"mergeReconciler(hostConfig)"})," ",(0,s.jsx)(r.code,{children:"hooks.tap"})," 注册事件 ",(0,s.jsx)(r.code,{children:"initNativeApi"}),"。\n",(0,s.jsx)(r.code,{children:"hostConfig"})," 对象中有 ",(0,s.jsx)(r.code,{children:"initNativeApi"})," 函数\n",(0,s.jsx)(r.code,{children:"initNativeApi"})," 函数中调用了 ",(0,s.jsx)(r.code,{children:"processApis"})," 函数。\n",(0,s.jsx)(r.code,{children:"processApis"})," 中调用了 ",(0,s.jsx)(r.code,{children:"equipCommonApis"})," 这个函数挂载常用的apis。"]}),"\n",(0,s.jsxs)(r.h2,{id:"3-equipcommonapis-挂载公共-apis",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3-equipcommonapis-挂载公共-apis",children:"#"}),"3. equipCommonApis 挂载公共 apis"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\n/**\n * 挂载常用 API\n * @param taro Taro 对象\n * @param global 小程序全局对象，如微信的 wx，支付宝的 my\n */\nfunction equipCommonApis (taro, global, apis: Record<string, any> = {}) {\n  // 省略若干代码\n  // 添加 request 和拦截器\n  // request & interceptors\n  const request = apis.request || getNormalRequest(global)\n  function taroInterceptor (chain) {\n    return request(chain.requestParams)\n  }\n  const link = new taro.Link(taroInterceptor)\n  taro.request = link.request.bind(link)\n  taro.addInterceptor = link.addInterceptor.bind(link)\n  taro.cleanInterceptors = link.cleanInterceptors.bind(link)\n  //   省略若干代码\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"你可能会问："}),"\n",(0,s.jsxs)(r.p,{children:["我们接着来看 ",(0,s.jsx)(r.code,{children:"getNormalRequest"})," 是怎么实现的？"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"taro.Link"})," 哪来的，为什么把  ",(0,s.jsx)(r.code,{children:"taroInterceptor"})," 函数传递给它。\n",(0,s.jsx)(r.code,{children:"link"})," 是 ",(0,s.jsx)(r.code,{children:"Link"})," 的实例对象。\n",(0,s.jsx)(r.code,{children:"taro.request"})," 是 ",(0,s.jsx)(r.code,{children:"link.request"}),"\n",(0,s.jsx)(r.code,{children:"taro.addInterceptor"})," 是 ",(0,s.jsx)(r.code,{children:"link.addInterceptor"}),"\n",(0,s.jsx)(r.code,{children:"taro.cleanInterceptors"})," 是 ",(0,s.jsx)(r.code,{children:"link.cleanInterceptors"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["我们接着先来看 ",(0,s.jsx)(r.code,{children:"getNormalRequest"})," 的代码实现，再看 ",(0,s.jsx)(r.code,{children:"Link"})," 的代码实现。寻找问题的答案。"]}),"\n",(0,s.jsxs)(r.h3,{id:"31-getnormalrequest-获取标准的-request",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#31-getnormalrequest-获取标准的-request",children:"#"}),"3.1 getNormalRequest 获取标准的 request"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"getNormalRequest"})," 返回一个 ",(0,s.jsx)(r.code,{children:"request"})," 函数，",(0,s.jsx)(r.code,{children:"request"})," 函数返回的是 ",(0,s.jsx)(r.code,{children:"promise"}),"。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\nfunction getNormalRequest (global) {\n  return function request (options) {\n	// 第一步：先是处理下 options，有值，如果是字符串传入url，不是就直接返回 options\n	// 没有值赋值空对象\n    options = options\n      ? (\n        isString(options)\n          ? { url: options }\n          : options\n      )\n      : {}\n\n    const originSuccess = options.success\n    const originFail = options.fail\n    const originComplete = options.complete\n\n	// 第二步：声明 requestTask 和 promise\n    let requestTask\n    const p: any = new Promise((resolve, reject) => {\n      options.success = res => {\n        originSuccess && originSuccess(res)\n        resolve(res)\n      }\n      options.fail = res => {\n        originFail && originFail(res)\n        reject(res)\n      }\n\n      options.complete = res => {\n        originComplete && originComplete(res)\n      }\n\n	  // 参数传入 global.request ，global 是 wx、my 等\n      requestTask = global.request(options)\n    })\n\n	// 第三步：将Task对象中的方法挂载到 promise 对象中，适配小程序 api 原生返回结果\n    equipTaskMethodsIntoPromise(requestTask, p)\n\n	// 第四步：取消，调用 task 的取消\n    p.abort = (cb) => {\n      cb && cb()\n      if (requestTask) {\n        requestTask.abort()\n      }\n      return p\n    }\n	// 最后返回 promise，也就是为什么可以调用 Taro.request then、catch 方法\n    return p\n  }\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"getNormalRequest"})," 的实现步骤："]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"第一步：先是处理下 options，有值，如果是字符串传入url，不是就直接返回 options"}),"\n",(0,s.jsx)(r.li,{children:"第二步：声明 requestTask 和 promise"}),"\n",(0,s.jsx)(r.li,{children:"第三步：将 Task 对象中的方法挂载到 promise 对象中，适配小程序 api 原生返回结果"}),"\n",(0,s.jsx)(r.li,{children:"第四步：取消，调用 task 的取消"}),"\n",(0,s.jsx)(r.li,{children:"最后返回 promise，也就是为什么可以调用 Taro.request then、catch 方法"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["其中调用了 ",(0,s.jsx)(r.code,{children:"equipTaskMethodsIntoPromise"})," 方法，我们简单看下这个方法的实现："]}),"\n",(0,s.jsxs)(r.h3,{id:"32-equiptaskmethodsintopromise-适配小程序-api-原生返回结果",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#32-equiptaskmethodsintopromise-适配小程序-api-原生返回结果",children:"#"}),"3.2 equipTaskMethodsIntoPromise 适配小程序 api 原生返回结果"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"equipTaskMethodsIntoPromise"})," 方法的实现如下："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\n/**\n * 将Task对象中的方法挂载到promise对象中，适配小程序api原生返回结果\n * @param task Task对象 {RequestTask | DownloadTask | UploadTask}\n * @param promise Promise\n */\nfunction equipTaskMethodsIntoPromise (task, promise) {\n  if (!task || !promise) return\n  const taskMethods = ['abort', 'onHeadersReceived', 'offHeadersReceived', 'onProgressUpdate', 'offProgressUpdate', 'onChunkReceived', 'offChunkReceived']\n  task && taskMethods.forEach(method => {\n    if (method in task) {\n      promise[method] = task[method].bind(task)\n    }\n  })\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - wx.uploadFile"})," |\n",(0,s.jsx)(r.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/UploadTask.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - 返回值 UploadTask"})," |\n",(0,s.jsx)(r.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/download/wx.downloadFile.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - wx.downloadFile"})," |\n",(0,s.jsx)(r.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/download/DownloadTask.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - 返回值 DownloadTask"})," |"]}),"\n",(0,s.jsxs)(r.p,{children:["看完了 ",(0,s.jsx)(r.code,{children:"getNormalRequest"})," 的实现，我们接着来看 ",(0,s.jsx)(r.code,{children:"Link"})," 的具体实现，我们可以知道 ",(0,s.jsx)(r.code,{children:"new taro.Link"})," 必定是在 ",(0,s.jsx)(r.code,{children:"@tarojs/taro"})," 实现的。 文章开头没有展开讲述的 ",(0,s.jsx)(r.code,{children:"@tarojs/api"}),"。"]}),"\n",(0,s.jsxs)(r.h2,{id:"4-tarojsapi-所有端的公共-api",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#4-tarojsapi-所有端的公共-api",children:"#"}),"4. @tarojs/api 所有端的公共 API"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["暴露给 @tarojs/taro 的所有端的公有 API。",(0,s.jsx)(r.code,{children:"@tarojs/api"})," 会跨 node/浏览器/小程序/React Native 使用，不得使用/包含平台特有特性。"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["我们来看下 ",(0,s.jsx)(r.code,{children:"@tarojs/api"})," 目录，如下图所示："]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{alt:"@tarojs/api 目录",src:o})}),"\n",(0,s.jsxs)(r.p,{children:["入口文件 ",(0,s.jsx)(r.code,{children:"packages/taro-api/src/index.ts"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["再就是拦截器实现的文件夹 ",(0,s.jsx)(r.code,{children:"packages/taro-api/src/interceptor/"}),"。"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"packages/taro-api/src/interceptor/index.ts 入口"}),"\n",(0,s.jsx)(r.li,{children:"packages/taro-api/src/interceptor/interceptor/chain.ts 链"}),"\n",(0,s.jsx)(r.li,{children:"packages/taro-api/src/interceptor/interceptor/interceptors.ts 内置的拦截器"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["我们先来看 ",(0,s.jsx)(r.code,{children:"@tarojs/api"})," 的入口文件。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro-api/src/index.ts\n\n/* eslint-disable camelcase */\n// 省略若干代码\nimport Link, { interceptorify } from './interceptor'\nimport * as interceptors from './interceptor/interceptors'\n\nconst Taro: Record<string, unknown> = {\n  Link,\n  interceptors,\n  interceptorify,\n}\n\nexport default Taro\n"})}),"\n",(0,s.jsxs)(r.p,{children:["从 ",(0,s.jsx)(r.code,{children:"interceptor"})," 导出 ",(0,s.jsx)(r.code,{children:"Link、interceptorify"}),"、",(0,s.jsx)(r.code,{children:"interceptor/interceptors"})," 导出所有内置拦截器，赋值到 ",(0,s.jsx)(r.code,{children:"Taro"})," 上。"]}),"\n",(0,s.jsxs)(r.h2,{id:"5-link-构造函数",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#5-link-构造函数",children:"#"}),"5. Link 构造函数"]}),"\n",(0,s.jsxs)(r.h3,{id:"51-拦截器入口文件-srcinterceptorindexts",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#51-拦截器入口文件-srcinterceptorindexts",children:"#"}),"5.1 拦截器入口文件 src/interceptor/index.ts"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro-api/src/interceptor/index.ts\nimport Chain from './chain'\n\nimport type { IRequestParams, TInterceptor } from './chain'\n\nexport default class Link {\n  taroInterceptor: TInterceptor\n  chain: Chain\n\n  constructor (interceptor: TInterceptor) {\n	// 传入的拦截器是返回一个 promise 的函数\n    this.taroInterceptor = interceptor\n	// 初始化 Chain 实例对象\n    this.chain = new Chain()\n  }\n\n  request (requestParams: IRequestParams) {\n    // 省略，拆开下方讲述\n  }\n\n  // 添加拦截器\n  addInterceptor (interceptor: TInterceptor) {\n    this.chain.interceptors.push(interceptor)\n  }\n\n  // 清空拦截器\n  cleanInterceptors () {\n    this.chain = new Chain()\n  }\n}\n\n// 转换成 Taro 拦截器\nexport function interceptorify (promiseifyApi) {\n  return new Link(function (chain) {\n    return promiseifyApi(chain.requestParams)\n  })\n}\n\n"})}),"\n",(0,s.jsxs)(r.p,{children:["我们来看下 ",(0,s.jsx)(r.code,{children:"link.request"})," 的实现："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"export default class Link {\n  request (requestParams: IRequestParams) {\n    const chain = this.chain\n    const taroInterceptor = this.taroInterceptor\n\n    chain.interceptors = chain.interceptors\n      .filter(interceptor => interceptor !== taroInterceptor)\n      .concat(taroInterceptor)\n\n    return chain.proceed({ ...requestParams })\n  }\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Link"})," 实例对象的 ",(0,s.jsx)(r.code,{children:"request"})," 方法代码也不多，把传入的拦截器，放到最后。\n最后调用链的 ",(0,s.jsx)(r.code,{children:"proceed"})," 方法 ",(0,s.jsx)(r.code,{children:"chain.proceed"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["你可能会问，",(0,s.jsx)(r.code,{children:"chain"})," 是如何实现的呢。"]}),"\n",(0,s.jsxs)(r.p,{children:["那么我们来看 ",(0,s.jsx)(r.code,{children:"chain"})," 的具体实现："]}),"\n",(0,s.jsxs)(r.h3,{id:"52-链-srcinterceptorchaints",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#52-链-srcinterceptorchaints",children:"#"}),"5.2 链 src/interceptor/chain.ts"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["Taro文档：在调用 ",(0,s.jsx)(r.code,{children:"Taro.request"})," 发起请求之前，调用 ",(0,s.jsx)(r.code,{children:"Taro.addInterceptor"})," 方法为请求添加拦截器，拦截器的调用顺序遵循洋葱模型。 拦截器是一个函数，接受 ",(0,s.jsx)(r.code,{children:"chain"})," 对象作为参数。",(0,s.jsx)(r.code,{children:"chain"})," 对象中含有 ",(0,s.jsx)(r.code,{children:"requestParmas"})," 属性，代表请求参数。拦截器内最后需要调用 ",(0,s.jsx)(r.code,{children:"chain.proceed(requestParams)"})," 以调用下一个拦截器或发起请求。"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro-api/src/interceptor/chain.ts\n\nimport { isFunction } from '@tarojs/shared'\n\nexport type TInterceptor = (c: Chain) => Promise<void>\n\nexport interface IRequestParams {\n  timeout?: number\n  method?: string\n  url?: string\n  data?: unknown\n}\n\nexport default class Chain {\n  index: number\n  requestParams: IRequestParams\n  interceptors: TInterceptor[]\n\n  constructor (requestParams?: IRequestParams, interceptors?: TInterceptor[], index?: number) {\n	// 初始化三个参数，索引值，请求参数和存放拦截器的数组\n    this.index = index || 0\n    this.requestParams = requestParams || {}\n    this.interceptors = interceptors || []\n  }\n\n  proceed (requestParams: IRequestParams = {}) {\n	// 省略，拆开放到下方单独讲述\n  }\n\n  // 内部方法，取下一个拦截器\n  _getNextInterceptor () {\n    return this.interceptors[this.index]\n  }\n\n  // 内部方法，取下一个链\n  _getNextChain () {\n    return new Chain(this.requestParams, this.interceptors, this.index + 1)\n  }\n}\n\n"})}),"\n",(0,s.jsxs)(r.p,{children:["我们来看 ",(0,s.jsx)(r.code,{children:"chain.proceed"})," 方法的实现："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"export default class Chain {\n  proceed (requestParams: IRequestParams = {}) {\n	// 第一步：调用这个方法的参数赋值为请求参数\n    this.requestParams = requestParams\n	// 第二步：拦截器数量不对抛出错误\n    if (this.index >= this.interceptors.length) {\n      throw new Error('chain 参数错误, 请勿直接修改 request.chain')\n    }\n	// 第三步：取出下一个拦截器\n    const nextInterceptor = this._getNextInterceptor()\n	// 第四步：取出下一个链\n    const nextChain = this._getNextChain()\n	// 第六步：把下一个链作为参数传入到下一个拦截器调用，返回 promise\n    const p = nextInterceptor(nextChain)\n	// 第六步：捕获错误\n    const res = p.catch(err => Promise.reject(err))\n	// 第七步：遍历实例对象 promise，如果是函数就赋值到 res[k] = p[k];\n	// 这里其实是兼容小程序 api 原生返回结果 promise 对象上还有 abort 等函数方法。\n    Object.keys(p).forEach(k => isFunction(p[k]) && (res[k] = p[k]))\n	// 第八步：返回 res promise\n    return res\n  }\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"chain.proceed"})," 简单来说就是调用下一个拦截器函数（async）。"]}),"\n",(0,s.jsxs)(r.h2,{id:"6-借助项目提供的-jest-测试用例调试拦截器",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#6-借助项目提供的-jest-测试用例调试拦截器",children:"#"}),"6. 借助项目提供的 jest 测试用例调试拦截器"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"chain.proceed"})," 函数比较抽象，第一次看没有看懂很正常。"]}),"\n",(0,s.jsx)(r.p,{children:"我们可以借助项目中提供的测试用例进行调试。"}),"\n",(0,s.jsxs)(r.p,{children:["我们很容易就找到了拦截器的测试用例文件：",(0,s.jsx)(r.code,{children:"packages/taro-api/__tests__/interceptorify.test.ts"}),"。我们来看测试用例的具体代码："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro-api/__tests__/interceptorify.test.ts\nimport Taro from '@tarojs/taro'\n\ndescribe('taro interceptorify', () => {\n  it('onion competency model', async () => {\n    interface IParams {\n      msg: string\n    }\n	// 转为拦截器，相当于是 wx.request\n    const execLink = Taro.interceptorify<IParams, IParams>(async function (requestParams) {\n      requestParams.msg += '__exec'\n      return requestParams\n    })\n	// 添加拦截器1\n    execLink.addInterceptor(async function (chain) {\n      chain.requestParams.msg += '__before1'\n      const params = await chain.proceed(chain.requestParams)\n      params.msg += '__after1'\n      return params\n    })\n	// 添加拦截器2\n    execLink.addInterceptor(async function (chain) {\n      chain.requestParams.msg += '__before2'\n      const params = await chain.proceed(chain.requestParams)\n      params.msg += '__after2'\n      return params\n    })\n	// 添加拦截器3\n    execLink.addInterceptor(async function (chain) {\n      chain.requestParams.msg += '__before3'\n      const params = await chain.proceed(chain.requestParams)\n      params.msg += '__after3'\n      return params\n    })\n	// 执行 request 把拦截器串联起来\n    const res1 = await execLink.request({ msg: 'test1' })\n    expect(res1.msg).toBe('test1__before1__before2__before3__exec__after3__after2__after1')\n\n	// 清空拦截器\n    execLink.cleanInterceptors()\n	// 再执行结果\n    const res2 = await execLink.request({ msg: 'test2' })\n    expect(res2.msg).toBe('test2__exec')\n  })\n})\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"虽然看起来代码比较多，但我们可以看到这部分代码做的事情相对简单："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Taro.interceptorify"})," 类似于是封装 ",(0,s.jsx)(r.code,{children:"wx.request"}),"，",(0,s.jsx)(r.code,{children:"my.request"})]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// 前文提到的\n// packages/shared/src/native-apis.ts\nconst request = apis.request || getNormalRequest(global)\nfunction taroInterceptor (chain) {\n	return request(chain.requestParams)\n}\nconst link = new taro.Link(taroInterceptor)\n"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"execLink.addInterceptor"})," 添加拦截器 1、2、3。"]}),"\n",(0,s.jsxs)(r.li,{children:["执行 ",(0,s.jsx)(r.code,{children:"await execLink.request()"})," 把拦截器从第 0 个开始串联起来。"]}),"\n",(0,s.jsx)(r.li,{children:"输出结果，符合期望。"}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"execLink.cleanInterceptors()"})," 清空拦截器。"]}),"\n",(0,s.jsxs)(r.li,{children:["再执行 ",(0,s.jsx)(r.code,{children:"await execLink.request()"}),"。"]}),"\n",(0,s.jsx)(r.li,{children:"输出结果，符合期望。"}),"\n",(0,s.jsx)(r.li,{children:"测试用例通过。"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"msg"})," 结果是这样：",(0,s.jsx)(r.code,{children:"test1__before1__before2__before3__exec__after3__after2__after1"}),"，就能很好的反应出拦截器（async 函数）的执行顺序。熟悉的小伙伴会知道这是典型的洋葱模型。Taro 文档也有说明：拦截器的调用顺序遵循洋葱模型。"]}),"\n",(0,s.jsxs)(r.p,{children:["如果了解 ",(0,s.jsx)(r.code,{children:"koa-compose"}),"，就会发现 ",(0,s.jsx)(r.code,{children:"chain.proceed"})," 其实就是 ",(0,s.jsx)(r.code,{children:"koa-compose"})," 中的 ",(0,s.jsx)(r.code,{children:"next"})," 方法。只不过实现方式不一样而已。\n我曾经写过 ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7005375860509245471",rel:"noopener noreferrer",target:"_blank",children:"50行代码串行Promise，koa洋葱模型原来是这么实现？"}),"，可以对比学习。"]}),"\n",(0,s.jsxs)(r.p,{children:["关于如何调试，",(0,s.jsx)(r.a,{href:"https://github.com/NervJS/taro/blob/main/CONTRIBUTING.md#4-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95",rel:"noopener noreferrer",target:"_blank",children:"贡献文档-单元测试"}),"中有提到："]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"package.json"})," 中设置了 ",(0,s.jsx)(r.code,{children:"test:ci"})," 命令的子包都配备了单元测试。\n开发者在修改这些包后，请运行 ",(0,s.jsx)(r.code,{children:"pnpm --filter [package-name] run test:ci"}),"，检查测试用例是否都能通过。"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["我们提前在 ",(0,s.jsx)(r.code,{children:"packages/taro-api/__tests__/interceptorify.test.ts"})," 文件中根据自己情况打好断点，再新建一个终端",(0,s.jsx)(r.code,{children:"JavaScript debug Termial"}),"，执行 ",(0,s.jsx)(r.code,{children:"pnpm --filter @tarojs/api run test:ci"})," 即可触发断点。调试如下图所示："]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{alt:"调试拦截器图",src:d})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Taro"})," 源码项目准备安装依赖在",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章"}),"中有详细说明，这里就不再赘述。"]}),"\n",(0,s.jsxs)(r.p,{children:["如果不太会调试，可参考我的文章",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7030584939020042254",rel:"noopener noreferrer",target:"_blank",children:"新手向：前端程序员必学基本技能——调试 JS 代码"}),"，或者",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7212263304394981432",rel:"noopener noreferrer",target:"_blank",children:"据说 90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码"})]}),"\n",(0,s.jsxs)(r.p,{children:["我们调试完后，再去看 ",(0,s.jsx)(r.code,{children:"Taro"})," 文档和拦截器相关代码就会豁然开朗，会有更深刻的理解。"]}),"\n",(0,s.jsxs)(r.p,{children:["这时不得不感慨一句：",(0,s.jsx)(r.strong,{children:"设计的很惊艳！"})]}),"\n",(0,s.jsx)(r.p,{children:"我们接着来看内置的拦截器，就比较简单一些了，Taro 文档中有说明。"}),"\n",(0,s.jsxs)(r.h2,{id:"7-内置的两个拦截器",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#7-内置的两个拦截器",children:"#"}),"7. 内置的两个拦截器"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Taro"})," 提供了两个内置拦截器 ",(0,s.jsx)(r.code,{children:"logInterceptor"})," 与 ",(0,s.jsx)(r.code,{children:"timeoutInterceptor"}),"，分别用于打印请求的相关信息和在请求超时时抛出错误。"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsxs)(r.a,{href:"https://taro-docs.jd.com/docs/next/apis/network/request/addInterceptor",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(r.code,{children:"Taro.addInterceptor"}),"文档"]})," 示例代码2"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"Taro.addInterceptor(Taro.interceptors.logInterceptor)\nTaro.addInterceptor(Taro.interceptors.timeoutInterceptor)\nTaro.request({ url })\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.code,{children:"import * as interceptors from './interceptor/interceptors'"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"@tarojs/api"})," 入口文件也有导出内置的拦截器挂载到 ",(0,s.jsx)(r.code,{children:"Taro"})," 上。"]}),"\n",(0,s.jsx)(r.p,{children:"我们接着来学习它们的具体实现。"}),"\n",(0,s.jsxs)(r.h3,{id:"71-timeoutinterceptor-超时拦截器",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#71-timeoutinterceptor-超时拦截器",children:"#"}),"7.1 timeoutInterceptor 超时拦截器"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro-api/src/interceptor/interceptors.ts\nimport { isFunction, isUndefined } from '@tarojs/shared'\n\nimport type Chain from './chain'\n\nexport function timeoutInterceptor (chain: Chain) {\n  const requestParams = chain.requestParams\n  let p: Promise<void>\n  const res = new Promise<void>((resolve, reject) => {\n    const timeout: ReturnType<typeof setTimeout> = setTimeout(() => {\n      clearTimeout(timeout)\n      reject(new Error('网络链接超时,请稍后再试！'))\n    }, (requestParams && requestParams.timeout) || 60000)\n\n    p = chain.proceed(requestParams)\n    p\n      .then(res => {\n        if (!timeout) return\n        clearTimeout(timeout)\n        resolve(res)\n      })\n      .catch(err => {\n        timeout && clearTimeout(timeout)\n        reject(err)\n      })\n  })\n  // @ts-ignore\n  // 这里是兼容 小程序 原生 api 返回结果，不过感觉是不是少兼容了\n  if (!isUndefined(p) && isFunction(p.abort)) res.abort = p.abort\n\n  return res\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"简言之：超时拦截器。"}),"\n",(0,s.jsxs)(r.h3,{id:"72-loginterceptor-日志拦截器",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#72-loginterceptor-日志拦截器",children:"#"}),"7.2 logInterceptor 日志拦截器"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// packages/taro-api/src/interceptor/interceptors.ts\nexport function logInterceptor (chain: Chain) {\n  const requestParams = chain.requestParams\n  const { method, data, url } = requestParams\n\n  // eslint-disable-next-line no-console\n  console.log(`http ${method || 'GET'} --\x3e ${url} data: `, data)\n\n  const p = chain.proceed(requestParams)\n  const res = p\n    .then(res => {\n      // eslint-disable-next-line no-console\n      console.log(`http <-- ${url} result:`, res)\n      return res\n    })\n  // @ts-ignore\n  // 这里是兼容 小程序 原生 api 返回结果，不过感觉是不是少兼容了\n  if (isFunction(p.abort)) res.abort = p.abort\n\n  return res\n}\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"简言之：就是输出下日志。"}),"\n",(0,s.jsxs)(r.h2,{id:"8-总结",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#8-总结",children:"#"}),"8. 总结"]}),"\n",(0,s.jsxs)(r.p,{children:["我们从文档出发 ",(0,s.jsx)(r.code,{children:"Taro.request"})," 的使用和文档中拦截器的使用，分析了 ",(0,s.jsx)(r.code,{children:"Taro.request"})," 的具体实现和 ",(0,s.jsx)(r.code,{children:"Taro"})," 的 ",(0,s.jsx)(r.code,{children:"request"})," 请求和响应拦截器实现。\n端平台插件运行时（runtime）挂载 ",(0,s.jsx)(r.code,{children:"global.request"}),"。\n",(0,s.jsx)(r.code,{children:"@tarojs/taro"}),"、",(0,s.jsx)(r.code,{children:"@tarojs/api"})," 中实现的 ",(0,s.jsx)(r.code,{children:"Chain"})," 链和 ",(0,s.jsx)(r.code,{children:"Link"})," ",(0,s.jsx)(r.code,{children:"request"})," 构造函数。"]}),"\n",(0,s.jsx)(r.p,{children:"最后，我们再回顾下："}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["Taro文档：在调用 ",(0,s.jsx)(r.code,{children:"Taro.request"})," 发起请求之前，调用 ",(0,s.jsx)(r.code,{children:"Taro.addInterceptor"})," 方法为请求添加拦截器，拦截器的调用顺序遵循洋葱模型。 拦截器是一个函数，接受 ",(0,s.jsx)(r.code,{children:"chain"})," 对象作为参数。",(0,s.jsx)(r.code,{children:"chain"})," 对象中含有 ",(0,s.jsx)(r.code,{children:"requestParmas"})," 属性，代表请求参数。拦截器内最后需要调用 ",(0,s.jsx)(r.code,{children:"chain.proceed(requestParams)"})," 以调用下一个拦截器或发起请求。"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["拦截器的调用顺序遵循洋葱模型，测试用例中输出顺序：",(0,s.jsx)(r.code,{children:"test1__before1__before2__before3__exec__after3__after2__after1"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"test1"})," 是 ",(0,s.jsx)(r.code,{children:"Taro.request"})," 传入的参数，",(0,s.jsx)(r.code,{children:"__exec"})," 是最开始的参数。",(0,s.jsx)(r.code,{children:"before、after"})," 数字对应的是拦截器（async 函数 ",(0,s.jsx)(r.code,{children:"fn1, fn2, fn3"}),"）。"]}),"\n",(0,s.jsxs)(r.p,{children:["总之 ",(0,s.jsx)(r.code,{children:"Taro"})," 拦截器",(0,s.jsx)(r.strong,{children:"设计的很惊艳"}),"，是设计模式中的职责链模式实现。和 ",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7005375860509245471",rel:"noopener noreferrer",target:"_blank",children:"koa-compose-文章"}),"、",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/6844904019987529735#heading-21",rel:"noopener noreferrer",target:"_blank",children:"axios-文章"})," 是实现的类似功能、只是实现方式不一样。"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["作者：常以",(0,s.jsx)(r.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,s.jsx)(r.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,s.jsx)(r.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,s.jsx)(r.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,s.jsxs)(r.p,{children:["最后可以持续关注我",(0,s.jsx)(r.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,s.jsx)(r.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(r.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(r.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(r.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(r.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),e.components);return r?(0,s.jsx)(r,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}let p=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["taro%2Frequest%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-taro-request-相关文档",text:"2. Taro request 相关文档",depth:2},{id:"3-equipcommonapis-挂载公共-apis",text:"3. equipCommonApis 挂载公共 apis",depth:2},{id:"31-getnormalrequest-获取标准的-request",text:"3.1 getNormalRequest 获取标准的 request",depth:3},{id:"32-equiptaskmethodsintopromise-适配小程序-api-原生返回结果",text:"3.2 equipTaskMethodsIntoPromise 适配小程序 api 原生返回结果",depth:3},{id:"4-tarojsapi-所有端的公共-api",text:"4. @tarojs/api 所有端的公共 API",depth:2},{id:"5-link-构造函数",text:"5. Link 构造函数",depth:2},{id:"51-拦截器入口文件-srcinterceptorindexts",text:"5.1 拦截器入口文件 src/interceptor/index.ts",depth:3},{id:"52-链-srcinterceptorchaints",text:"5.2 链 src/interceptor/chain.ts",depth:3},{id:"6-借助项目提供的-jest-测试用例调试拦截器",text:"6. 借助项目提供的 jest 测试用例调试拦截器",depth:2},{id:"7-内置的两个拦截器",text:"7. 内置的两个拦截器",depth:2},{id:"71-timeoutinterceptor-超时拦截器",text:"7.1 timeoutInterceptor 超时拦截器",depth:3},{id:"72-loginterceptor-日志拦截器",text:"7.2 logInterceptor 日志拦截器",depth:3},{id:"8-总结",text:"8. 总结",depth:2}],title:"Taro 源码揭秘：7. Taro.request 和请求响应拦截器是如何实现的",headingTitle:"Taro 源码揭秘：7. Taro.request 和请求响应拦截器是如何实现的",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(e,r,n){n.d(r,{Z:()=>o});var s=n(52676),t=n(75271),i=n(92815);n(18544);let c={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,r,n){let s=Object.keys(c).includes(r)?r:n;return c[s](e)}let o=e=>{let{defaultLocale:r="en-US"}=e,n=(0,i.Vi)().page.readingTimeData,c=(0,i.Jr)(),o=(0,i.e7)(),[d,l]=(0,t.useState)(a(n,c,r));return(0,t.useEffect)(()=>{l(a(n,c,r))},[c,n]),(0,s.jsx)("span",{"data-dark":String(o),className:"rp-reading-time",children:d})}}}]);