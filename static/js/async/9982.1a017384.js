"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["9982"],{60332:function(e,n,t){e.exports=t.p+"static/image/wechat-official-accounts-mini.44481959.png"},57958:function(e,n,t){t.r(n),t.d(n,{default:()=>j});var r=t(52676),c=t(40453),o=t(20713);let s=t.p+"static/image/demo1.3d14c587.png",d=t.p+"static/image/demo2.a9748649.png",i=t.p+"static/image/f.5ac133fb.png";var l=t(60332);function a(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",code:"code",h2:"h2",pre:"pre",strong:"strong",img:"img",h3:"h3",ol:"ol",li:"li"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"面试官问能否模拟实现js的new操作符",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#面试官问能否模拟实现js的new操作符",children:"#"}),"面试官问：能否模拟实现JS的new操作符"]}),"\n",(0,r.jsx)(o.Z,{defaultLocale:"zh-CN"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"写于2018年11月05日"})}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["大家好，我是",(0,r.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。我倾力持续组织了一年",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习200行左右的源码共读活动"}),"，感兴趣的可以",(0,r.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,r.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,r.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["这是面试官问系列的第一篇，旨在帮助读者提升",(0,r.jsx)(n.code,{children:"JS"}),"基础知识，包含",(0,r.jsx)(n.code,{children:"new、call、apply、this、继承"}),"相关知识。","\n",(0,r.jsx)(n.code,{children:"面试官问系列"}),"文章如下：感兴趣的读者可以点击阅读。","\n1.",(0,r.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n2.",(0,r.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n3.",(0,r.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n4.",(0,r.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n5.",(0,r.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["用过",(0,r.jsx)(n.code,{children:"Vuejs"}),"的同学都知道，需要用",(0,r.jsx)(n.code,{children:"new"}),"操作符来实例化。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"new Vue({\n    el: '#app',\n    mounted(){},\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["那么面试官可能会问是否想过",(0,r.jsx)(n.code,{children:"new"}),"到底做了什么，怎么模拟实现呢。"]})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["附上之前写文章写过的一段话：已经有很多模拟实现",(0,r.jsx)(n.code,{children:"new"}),"操作符的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"2-new-做了什么",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-new-做了什么",children:"#"}),"2. new 做了什么"]}),"\n",(0,r.jsxs)(n.p,{children:["先看简单",(0,r.jsx)(n.strong,{children:"例子1"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 例子1\nfunction Student(){\n}\nvar student = new Student();\nconsole.log(student); // {}\n// student 是一个对象。\nconsole.log(Object.prototype.toString.call(student)); // [object Object]\n// 我们知道平时声明对象也可以用new Object(); 只是看起来更复杂\n// 顺便提一下 `new Object`(不推荐)和Object()也是一样的效果\n// 可以猜测内部做了一次判断，用new调用\n/** if (!(this instanceof Object)) {\n*    return new Object();\n*  }\n*/\nvar obj = new Object();\nconsole.log(obj) // {}\nconsole.log(Object.prototype.toString.call(student)); // [object Object]\n\ntypeof Student === 'function' // true\ntypeof Object === 'function' // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["从这里例子中，我们可以看出：一个函数用",(0,r.jsx)(n.code,{children:"new"}),"操作符来调用后，生成了一个全新的对象。而且",(0,r.jsx)(n.code,{children:"Student"}),"和",(0,r.jsx)(n.code,{children:"Object"}),"都是函数，只不过",(0,r.jsx)(n.code,{children:"Student"}),"是我们自定义的，",(0,r.jsx)(n.code,{children:"Object"}),"是",(0,r.jsx)(n.code,{children:"JS"}),"本身就内置的。\n再来看下控制台输出图，感兴趣的读者可以在控制台试试。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"例子1 控制台输出图",src:s})}),"\n",(0,r.jsxs)(n.p,{children:["与",(0,r.jsx)(n.code,{children:"new Object()"})," 生成的对象不同的是",(0,r.jsx)(n.code,{children:"new Student()"}),"生成的对象中间还嵌套了一层",(0,r.jsx)(n.code,{children:"__proto__"}),"，它的",(0,r.jsx)(n.code,{children:"constructor"}),"是",(0,r.jsx)(n.code,{children:"Student"}),"这个函数。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 也就是说：\nstudent.constructor === Student;\nStudent.prototype.constructor === Student;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"21-小结1从这个简单例子来看new操作符做了两件事",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-小结1从这个简单例子来看new操作符做了两件事",children:"#"}),"2.1 小结1：从这个简单例子来看，",(0,r.jsx)(n.code,{children:"new"}),"操作符做了两件事："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"创建了一个全新的对象。"}),"\n",(0,r.jsxs)(n.li,{children:["这个对象会被执行",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,r.jsx)(n.code,{children:"__proto__"}),"）链接。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们再来看升级版的",(0,r.jsx)(n.strong,{children:"例子2"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 例子2\nfunction Student(name){\n    console.log('赋值前-this', this); // {}\n    this.name = name;\n    console.log('赋值后-this', this); // {name: '若川'}\n}\nvar student = new Student('若川');\nconsole.log(student); // {name: '若川'}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["由此可以看出：这里",(0,r.jsx)(n.code,{children:"Student"}),"函数中的",(0,r.jsx)(n.code,{children:"this"}),"指向",(0,r.jsx)(n.code,{children:"new Student()"}),"生成的对象",(0,r.jsx)(n.code,{children:"student"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"22-小结2从这个例子来看new操作符又做了一件事",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-小结2从这个例子来看new操作符又做了一件事",children:"#"}),"2.2 小结2：从这个例子来看，",(0,r.jsx)(n.code,{children:"new"}),"操作符又做了一件事："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["生成的新对象会绑定到函数调用的",(0,r.jsx)(n.code,{children:"this"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来继续看升级版",(0,r.jsx)(n.strong,{children:"例子3"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 例子3\nfunction Student(name){\n    this.name = name;\n    // this.doSth();\n}\nStudent.prototype.doSth = function() {\n    console.log(this.name);\n};\nvar student1 = new Student('若');\nvar student2 = new Student('川');\nconsole.log(student1, student1.doSth()); // {name: '若'} '若'\nconsole.log(student2, student2.doSth()); // {name: '川'} '川'\nstudent1.__proto__ === Student.prototype; // true\nstudent2.__proto__ === Student.prototype; // true\n// __proto__ 是浏览器实现的查看原型方案。\n// 用ES5 则是：\nObject.getPrototypeOf(student1) === Student.prototype; // true\nObject.getPrototypeOf(student2) === Student.prototype; // true\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"例子3 控制台输出图",src:d})}),"\n",(0,r.jsx)(n.p,{children:"关于JS的原型关系我之前看到这张图，觉得很不错，分享给大家。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"JavaScript原型关系图",src:i})}),"\n",(0,r.jsxs)(n.h3,{id:"23-小结3这个例子3再一次验证了小结1中的第2点也就是这个对象会被执行prototype也就是__proto__链接并且通过new-student创建的每个对象将最终被prototype链接到这个studentprotytype对象上",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-小结3这个例子3再一次验证了小结1中的第2点也就是这个对象会被执行prototype也就是__proto__链接并且通过new-student创建的每个对象将最终被prototype链接到这个studentprotytype对象上",children:"#"}),"2.3 小结3：这个例子3再一次验证了",(0,r.jsx)(n.strong,{children:"小结1"}),"中的",(0,r.jsx)(n.strong,{children:"第2点"}),"。也就是这个对象会被执行",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,r.jsx)(n.code,{children:"__proto__"}),"）链接。并且通过",(0,r.jsx)(n.code,{children:"new Student()"}),"创建的每个对象将最终被",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"链接到这个",(0,r.jsx)(n.code,{children:"Student.protytype"}),"对象上。"]}),"\n",(0,r.jsxs)(n.p,{children:["细心的同学可能会发现这三个例子中的函数都没有返回值。那么有返回值会是怎样的情形呢。\n那么接下来请看",(0,r.jsx)(n.strong,{children:"例子4"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 例子4\nfunction Student(name){\n    this.name = name;\n    // Null（空） null\n    // Undefined（未定义） undefined\n    // Number（数字） 1\n    // String（字符串）'1'\n    // Boolean（布尔） true\n    // Symbol（符号）（第六版新增） symbol\n\n    // Object（对象） {}\n        // Function（函数） function(){}\n        // Array（数组） []\n        // Date（日期） new Date()\n        // RegExp（正则表达式）/a/\n        // Error （错误） new Error()\n    // return /a/;\n}\nvar student = new Student('若川');\nconsole.log(student); {name: '若川'}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我测试这七种类型后",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript",rel:"noopener noreferrer",target:"_blank",children:"MDN JavaScript类型"}),"，得出的结果是：前面六种基本类型都会正常返回",(0,r.jsx)(n.code,{children:"{name: '若川'}"}),"，后面的",(0,r.jsx)(n.code,{children:"Object"}),"(包含",(0,r.jsx)(n.code,{children:"Functoin"}),", ",(0,r.jsx)(n.code,{children:"Array"}),", ",(0,r.jsx)(n.code,{children:"Date"}),", ",(0,r.jsx)(n.code,{children:"RegExg"}),", ",(0,r.jsx)(n.code,{children:"Error"}),")都会直接返回这些值。"]}),"\n",(0,r.jsxs)(n.h3,{id:"24-由此得出-小结4",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-由此得出-小结4",children:"#"}),"2.4 由此得出 小结4："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["如果函数没有返回对象类型",(0,r.jsx)(n.code,{children:"Object"}),"(包含",(0,r.jsx)(n.code,{children:"Functoin"}),", ",(0,r.jsx)(n.code,{children:"Array"}),", ",(0,r.jsx)(n.code,{children:"Date"}),", ",(0,r.jsx)(n.code,{children:"RegExg"}),", ",(0,r.jsx)(n.code,{children:"Error"}),")，那么",(0,r.jsx)(n.code,{children:"new"}),"表达式中的函数调用会自动返回这个新的对象。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"结合这些小结，整理在一起就是："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"创建了一个全新的对象。"}),"\n",(0,r.jsxs)(n.li,{children:["这个对象会被执行",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,r.jsx)(n.code,{children:"__proto__"}),"）链接。"]}),"\n",(0,r.jsxs)(n.li,{children:["生成的新对象会绑定到函数调用的",(0,r.jsx)(n.code,{children:"this"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["通过",(0,r.jsx)(n.code,{children:"new"}),"创建的每个对象将最终被",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"链接到这个函数的",(0,r.jsx)(n.code,{children:"prototype"}),"对象上。"]}),"\n",(0,r.jsxs)(n.li,{children:["如果函数没有返回对象类型",(0,r.jsx)(n.code,{children:"Object"}),"(包含",(0,r.jsx)(n.code,{children:"Functoin"}),", ",(0,r.jsx)(n.code,{children:"Array"}),", ",(0,r.jsx)(n.code,{children:"Date"}),", ",(0,r.jsx)(n.code,{children:"RegExg"}),", ",(0,r.jsx)(n.code,{children:"Error"}),")，那么",(0,r.jsx)(n.code,{children:"new"}),"表达式中的函数调用会自动返回这个新的对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"3-new-模拟实现",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-new-模拟实现",children:"#"}),"3. new 模拟实现"]}),"\n",(0,r.jsxs)(n.p,{children:["知道了这些现象，我们就可以模拟实现",(0,r.jsx)(n.code,{children:"new"}),"操作符。直接贴出代码和注释"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/**\n * 模拟实现 new 操作符\n * @param  {Function} ctor [构造函数]\n * @return {Object|Function|Regex|Date|Error}      [返回结果]\n */\nfunction newOperator(ctor){\n    if(typeof ctor !== 'function'){\n      throw 'newOperator function the first param must be a function';\n    }\n    // ES6 new.target 是指向构造函数\n    newOperator.target = ctor;\n    // 1.创建一个全新的对象，\n    // 2.并且执行[[Prototype]]链接\n    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。\n    var newObj = Object.create(ctor.prototype);\n    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);\n    // 除去ctor构造函数的其余参数\n    var argsArr = [].slice.call(arguments, 1);\n    // 3.生成的新对象会绑定到函数调用的`this`。\n    // 获取到ctor函数返回结果\n    var ctorReturnResult = ctor.apply(newObj, argsArr);\n    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null\n    var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;\n    var isFunction = typeof ctorReturnResult === 'function';\n    if(isObject || isFunction){\n        return ctorReturnResult;\n    }\n    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。\n    return newObj;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["最后用模拟实现的",(0,r.jsx)(n.code,{children:"newOperator"}),"函数验证下之前的",(0,r.jsx)(n.strong,{children:"例子3"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 例子3 多加一个参数\nfunction Student(name, age){\n    this.name = name;\n    this.age = age;\n    // this.doSth();\n    // return Error();\n}\nStudent.prototype.doSth = function() {\n    console.log(this.name);\n};\nvar student1 = newOperator(Student, '若', 18);\nvar student2 = newOperator(Student, '川', 18);\n// var student1 = new Student('若');\n// var student2 = new Student('川');\nconsole.log(student1, student1.doSth()); // {name: '若'} '若'\nconsole.log(student2, student2.doSth()); // {name: '川'} '川'\n\nstudent1.__proto__ === Student.prototype; // true\nstudent2.__proto__ === Student.prototype; // true\n// __proto__ 是浏览器实现的查看原型方案。\n// 用ES5 则是：\nObject.getPrototypeOf(student1) === Student.prototype; // true\nObject.getPrototypeOf(student2) === Student.prototype; // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看出，很符合",(0,r.jsx)(n.code,{children:"new"}),"操作符。读者发现有不妥或可改善之处，欢迎指出。\n回顾这个模拟",(0,r.jsx)(n.code,{children:"new"}),"函数",(0,r.jsx)(n.code,{children:"newOperator"}),"实现，最大的功臣当属于",(0,r.jsx)(n.code,{children:"Object.create()"}),"这个",(0,r.jsx)(n.code,{children:"ES5"}),"提供的",(0,r.jsx)(n.code,{children:"API"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"4-objectcreate-用法举例",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-objectcreate-用法举例",children:"#"}),"4. Object.create() 用法举例"]}),"\n",(0,r.jsxs)(n.p,{children:["我之前整理的一篇文章中也有讲过，可以翻看",(0,r.jsx)(n.a,{href:"https://segmentfault.com/a/1190000010753942",rel:"noopener noreferrer",target:"_blank",children:"JavaScript 对象所有API解析"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create",rel:"noopener noreferrer",target:"_blank",children:"MDN Object.create()"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Object.create(proto, [propertiesObject])"}),"\n方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是",(0,r.jsx)(n.code,{children:"undefined"}),"）。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var anotherObject = {\n    name: '若川'\n};\nvar myObject = Object.create(anotherObject, {\n    age: {\n        value：18,\n    },\n});\n// 获得它的原型\nObject.getPrototypeOf(anotherObject) === Object.prototype; // true 说明anotherObject的原型是Object.prototype\nObject.getPrototypeOf(myObject); // {name: \"若川\"} // 说明myObject的原型是{name: \"若川\"}\nmyObject.hasOwnProperty('name'); // false; 说明name是原型上的。\nmyObject.hasOwnProperty('age'); // true 说明age是自身的\nmyObject.name; // '若川'\nmyObject.age; // 18;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["对于不支持",(0,r.jsx)(n.code,{children:"ES5"}),"的浏览器，",(0,r.jsx)(n.code,{children:"MDN"}),"上提供了",(0,r.jsx)(n.code,{children:"ployfill"}),"方案。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"if (typeof Object.create !== \"function\") {\n    Object.create = function (proto, propertiesObject) {\n        if (typeof proto !== 'object' && typeof proto !== 'function') {\n            throw new TypeError('Object prototype may only be an Object: ' + proto);\n        } else if (proto === null) {\n            throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n        }\n\n        if (typeof propertiesObject != 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\");\n\n        function F() {}\n        F.prototype = proto;\n        return new F();\n    };\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"到此，文章就基本写完了。感谢读者看到这里。"}),"\n",(0,r.jsxs)(n.h2,{id:"5-最后总结一下",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-最后总结一下",children:"#"}),"5. 最后总结一下："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"new"}),"做了什么："]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"创建了一个全新的对象。"}),"\n",(0,r.jsxs)(n.li,{children:["这个对象会被执行",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"（也就是",(0,r.jsx)(n.code,{children:"__proto__"}),"）链接。"]}),"\n",(0,r.jsxs)(n.li,{children:["生成的新对象会绑定到函数调用的",(0,r.jsx)(n.code,{children:"this"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["通过",(0,r.jsx)(n.code,{children:"new"}),"创建的每个对象将最终被",(0,r.jsx)(n.code,{children:"[[Prototype]]"}),"链接到这个函数的",(0,r.jsx)(n.code,{children:"prototype"}),"对象上。"]}),"\n",(0,r.jsxs)(n.li,{children:["如果函数没有返回对象类型",(0,r.jsx)(n.code,{children:"Object"}),"(包含",(0,r.jsx)(n.code,{children:"Functoin"}),", ",(0,r.jsx)(n.code,{children:"Array"}),", ",(0,r.jsx)(n.code,{children:"Date"}),", ",(0,r.jsx)(n.code,{children:"RegExg"}),", ",(0,r.jsx)(n.code,{children:"Error"}),")，那么",(0,r.jsx)(n.code,{children:"new"}),"表达式中的函数调用会自动返回这个新的对象。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"怎么模拟实现"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 去除了注释\nfunction newOperator(ctor){\n    if(typeof ctor !== 'function'){\n      throw 'newOperator function the first param must be a function';\n    }\n    newOperator.target = ctor;\n    var newObj = Object.create(ctor.prototype);\n    var argsArr = [].slice.call(arguments, 1);\n    var ctorReturnResult = ctor.apply(newObj, argsArr);\n    var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;\n    var isFunction = typeof ctorReturnResult === 'function';\n    if(isObject || isFunction){\n        return ctorReturnResult;\n    }\n    return newObj;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对我的一种支持。"}),"\n",(0,r.jsxs)(n.h2,{id:"关于",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,r.jsxs)(n.p,{children:["作者：常以",(0,r.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,r.jsx)(n.a,{href:"https://ruochuan12.github.io/",rel:"noopener noreferrer",target:"_blank",children:"个人博客"}),"\n",(0,r.jsx)(n.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,r.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,r.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，开通了",(0,r.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,r.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，开通了",(0,r.jsx)(n.strong,{children:"前端视野"}),"专栏，欢迎关注~","\n",(0,r.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,r.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,r.jsxs)(n.h2,{id:"微信公众号--若川视野",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,r.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ",(0,r.jsx)(n.code,{children:"ruochuan12"}),"，注明来源，拉您进【前端视野交流群】。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"若川视野",src:l})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(a,e)})):a(e)}let j=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["js-implement-new%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-new-做了什么",text:"2. new 做了什么",depth:2},{id:"21-小结1从这个简单例子来看new操作符做了两件事",text:"2.1 小结1：从这个简单例子来看，`new`操作符做了两件事：",depth:3},{id:"22-小结2从这个例子来看new操作符又做了一件事",text:"2.2 小结2：从这个例子来看，`new`操作符又做了一件事：",depth:3},{id:"23-小结3这个例子3再一次验证了小结1中的第2点也就是这个对象会被执行prototype也就是__proto__链接并且通过new-student创建的每个对象将最终被prototype链接到这个studentprotytype对象上",text:"2.3 小结3：这个例子3再一次验证了**小结1**中的**第2点**。也就是这个对象会被执行`[[Prototype]]`（也就是`__proto__`）链接。并且通过`new Student()`创建的每个对象将最终被`[[Prototype]]`链接到这个`Student.protytype`对象上。",depth:3},{id:"24-由此得出-小结4",text:"2.4 由此得出 小结4：",depth:3},{id:"3-new-模拟实现",text:"3. new 模拟实现",depth:2},{id:"4-objectcreate-用法举例",text:"4. Object.create() 用法举例",depth:2},{id:"5-最后总结一下",text:"5. 最后总结一下：",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"面试官问：能否模拟实现JS的new操作符",headingTitle:"面试官问：能否模拟实现JS的new操作符",frontmatter:{}}},20713:function(e,n,t){t.d(n,{Z:()=>i});var r=t(52676),c=t(75271),o=t(92815);t(18544);let s={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function d(e,n,t){let r=Object.keys(s).includes(n)?n:t;return s[r](e)}let i=e=>{let{defaultLocale:n="en-US"}=e,t=(0,o.Vi)().page.readingTimeData,s=(0,o.Jr)(),i=(0,o.e7)(),[l,a]=(0,c.useState)(d(t,s,n));return(0,c.useEffect)(()=>{a(d(t,s,n))},[s,t]),(0,r.jsx)("span",{"data-dark":String(i),className:"rp-reading-time",children:l})}}}]);