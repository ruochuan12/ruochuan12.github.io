"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["9111"],{6752:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(52676),i=r(40453),o=r(20713);let t=r.p+"static/image/docs-apis.63d9a2b5.png";function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",input:"input",pre:"pre",img:"img",h3:"h3",blockquote:"blockquote",strong:"strong",hr:"hr"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"taro-源码揭秘6-为什么通过-taroxxx-能调用各个小程序平台的-api如何设计实现的",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘6-为什么通过-taroxxx-能调用各个小程序平台的-api如何设计实现的",children:"#"}),"Taro 源码揭秘：6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"]}),"\n",(0,s.jsx)(o.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["截至目前（",(0,s.jsx)(n.code,{children:"2024-08-28"}),"），",(0,s.jsxs)(n.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.3",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"taro 4.0"})," 正式版已经发布"]}),"，目前最新是 ",(0,s.jsx)(n.code,{children:"4.0.5"}),"，官方",(0,s.jsx)(n.code,{children:"4.0"}),"正式版本的介绍文章暂未发布。官方之前发过",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。第 6 篇我们来讲些相对简单的，Taro 是如何实现 ",(0,s.jsx)(n.code,{children:"Taro.xxx"})," 能访问 ",(0,s.jsx)(n.code,{children:"wx.xxx"}),"（文章以微信小程序为例）。"]}),"\n",(0,s.jsxs)(n.p,{children:["关于克隆项目、环境准备、如何调试代码等，参考",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章-准备工作、调试"}),"。后续文章基本不再过多赘述。"]}),"\n",(0,s.jsx)(n.p,{children:"学完本文，你将学到："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. @tarojs/taro 源码揭秘\n2. 端平台插件运行时源码分析\n3. initNativeApi 中的 processApis 是如何设计实现的，如何 promisify 化的\n等等\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"2-taro-文档---api-说明",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-taro-文档---api-说明",children:"#"}),"2. Taro 文档 - API 说明"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/apis/about/desc",rel:"noopener noreferrer",target:"_blank",children:"Taro 文档 - API 说明"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"文档截图",src:t})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import Taro from '@tarojs/taro'\n\nTaro.request(url).then(function (res) {\n  console.log(res)\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们具体来分析下，",(0,s.jsx)(n.code,{children:"Taro"})," 源码中是如何实现 ",(0,s.jsx)(n.code,{children:"Taro.xxx"})," 访问 ",(0,s.jsx)(n.code,{children:"wx.xxx"})," 的，并且是如何实现 ",(0,s.jsx)(n.code,{children:"promisify"})," 的。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"promisify"})," 把回调函数转成 ",(0,s.jsx)(n.code,{children:"promise"})," 避免回调地狱问题。面试也经常考察此题。我之前写过一篇文章：",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7028731182216904740#heading-11",rel:"noopener noreferrer",target:"_blank",children:"从22行有趣的源码库中，我学到了 callback promisify 化的 Node.js 源码实现"})]}),"\n",(0,s.jsxs)(n.p,{children:["文章中简单的 ",(0,s.jsx)(n.code,{children:"promisify"})," 函数实现如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 简单的 promisify 函数\nfunction promisify(original){\n    function fn(...args){\n        return new Promise((resolve, reject) => {\n            args.push((err, ...values) => {\n                if(err){\n                    return reject(err);\n                }\n                resolve(values);\n            });\n            // original.apply(this, args);\n            Reflect.apply(original, this, args);\n        });\n    }\n    return fn;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们日常开发都会引入 ",(0,s.jsx)(n.code,{children:"@tarojs/taro"}),"，然后调用 ",(0,s.jsx)(n.code,{children:"Taro.xxx"})," 方法，比如 ",(0,s.jsx)(n.code,{children:"Taro.navigateTo"}),"，微信小程序调用的是 ",(0,s.jsx)(n.code,{children:"wx.navigateTo"}),"，支付宝小程序则是 ",(0,s.jsx)(n.code,{children:"my.navigateTo"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们先来看 ",(0,s.jsx)(n.code,{children:"@tarojs/taro"})," 的代码。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-tarojstaro-taro-入口",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-tarojstaro-taro-入口",children:"#"}),"3. @tarojs/taro taro 入口"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro/index.js\nconst { hooks } = require('@tarojs/runtime')\nconst taro = require('@tarojs/api').default\n\nif (hooks.isExist('initNativeApi')) {\n  hooks.call('initNativeApi', taro)\n}\n\nmodule.exports = taro\nmodule.exports.default = module.exports\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hooks"})," 和 ",(0,s.jsx)(n.code,{children:"@tarojs/api"})," 在上篇文章",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977#heading-20",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"}),"讲过。\n简单来说就是 ",(0,s.jsx)(n.code,{children:"tap"})," 是注册事件，",(0,s.jsx)(n.code,{children:"call"})," 是触发事件。其中 ",(0,s.jsx)(n.code,{children:"mergeReconciler"})," 函数中注册",(0,s.jsx)(n.code,{children:"initNativeApi"}),"函数。"]}),"\n",(0,s.jsxs)(n.p,{children:["这时我们需要来寻找 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 函数在哪里实现的。可以在Taro源码中根据 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 关键字搜索。或者之前的第三篇文章 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"3. taro build"}),"。我们知道端平台插件的代码在 ",(0,s.jsx)(n.code,{children:"@tarojs/plugin-platform-weapp"})," 包中，路径是 ",(0,s.jsx)(n.code,{children:"packages/taro-platform-weapp/src/program.ts"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-new-weapp-端平台插件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-new-weapp-端平台插件",children:"#"}),"4. new Weapp 端平台插件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-platform-weapp/src/program.ts\nimport { TaroPlatformBase } from '@tarojs/service'\n\n// 省略若干代码\n\nconst PACKAGE_NAME = '@tarojs/plugin-platform-weapp'\n\nexport default class Weapp extends TaroPlatformBase {\n  template: Template\n  platform = 'weapp'\n  globalObject = 'wx'\n  projectConfigJson: string = this.config.projectConfigName || 'project.config.json'\n  runtimePath = `${PACKAGE_NAME}/dist/runtime`\n  //   省略若干代码\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"runtimePath"})," 路径：",(0,s.jsx)(n.code,{children:"@tarojs/plugin-platform-weapp/dist/runtime"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["对应的运行时路径 ",(0,s.jsx)(n.code,{children:"packages/taro-platform-weapp/src/runtime.ts"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"5-运行时-runtimets",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-运行时-runtimets",children:"#"}),"5. 运行时 runtime.ts"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-platform-weapp/src/runtime.ts\nimport { mergeInternalComponents, mergeReconciler } from '@tarojs/shared'\n\nimport { components, hostConfig } from './runtime-utils'\n\nmergeReconciler(hostConfig)\nmergeInternalComponents(components)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"mergeReconciler"})," 函数把自定义的 ",(0,s.jsx)(n.code,{children:"hostConfig"})," 合并到全局 ",(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/platform-plugin/reconciler",rel:"noopener noreferrer",target:"_blank",children:"Reconciler"})," 中。"]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"mergeInternalComponents"})," 函数把自定义组件信息 ",(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/platform-plugin/platform-mini#31-%E7%BC%96%E5%86%99-componentsts",rel:"noopener noreferrer",target:"_blank",children:"components.ts"})," 合并到全局 ",(0,s.jsx)(n.code,{children:"internalComponents"})," 组件信息对象中。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们来看下 ",(0,s.jsx)(n.code,{children:"mergeReconciler"})," 函数的实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-mergereconciler-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-mergereconciler-函数",children:"#"}),"6. mergeReconciler 函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/utils.ts\nimport { hooks } from './runtime-hooks'\nexport function mergeReconciler (hostConfig, hooksForTest?) {\n  const obj = hooksForTest || hooks\n  const keys = Object.keys(hostConfig)\n  keys.forEach(key => {\n    obj.tap(key, hostConfig[key])\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"obj.tap(key, hostConfig[key])"})," 是注册事件，在 ",(0,s.jsx)(n.code,{children:"call"})," 调用。"]}),"\n",(0,s.jsxs)(n.p,{children:["再看 ",(0,s.jsx)(n.code,{children:"hostConfig"})," 配置对象。"]}),"\n",(0,s.jsxs)(n.h2,{id:"7-hostconfig-配置对象",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-hostconfig-配置对象",children:"#"}),"7. hostConfig 配置对象"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-platform-weapp/src/runtime-utils.ts\nimport { Shortcuts, toCamelCase } from '@tarojs/shared'\n\nimport { initNativeApi } from './apis'\n\ndeclare const getCurrentPages: any\n\nexport { initNativeApi }\nexport * from './apis-list'\nexport * from './components'\nexport const hostConfig = {\n  initNativeApi,\n  getMiniLifecycle (config) {\n    // 省略具体实现\n  },\n  transferHydrateData (data, element, componentsAlias) {\n    // 省略具体实现\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hostConfig"})," 对象中包含了 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 等函数。我们接着来看 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 函数。"]}),"\n",(0,s.jsxs)(n.h2,{id:"8-initnativeapi-初始化原始-api",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-initnativeapi-初始化原始-api",children:"#"}),"8. initNativeApi 初始化原始 api"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-platform-weapp/src/apis.ts\nimport { processApis } from '@tarojs/shared'\n\nimport { needPromiseApis } from './apis-list'\n\ndeclare const wx: any\n\nexport function initNativeApi (taro) {\n  processApis(taro, wx, {\n    needPromiseApis,\n    modifyApis (apis) {\n      // fix https://github.com/NervJS/taro/issues/9899\n      apis.delete('lanDebug')\n    },\n    transformMeta (api: string, options: Record<string, any>) {\n      // 省略具体实现\n    }\n  })\n  taro.cloud = wx.cloud\n  taro.getTabBar = function (pageCtx) {\n    if (typeof pageCtx?.getTabBar === 'function') {\n      return pageCtx.getTabBar()?.$taroInstances\n    }\n  }\n  taro.getRenderer = function () {\n    return taro.getCurrentInstance()?.page?.renderer ?? 'webview'\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"initNativeApi"})," 函数中调用了 ",(0,s.jsx)(n.code,{children:"processApis"})," 函数，把 ",(0,s.jsx)(n.code,{children:"wx"})," 的 ",(0,s.jsx)(n.code,{children:"api"})," 转换成 ",(0,s.jsx)(n.code,{children:"taro"})," 的 ",(0,s.jsx)(n.code,{children:"api"}),"。我们接着来看 ",(0,s.jsx)(n.code,{children:"processApis"})," 函数的具体实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"9-processapis-处理-apis",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-processapis-处理-apis",children:"#"}),"9. processApis 处理 apis"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\n\n// 需要 promisify 的 api 列表（内置的，所有端平台都用得上的）\nconst needPromiseApis = new Set<string>([\n  // 省略了很多 api，这里相对常用的留一些\n  'chooseAddress', 'chooseImage', 'chooseLocation', 'downloadFile','getLocation', 'navigateBack', 'navigateTo', 'openDocument', 'openLocation', 'reLaunch', 'redirectTo', 'scanCode', 'showModal', 'showToast', 'switchTab', 'uploadFile',\n])\n\n// processApis config 参数对象，TS 接口定义\ninterface IProcessApisIOptions {\n  // 不需要 promisify 的 api\n  noPromiseApis?: Set<string>\n  // 需要 promisify 的 api\n  needPromiseApis?: Set<string>\n  // handleSyncApis 磨平差异\n  handleSyncApis?: (key: string, global: IObject, args: any[]) => any\n  // 改变 key 或 option 字段，如需要把支付宝标准的字段对齐微信标准的字段\n  transformMeta?: (key: string, options: IObject) => { key: string, options: IObject }\n  //  修改 apis\n  modifyApis?: (apis: Set<string>) => void\n  //  修改返回结果\n  modifyAsyncResult?: (key: string, res) => void\n//   是否只 promisify，只在 plugin-inject 端使用\n  isOnlyPromisify?: boolean\n  [propName: string]: any\n}\n\nfunction processApis (taro, global, config: IProcessApisIOptions = {}) {\n	// 省略...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们来看 ",(0,s.jsx)(n.code,{children:"processApis"})," 函数的具体实现。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\nfunction processApis (taro, global, config: IProcessApisIOptions = {}) {\n  // 端平台插件中定义的一些需要 promisify 的 api\n  const patchNeedPromiseApis = config.needPromiseApis || []\n  const _needPromiseApis = new Set<string>([...patchNeedPromiseApis, ...needPromiseApis])\n  //  保留的 api\n  const preserved = [\n    'getEnv',\n    'interceptors',\n    'Current',\n    'getCurrentInstance',\n    'options',\n    'nextTick',\n    'eventCenter',\n    'Events',\n    'preload',\n    'webpackJsonp'\n  ]\n\n  // Object.keys(global) (wx、my等) 获取所有 api 的 key，过滤掉保留的 api\n  // 如果 config.isOnlyPromisify 为 true，则只执行 needPromiseApis，其他的已经在此之前执行过了。\n  const apis = new Set(\n    !config.isOnlyPromisify\n      ? Object.keys(global).filter(api => preserved.indexOf(api) === -1)\n      : patchNeedPromiseApis\n  )\n\n  // 修改 apis，如需要把支付宝标准的 apis 对齐微信标准的 apis\n  if (config.modifyApis) {\n    config.modifyApis(apis)\n  }\n\n  // 遍历 apis，需要 promisify 的 api 执行 promisify，不需要的则直接挂载到 taro 上\n  apis.forEach(key => {\n    // 省略，拆开到下方\n  })\n\n  // 挂载常用的 API, 比如 canIUseWebp、getCurrentPages、getApp、env 等\n  !config.isOnlyPromisify && equipCommonApis(taro, global, config)\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"91-apisforeach-需要-promisify-的-api-逻辑",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#91-apisforeach-需要-promisify-的-api-逻辑",children:"#"}),"9.1 apis.forEach 需要 promisify 的 api 逻辑"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// packages/shared/src/native-apis.ts\napis.forEach(key => {\n    if (_needPromiseApis.has(key)) {\n      const originKey = key\n      taro[originKey] = (options: Record<string, any> | string = {}, ...args) => {\n        let key = originKey\n\n        // 第一个参数 options 为字符串，单独处理\n        if (typeof options === 'string') {\n          if (args.length) {\n            return global[key](options, ...args)\n          }\n          return global[key](options)\n        }\n\n        // 改变 key 或 option 字段，如需要把支付宝标准的字段对齐微信标准的字段\n        if (config.transformMeta) {\n          const transformResult = config.transformMeta(key, options)\n          key = transformResult.key\n          ; (options as Record<string, any>) = transformResult.options\n          // 新 key 可能不存在\n          if (!global.hasOwnProperty(key)) {\n            return nonsupport(key)()\n          }\n        }\n\n        let task: any = null\n        const obj: Record<string, any> = Object.assign({}, options)\n\n        // 为页面跳转相关的 API 设置一个随机数作为路由参数。为了给 runtime 区分页面。\n        setUniqueKeyToRoute(key, options)\n\n        // Promise 化\n        const p: any = new Promise((resolve, reject) => {\n          // 省略...，拆开在下方\n        })\n\n        // 给 promise 对象挂载属性\n        if (['uploadFile', 'downloadFile'].includes(key)) {\n          // 省略实现...\n        }\n        return p\n      }\n    } else {\n    	// 拆开，放在下方\n    }\n  })\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nonsupport"})," 函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/utils.ts\nexport function nonsupport (api) {\n  return function () {\n    console.warn(`小程序暂不支持 ${api}`)\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"promisify"})," 具体实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Promise 化\nconst p: any = new Promise((resolve, reject) => {\n	obj.success = res => {\n		config.modifyAsyncResult?.(key, res)\n		options.success?.(res)\n		if (key === 'connectSocket') {\n			resolve(\n				Promise.resolve().then(() => task ? Object.assign(task, res) : res)\n			)\n		} else {\n			resolve(res)\n		}\n	}\n	obj.fail = res => {\n		options.fail?.(res)\n		reject(res)\n	}\n	obj.complete = res => {\n		options.complete?.(res)\n	}\n	if (args.length) {\n		task = global[key](obj, ...args)\n	} else {\n		task = global[key](obj)\n	}\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上传和下载文件的 ",(0,s.jsx)(n.code,{children:"API"})," 需要特殊处理，因为它们返回的是 ",(0,s.jsx)(n.code,{children:"Task"})," 对象，需要将 ",(0,s.jsx)(n.code,{children:"Task"})," 对象的属性和方法挂载到 ",(0,s.jsx)(n.code,{children:"Promise"})," 对象上。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 给 promise 对象挂载属性\nif (['uploadFile', 'downloadFile'].includes(key)) {\n	equipTaskMethodsIntoPromise(task, p)\n	p.progress = cb => {\n		task?.onProgressUpdate(cb)\n		return p\n	}\n	p.abort = cb => {\n		cb?.()\n		task?.abort()\n		return p\n	}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"equipTaskMethodsIntoPromise"})," 方法的实现如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\n/**\n * 将Task对象中的方法挂载到promise对象中，适配小程序api原生返回结果\n * @param task Task对象 {RequestTask | DownloadTask | UploadTask}\n * @param promise Promise\n */\nfunction equipTaskMethodsIntoPromise (task, promise) {\n  if (!task || !promise) return\n  const taskMethods = ['abort', 'onHeadersReceived', 'offHeadersReceived', 'onProgressUpdate', 'offProgressUpdate', 'onChunkReceived', 'offChunkReceived']\n  task && taskMethods.forEach(method => {\n    if (method in task) {\n      promise[method] = task[method].bind(task)\n    }\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - wx.uploadFile"})," |\n",(0,s.jsx)(n.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/UploadTask.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - 返回值 UploadTask"})," |\n",(0,s.jsx)(n.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/download/wx.downloadFile.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - wx.downloadFile"})," |\n",(0,s.jsx)(n.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/download/DownloadTask.html",rel:"noopener noreferrer",target:"_blank",children:"文档 - 返回值 DownloadTask"})," |"]}),"\n",(0,s.jsxs)(n.h3,{id:"92-apisforeach-不需要-promisify-的-api-逻辑",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#92-apisforeach-不需要-promisify-的-api-逻辑",children:"#"}),"9.2 apis.forEach 不需要 promisify 的 api 逻辑"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/native-apis.ts\nif (_needPromiseApis.has(key)) {\n	// 省略，上方\n} else {\n	let platformKey = key\n	// 改变 key 或 option 字段，如需要把支付宝标准的字段对齐微信标准的字段\n	if (config.transformMeta) {\n		platformKey = config.transformMeta(key, {}).key\n	}\n\n	// API 不存在\n	if (!global.hasOwnProperty(platformKey)) {\n		taro[key] = nonsupport(key)\n		return\n	}\n	if (isFunction(global[key])) {\n		taro[key] = (...args) => {\n			if (config.handleSyncApis) {\n				return config.handleSyncApis(key, global, args)\n			} else {\n				return global[platformKey].apply(global, args)\n			}\n		}\n	} else {\n		// 属性类型\n		taro[key] = global[platformKey]\n	}\n}\n\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"93-挂载常用-api",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#93-挂载常用-api",children:"#"}),"9.3 挂载常用 API"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function processApis (taro, global, config: IProcessApisIOptions = {}) {\n	// 省略若干代码...\n	// 最后一行代码\n	!config.isOnlyPromisify && equipCommonApis(taro, global, config)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isOnlyPromisify"})," 参数为 ",(0,s.jsx)(n.code,{children:"true"}),"，表示只 ",(0,s.jsx)(n.code,{children:"promisify"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们来看 ",(0,s.jsx)(n.code,{children:"equipCommonApis"})," 的具体实现。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * 挂载常用 API\n * @param taro Taro 对象\n * @param global 小程序全局对象，如微信的 wx，支付宝的 my\n */\nfunction equipCommonApis (taro, global, apis: Record<string, any> = {}) {\n  //   省略若干代码\n  taro.canIUseWebp = getCanIUseWebp(taro)\n  taro.getCurrentPages = getCurrentPages || nonsupport('getCurrentPages')\n  taro.getApp = getApp || nonsupport('getApp')\n  taro.env = global.env || {}\n\n  // 添加request 和 拦截器\n  // request & interceptors\n  const request = apis.request || getNormalRequest(global)\n  function taroInterceptor (chain) {\n    return request(chain.requestParams)\n  }\n  const link = new taro.Link(taroInterceptor)\n  taro.request = link.request.bind(link)\n  taro.addInterceptor = link.addInterceptor.bind(link)\n  taro.cleanInterceptors = link.cleanInterceptors.bind(link)\n\n  try {\n    taro.requirePlugin = requirePlugin || nonsupport('requirePlugin')\n  } catch (error) {\n    taro.requirePlugin = nonsupport('requirePlugin')\n  }\n  taro.miniGlobal = taro.options.miniGlobal = global\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["添加一些公共的 API。",(0,s.jsx)(n.a,{href:"https://taro-docs.jd.com/docs/next/apis/framework/getCurrentPages",rel:"noopener noreferrer",target:"_blank",children:"Taro 文档 有这些 API"}),"。",(0,s.jsx)(n.code,{children:"request"})," 和拦截器等。",(0,s.jsx)(n.code,{children:"request"})," 这部分的具体实现，相对比较复杂，我们后续再单独写一篇文章来讲述。"]}),"\n",(0,s.jsxs)(n.h3,{id:"94-tarojsplugin-inject-插件注入公共的组件api-等逻辑",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#94-tarojsplugin-inject-插件注入公共的组件api-等逻辑",children:"#"}),"9.4 @tarojs/plugin-inject 插件注入公共的组件、API 等逻辑"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以搜索 ",(0,s.jsx)(n.code,{children:"taro"})," 源码中 ",(0,s.jsx)(n.code,{children:"isOnlyPromisify"})," 查找到 ",(0,s.jsx)(n.code,{children:"processApis"})," 传入 ",(0,s.jsx)(n.code,{children:"isOnlyPromisify"})," 为 ",(0,s.jsx)(n.code,{children:"true"}),"。只在 ",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/main/packages/taro-plugin-inject/README.md",rel:"noopener noreferrer",target:"_blank",children:"@tarojs/plugin-inject"})," 插件使用"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"可以为小程序平台注入公共的组件、API 等逻辑"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-plugin-inject/src/runtime.ts\nimport { mergeInternalComponents, mergeReconciler, processApis } from '@tarojs/shared'\n\nimport { needPromiseApis, noPromiseApis } from './apis-list'\nimport { components } from './components'\n\nconst hostConfig = {\n  initNativeApi (taro) {\n    const global = taro.miniGlobal\n    processApis(taro, global, {\n      noPromiseApis,\n      needPromiseApis,\n      isOnlyPromisify: true\n    })\n  }\n}\n\nmergeReconciler(hostConfig)\nmergeInternalComponents(components)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们来看具体是如何实现支持开发者自定义 ",(0,s.jsx)(n.code,{children:"API"})," 的。"]}),"\n",(0,s.jsxs)(n.p,{children:["添加 ",(0,s.jsx)(n.code,{children:"asyncApis"})," 也就是 ",(0,s.jsx)(n.code,{children:"needPromiseApis"})," 字段。"]}),"\n",(0,s.jsxs)(n.p,{children:["插件支持为小程序新增 ",(0,s.jsx)(n.strong,{children:"异步的"})," API。"]}),"\n",(0,s.jsx)(n.p,{children:"用法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const config = {\n  plugins: [\n    ['@tarojs/plugin-inject', {\n      // 配置需要新增的 API\n      asyncApis: ['b']\n    }]\n  ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"运行时即可调用此新增的 API："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"Taro.b()\n  .then(() => {})\n  .catch(() => {})\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"apis-list.ts"})," 文件默认内容如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-plugin-inject/src/apis-list.ts\nexport const noPromiseApis = new Set([])\nexport const needPromiseApis = new Set([])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["调用 ",(0,s.jsx)(n.code,{children:"@tarojs/plugin-inject"})," 插件时会调用 ",(0,s.jsx)(n.code,{children:"injectApis"})," 函数，修改这个文件里的 ",(0,s.jsx)(n.code,{children:"needPromiseApis"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-plugin-inject/src/index.ts\nfunction injectApis (fs, syncApis, asyncApis) {\n  fs.writeFileSync(path.resolve(__dirname, '../dist/apis-list.js'), `\nexport const noPromiseApis = new Set(${syncApis ? JSON.stringify(syncApis) : JSON.stringify([])});\nexport const needPromiseApis = new Set(${asyncApis ? JSON.stringify(asyncApis) : JSON.stringify([])});\n`)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这一步即可注入开发者自定义的公共的组件和 ",(0,s.jsx)(n.code,{children:"API"})," 等。"]}),"\n",(0,s.jsxs)(n.p,{children:["后续有时间再单独写一篇文章分析 ",(0,s.jsx)(n.code,{children:"@tarojs/plugin-inject"})," 的具体实现，这里限于篇幅就不详细讲述了。"]}),"\n",(0,s.jsxs)(n.h2,{id:"10-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-总结",children:"#"}),"10. 总结"]}),"\n",(0,s.jsx)(n.p,{children:"我们最后来总结一下整个过程。"}),"\n",(0,s.jsxs)(n.p,{children:["端平台插件运行时 ",(0,s.jsx)(n.code,{children:"mergeReconciler(hostConfig)"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/utils.ts\nimport { hooks } from './runtime-hooks'\nexport function mergeReconciler (hostConfig, hooksForTest?) {\n  const obj = hooksForTest || hooks\n  const keys = Object.keys(hostConfig)\n  keys.forEach(key => {\n    obj.tap(key, hostConfig[key])\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"class TaroHooks"}),"(实例对象",(0,s.jsx)(n.code,{children:"hooks"}),") 继承自 ",(0,s.jsx)(n.code,{children:"Events"}),"，",(0,s.jsx)(n.code,{children:"tap"})," 注册事件回调，",(0,s.jsx)(n.code,{children:"call"})," 调用事件。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Events"})," 机制的好处在于解耦。缺点是维护成本较高，可能消耗内存较多。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hostConfig"})," 对象中存在 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 函数调用 ",(0,s.jsx)(n.code,{children:"processApis"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro/index.js\nconst { hooks } = require('@tarojs/runtime')\nconst taro = require('@tarojs/api').default\n\nif (hooks.isExist('initNativeApi')) {\n  hooks.call('initNativeApi', taro)\n}\n\nmodule.exports = taro\nmodule.exports.default = module.exports\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@tarojs/taro"})," ",(0,s.jsx)(n.code,{children:"call"})," 调用 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 函数。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@tarojs/taro"})," 最终会调用不同小程序端的运行时注册是事件。会调用 ",(0,s.jsx)(n.code,{children:"hostConfig"})," 中的 ",(0,s.jsx)(n.code,{children:"initNativeApi"})," 函数中的 ",(0,s.jsx)(n.code,{children:"processApis"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"processApis(taro, global, config)"}),"："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["挂载小程序平台公共的小程序 API 到 ",(0,s.jsx)(n.code,{children:"Taro"})," 对象上，需要 ",(0,s.jsx)(n.code,{children:"needPromiseApis"})," 异步 API，",(0,s.jsx)(n.code,{children:"promisify"})," 转换返回 ",(0,s.jsx)(n.code,{children:"Promise"})," 对象。传入一些配置修改 apis 等，支持抹平平台差异等。"]}),"\n",(0,s.jsxs)(n.li,{children:["挂载常用的小程序全局对象属性 到 ",(0,s.jsx)(n.code,{children:"Taro"})," 对象上。"]}),"\n",(0,s.jsxs)(n.li,{children:["挂载开发者传入的小程序 API 到 ",(0,s.jsx)(n.code,{children:"Taro"})," 对象上，",(0,s.jsx)(n.code,{children:"@tarojs/plugin-inject"})," 插件支持开发者自定义的公共组件和 API 等。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"11-参考",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-参考",children:"#"}),"11. 参考"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/platform-plugin/",rel:"noopener noreferrer",target:"_blank",children:"Taro文档 - 端平台插件"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,s.jsx)(n.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后可以持续关注我",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(a,e)})):a(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["taro%2Fnative-apis%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-taro-文档---api-说明",text:"2. Taro 文档 - API 说明",depth:2},{id:"3-tarojstaro-taro-入口",text:"3. @tarojs/taro taro 入口",depth:2},{id:"4-new-weapp-端平台插件",text:"4. new Weapp 端平台插件",depth:2},{id:"5-运行时-runtimets",text:"5. 运行时 runtime.ts",depth:2},{id:"6-mergereconciler-函数",text:"6. mergeReconciler 函数",depth:2},{id:"7-hostconfig-配置对象",text:"7. hostConfig 配置对象",depth:2},{id:"8-initnativeapi-初始化原始-api",text:"8. initNativeApi 初始化原始 api",depth:2},{id:"9-processapis-处理-apis",text:"9. processApis 处理 apis",depth:2},{id:"91-apisforeach-需要-promisify-的-api-逻辑",text:"9.1 apis.forEach 需要 promisify 的 api 逻辑",depth:3},{id:"92-apisforeach-不需要-promisify-的-api-逻辑",text:"9.2 apis.forEach 不需要 promisify 的 api 逻辑",depth:3},{id:"93-挂载常用-api",text:"9.3 挂载常用 API",depth:3},{id:"94-tarojsplugin-inject-插件注入公共的组件api-等逻辑",text:"9.4 @tarojs/plugin-inject 插件注入公共的组件、API 等逻辑",depth:3},{id:"10-总结",text:"10. 总结",depth:2},{id:"11-参考",text:"11. 参考",depth:2}],title:"Taro 源码揭秘：6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?",headingTitle:"Taro 源码揭秘：6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(e,n,r){r.d(n,{Z:()=>c});var s=r(52676),i=r(75271),o=r(92815);r(18544);let t={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,r){let s=Object.keys(t).includes(n)?n:r;return t[s](e)}let c=e=>{let{defaultLocale:n="en-US"}=e,r=(0,o.Vi)().page.readingTimeData,t=(0,o.Jr)(),c=(0,o.e7)(),[l,p]=(0,i.useState)(a(r,t,n));return(0,i.useEffect)(()=>{p(a(r,t,n))},[t,r]),(0,s.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:l})}}}]);