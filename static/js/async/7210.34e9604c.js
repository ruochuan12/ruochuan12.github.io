"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["7210"],{19798:function(e,n,r){r.r(n),r.d(n,{default:()=>E});var s=r(52676),i=r(40453),t=r(20713);let a=r.p+"static/image/kernal.c7dc45a9.png",c=r.p+"static/image/pnpm-i-error.1c6a8d60.png",l=r.p+"static/image/pnpm-build.a8cb05fc.png",o=r.p+"static/image/vscode-debugger.a8774241.png",d=r.p+"static/image/binding-error.1e66f90d.png",h=r.p+"static/image/binding-rust.dfb35832.png",p=r.p+"static/image/vscode-console.093ba6d1.png",g=r.p+"static/image/parseArgs-1.8545c5d6.png",j=r.p+"static/image/presets.e4be1a18.png",x=r.p+"static/image/parseArgs-2.6853a7b2.png",u=r.p+"static/image/createSwcRegister.df5d3d58.png",m=r.p+"static/image/global-config.e19c6e9e.png",f=r.p+"static/image/initConfig.e68bac7f.png",b=r.p+"static/image/parseArgs-3.500b260b.png",k=r.p+"static/image/parseArgs-4.ed02e5c9.png",_=r.p+"static/image/runOpts.a242462a.png",P=r.p+"static/image/plugin-methods.da68d95d.png",v=r.p+"static/image/plugin-hooks.3b6061f8.png",N=r.p+"static/image/command-help.d3695805.png",w=r.p+"static/image/ppt.2be3caea.png";function C(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",img:"img",ul:"ul",li:"li",input:"input",pre:"pre",blockquote:"blockquote",h3:"h3",h4:"h4",ol:"ol",hr:"hr",strong:"strong"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"taro-源码揭秘1-揭开整个架构的入口-cli--taro-init-初始化项目的秘密",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘1-揭开整个架构的入口-cli--taro-init-初始化项目的秘密",children:"#"}),"Taro 源码揭秘：1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"]}),"\n",(0,s.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["截至目前（",(0,s.jsx)(n.code,{children:"2024-07-17"}),"），",(0,s.jsx)(n.code,{children:"taro"})," 正式版是 ",(0,s.jsx)(n.code,{children:"3.6.34"}),"，",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。文章提到将于 2024 年第二季度，发布 ",(0,s.jsx)(n.code,{children:"4.x"}),"。目前已经发布 ",(0,s.jsx)(n.code,{children:"4.x"}),"。所以我们直接学习 ",(0,s.jsx)(n.code,{children:"main"})," 分支最新版本是 ",(0,s.jsx)(n.code,{children:"4.0.2"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://taro-docs.jd.com/blog/2023/03/29/D2_17",rel:"noopener noreferrer",target:"_blank",children:"多编译内核生态下的极速研发体验"})," 官方博客有如下图。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"多编译内核架构",src:a})}),"\n",(0,s.jsxs)(n.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"学完本文，你将学到："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. 学会通过两种方式调试 taro 源码\n2. 学会入口 taro-cli 具体实现方式\n3. 学会 cli init 命令实现原理，读取用户项目配置文件和用户全局配置文件\n4. 学会 taro-service kernal （内核）解耦实现\n5. 初步学会 taro 插件架构，学会如何编写一个 taro 插件\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"2-准备工作",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-准备工作",children:"#"}),"2. 准备工作"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 克隆项目\ngit clone https://github.com/NervJS/taro.git\n# 切换到分支 main\ngit checkout main\n# 写文章时，项目当前 hash\ngit checkout f53250b68f007310bf098e77c6113e2012983e82\n# Merge branch 'main' into 4.x\n# 写文章时，当前版本\n# 4.0.2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["看一个开源项目，第一步应该是先看 ",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro.git",rel:"noopener noreferrer",target:"_blank",children:"README.md"})," 再看 ",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/4.x/CONTRIBUTING.md",rel:"noopener noreferrer",target:"_blank",children:"贡献文档"})," 和 ",(0,s.jsx)(n.code,{children:"package.json"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"环境准备"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["需要安装 ",(0,s.jsx)(n.a,{href:"https://nodejs.org/en/",rel:"noopener noreferrer",target:"_blank",children:"Node.js 16"}),"（建议安装 ",(0,s.jsx)(n.code,{children:"16.20.0"})," 及以上版本）及 ",(0,s.jsx)(n.a,{href:"https://pnpm.io/zh/installation",rel:"noopener noreferrer",target:"_blank",children:"pnpm 7"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我使用的环境：",(0,s.jsx)(n.code,{children:"mac"}),"，当然 ",(0,s.jsx)(n.code,{children:"Windows"})," 一样可以。"]}),"\n",(0,s.jsxs)(n.p,{children:["一般用 ",(0,s.jsx)(n.a,{href:"https://github.com/nvm-sh/nvm",rel:"noopener noreferrer",target:"_blank",children:"nvm"})," 管理 ",(0,s.jsx)(n.code,{children:"node"})," 版本。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-zsh",children:"nvm install 18\nnvm use 18\n# 可以把 node 默认版本设置为 18，调试时会使用默认版本\nnvm alias default 18\n\npnpm -v\n# 9.1.1\nnode -v\n# v18.20.2\n\ncd taro\n# 安装依赖\npnpm i\n# 如果网络不好，一直安装不上可以指定国内镜像站，速度比较快\npnpm i --registry=https://registry.npmmirror.com\n# 编译构建\npnpm build\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 删除根目录的 node_modules 和所有 workspace 里的 node_modules\n$ pnpm run clear-all\n# 对应的是：rimraf **/node_modules\n# mac 下可以用 rm -rf **/node_modules\n"})}),"\n",(0,s.jsx)(n.p,{children:"安装依赖可能会报错。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pnpm i error",src:c})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'Failed to set up Chromium r1108766! Set "PUPPETEER_SKIP_DOWNLOAD" env variable to skip download.\n'})}),"\n",(0,s.jsx)(n.p,{children:"通过谷歌等搜索引擎可以找到解决方法。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/63187371/puppeteer-is-not-able-to-install-error-failed-to-set-up-chromium-r782078-set",rel:"noopener noreferrer",target:"_blank",children:"stackoverflow"})}),"\n",(0,s.jsxs)(n.p,{children:["Mac : ",(0,s.jsx)(n.code,{children:"export PUPPETEER_SKIP_DOWNLOAD='true'"}),"\nWindows: ",(0,s.jsx)(n.code,{children:"SET PUPPETEER_SKIP_DOWNLOAD='true'"})]}),"\n",(0,s.jsx)(n.p,{children:"pnpm build 完成，如下图所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pnpm build 完成",src:l})}),"\n",(0,s.jsxs)(n.h2,{id:"3-调试",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-调试",children:"#"}),"3. 调试"]}),"\n",(0,s.jsx)(n.p,{children:"package.json"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// packages/taro-cli/package.json\n{\n	"name": "@tarojs/cli",\n	"version": "4.0.0",\n	"description": "cli tool for taro",\n	"main": "index.js",\n	"types": "dist/index.d.ts",\n	"bin": {\n		"taro": "bin/taro"\n	}\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"31-入口文件-packagestaro-clibintaro",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-入口文件-packagestaro-clibintaro",children:"#"}),"3.1 入口文件 packages/taro-cli/bin/taro"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// packages/taro-cli/bin/taro\n\n#! /usr/bin/env node\n\nrequire("../dist/util").printPkgVersion();\n\nconst CLI = require("../dist/cli").default;\n\nnew CLI().run();\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"32-调试方法-1-javascript-debug-terminal",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-调试方法-1-javascript-debug-terminal",children:"#"}),"3.2 调试方法 1 JavaScript Debug Terminal"]}),"\n",(0,s.jsxs)(n.p,{children:["可参考我的文章",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7030584939020042254",rel:"noopener noreferrer",target:"_blank",children:"新手向：前端程序员必学基本技能——调试 JS 代码"}),"，或者",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7212263304394981432",rel:"noopener noreferrer",target:"_blank",children:"据说 90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码"})]}),"\n",(0,s.jsx)(n.p,{children:"简而言之就是以下步骤："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. 找到入口文件设置断点\n2. ctrl + `\\`` (反引号) 打开终端，配置`JavaScript调试终端`\n3. 在终端输入 `node` 相关命令，这里用 `init` 举例\n4. 尽情调试源码\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node ./packages/taro-cli/bin/taro init taro-init-debug\n"})}),"\n",(0,s.jsxs)(n.p,{children:["本文将都是使用 ",(0,s.jsx)(n.code,{children:"init"})," 命令作为示例。"]}),"\n",(0,s.jsx)(n.p,{children:"如下图所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"vscode 调试源码",src:o})}),"\n",(0,s.jsxs)(n.p,{children:["也可以使用项目中提供的测试用例 ",(0,s.jsx)(n.code,{children:"packages/taro-cli/src/__tests__/cli.spec.ts"})," 提前打断点调试源码。",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/main/CONTRIBUTING.md#4-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95",rel:"noopener noreferrer",target:"_blank",children:"贡献文档-单元测试"}),"中有提到："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"package.json"})," 中设置了 ",(0,s.jsx)(n.code,{children:"test:ci"})," 命令的子包都配备了单元测试。\n开发者在修改这些包后，请运行 ",(0,s.jsx)(n.code,{children:"pnpm --filter [package-name] run test:ci"}),"，检查测试用例是否都能通过。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# JavaScript Debug Terminal\npnpm --filter @tarojs/cli run test:ci\n"})}),"\n",(0,s.jsx)(n.p,{children:"调试和上图类似，就不截调试图了。"}),"\n",(0,s.jsxs)(n.p,{children:["调试时应该会报错 ",(0,s.jsx)(n.code,{children:"binding"})," ",(0,s.jsx)(n.code,{children:"taro.[os-platform].node"}),"。如下图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"binding-error",src:d})}),"\n",(0,s.jsxs)(n.p,{children:["运行等过程报错，不要慌。可能是我们遗漏了一些细节，贡献文档等应该会给出答案。所以再来看下 ",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/4.x/CONTRIBUTING.md#10-rust-%E9%83%A8%E5%88%86",rel:"noopener noreferrer",target:"_blank",children:"贡献文档-10-rust-部分"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"binding-rust",src:h})}),"\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.a,{href:"https://rustup.rs",rel:"noopener noreferrer",target:"_blank",children:"rustup"})," 找到安装命令："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n"})}),"\n",(0,s.jsxs)(n.p,{children:["安装完成后，执行 ",(0,s.jsx)(n.code,{children:"pnpm run build:binding:debug"})," 或 ",(0,s.jsx)(n.code,{children:"pnpm run binding:release"})," 编译出文件：",(0,s.jsx)(n.code,{children:"crates/native_binding/taro.darwin-arm64.node"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"就完美解决了，调试时不会报错了。"}),"\n",(0,s.jsxs)(n.h3,{id:"33-调试方式-2-配置-vscodelaunchjson",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-调试方式-2-配置-vscodelaunchjson",children:"#"}),"3.3 调试方式 2 配置 .vscode/launch.json"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/debug-config/",rel:"noopener noreferrer",target:"_blank",children:"taro 文档 - 单步调测配置"}),"\n写的挺好的，通过配置 ",(0,s.jsx)(n.code,{children:"launch.json"})," 来调试，在此就不再赘述了。"]}),"\n",(0,s.jsxs)(n.p,{children:["不过补充一条：",(0,s.jsx)(n.code,{children:"launch.json"})," 文件可以添加一条 ",(0,s.jsx)(n.code,{children:'"console": "integratedTerminal"'}),"（集成终端）配置，就可以在调试终端输入内容。",(0,s.jsx)(n.code,{children:"args"})," 参数添加 ",(0,s.jsx)(n.code,{children:"init"})," 和指定要初始化项目的文件夹。当然调试其他的时候也可以修改为其他参数。比如",(0,s.jsx)(n.code,{children:'args: ["build", "--type", "weapp", "--watch"]'}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"version": "0.2.0",\n	"configurations": [\n		{\n			"type": "node",\n			"request": "launch",\n			"name": "CLI debug",\n			"program": "${workspaceFolder}/packages/taro-cli/bin/taro",\n			// "cwd": "${project absolute path}",\n			"args": [\n				"init",\n				"taro-init-debug",\n			],\n			"skipFiles": ["<node_internals>/**"],\n			"console": "integratedTerminal"\n		}\n	]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_node-console",rel:"noopener noreferrer",target:"_blank",children:"vscode nodejs 调试"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"console- 启动程序的控制台（internalConsole，integratedTerminal，externalTerminal）。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"vscode console",src:p})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// packages/taro-cli/bin/taro\n\n#! /usr/bin/env node\n\nrequire("../dist/util").printPkgVersion();\n\nconst CLI = require("../dist/cli").default;\n\nnew CLI().run();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["我们跟着断点进入，入口文件中的第一句",(0,s.jsx)(n.code,{children:'require("../dist/util").printPkgVersion();'})," ",(0,s.jsx)(n.code,{children:"printPkgVersion"})," 函数。"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-taro-clisrcutilsindexts",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-taro-clisrcutilsindexts",children:"#"}),"4. taro-cli/src/utils/index.ts"]}),"\n",(0,s.jsx)(n.p,{children:"工具函数"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// packages/taro-cli/src/util/index.ts\nimport * as path from "path";\n\nexport function getRootPath(): string {\n	return path.resolve(__dirname, "../../");\n}\n\nexport function getPkgVersion(): string {\n	return require(path.join(getRootPath(), "package.json")).version;\n}\n\nexport function printPkgVersion() {\n	console.log(`\uD83D\uDC7D Taro v${getPkgVersion()}`);\n	console.log();\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["可以看出这句输出的是 ",(0,s.jsx)(n.code,{children:"taro/packages/taro-cli/package.json"})," 的版本号。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"\uD83D\uDC7D Taro v4.0.0\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们继续跟着断点，进入第二第三句，可以进入到 ",(0,s.jsx)(n.code,{children:"packages/taro-cli/src/cli.ts"})," 这个文件。"]}),"\n",(0,s.jsxs)(n.h2,{id:"5-cli-整体结构",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-cli-整体结构",children:"#"}),"5. CLI 整体结构"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"taro-cli"})," 对应的文件路径是："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"packages/taro-cli/src/cli.ts"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们先来看下这个文件的整体结构。",(0,s.jsx)(n.code,{children:"class CLI"})," 一个 appPath 属性（一般指 ",(0,s.jsx)(n.code,{children:"taro"})," 工作目录），两个函数 ",(0,s.jsx)(n.code,{children:"run"})," 和 ",(0,s.jsx)(n.code,{children:"parseArgs"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// packages/taro-cli/src/cli.ts\nexport default class CLI {\n	appPath: string;\n	constructor(appPath) {\n		this.appPath = appPath || process.cwd();\n	}\n\n	run() {\n		return this.parseArgs();\n	}\n\n	async parseArgs() {\n		const args = minimist(process.argv.slice(2), {\n			alias: {\n				// 省略一些别名设置 ...\n			},\n			boolean: ["version", "help", "disable-global-config"],\n			default: {\n				build: true,\n			},\n		});\n		const _ = args._;\n		// init、build 等\n		const command = _[0];\n		if (command) {\n			// 省略若干代码\n		} else {\n			if (args.h) {\n				// 输出帮助信息\n				// 省略代码\n			} else if (args.v) {\n				// 输出版本号\n				console.log(getPkgVersion());\n			}\n		}\n	}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["使用了",(0,s.jsx)(n.a,{href:"https://github.com/minimistjs/minimist",rel:"noopener noreferrer",target:"_blank",children:"minimist"}),"，参数解析工具。"]}),"\n",(0,s.jsxs)(n.p,{children:["同类工具还有：\n",(0,s.jsx)(n.a,{href:"https://github.com/tj/commander.js",rel:"noopener noreferrer",target:"_blank",children:"commander"}),"，命令行工具。功能齐全的框架，提供类似 git 的子命令系统，自动生成帮助信息等。有很多知名的 ",(0,s.jsx)(n.code,{children:"cli"})," 都是用的这个",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/browse/depended/commander",rel:"noopener noreferrer",target:"_blank",children:"commander"}),"。比如：",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli/bin/vue.js#L37",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vue-cli"})}),"、",(0,s.jsx)(n.a,{href:"https://github.com/webpack/webpack-cli/blob/master/packages/webpack-cli/src/webpack-cli.ts#L64",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"webpack-cli"})})," 和 ",(0,s.jsx)(n.a,{href:"https://github.com/facebook/create-react-app/blob/main/packages/create-react-app/createReactApp.js#L59",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"create-react-app"})})," 用的是这个。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/cacjs/cac",rel:"noopener noreferrer",target:"_blank",children:"cac"}),"，类似 ",(0,s.jsx)(n.code,{children:"Commander.js"})," 但更轻巧、现代，支持插件。也有很多使用这个",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/cac?activeTab=dependents",rel:"noopener noreferrer",target:"_blank",children:"cac npm"}),"，比如",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/vite?activeTab=dependencies",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"vite"})})," 使用的是这个。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/yargs/yargs",rel:"noopener noreferrer",target:"_blank",children:"yargs"}),"，交互式命令行工具。功能强大的框架，但显得过于臃肿。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"cli.run"})," 函数最终调用的是 ",(0,s.jsx)(n.code,{children:"cli.parseArgs"})," 函数。我们接着来看 ",(0,s.jsx)(n.code,{children:"parseArgs"})," 函数。"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-cli-parseargs",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-cli-parseargs",children:"#"}),"6. cli parseArgs"]}),"\n",(0,s.jsxs)(n.h3,{id:"61-presets-预设插件集合",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-presets-预设插件集合",children:"#"}),"6.1 presets 预设插件集合"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"parseArgs-1",src:g})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"presets"})," 对应的目录结构如图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"presets",src:j})}),"\n",(0,s.jsxs)(n.h3,{id:"62-config",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-config",children:"#"}),"6.2 Config"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"parseArgs-2",src:x})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"64-78"})," 行代码，代码量相对较少，就截图同时顺便直接放代码了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// packages/taro-cli/src/cli.ts\n// 这里解析 dotenv 以便于 config 解析时能获取 dotenv 配置信息\nconst expandEnv = dotenvParse(appPath, args.envPrefix, mode);\n\nconst disableGlobalConfig = !!(\n	args["disable-global-config"] ||\n	DISABLE_GLOBAL_CONFIG_COMMANDS.includes(command)\n);\n\nconst configEnv = {\n	mode,\n	command,\n};\nconst config = new Config({\n	appPath: this.appPath,\n	disableGlobalConfig: disableGlobalConfig,\n});\nawait config.init(configEnv);\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dotenvParse"})," 函数简单来说就是通过 ",(0,s.jsx)(n.a,{href:"https://github.com/motdotla/dotenv",rel:"noopener noreferrer",target:"_blank",children:"dotenv"})," 和 ",(0,s.jsx)(n.a,{href:"https://github.com/motdotla/dotenv-expand",rel:"noopener noreferrer",target:"_blank",children:"dotenv-expand"})," 解析 ",(0,s.jsx)(n.code,{children:".env"}),"、",(0,s.jsx)(n.code,{children:".env.development"}),"、",(0,s.jsx)(n.code,{children:".env.production"})," 等文件和变量的。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dotenv"})," 是一个零依赖模块，可将 ",(0,s.jsx)(n.code,{children:".env"})," 文件中的环境变量加载到 ",(0,s.jsx)(n.code,{children:"process.env"})," 中。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我之前写过一篇 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7045057475845816357",rel:"noopener noreferrer",target:"_blank",children:"面试官：项目中常用的 .env 文件原理是什么？如何实现？"})]}),"\n",(0,s.jsxs)(n.p,{children:["接着我们来看 ",(0,s.jsx)(n.code,{children:"Config"})," 类。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Config.ts\nexport default class Config {\n	appPath: string;\n	configPath: string;\n	initialConfig: IProjectConfig;\n	initialGlobalConfig: IProjectConfig;\n	isInitSuccess: boolean;\n	disableGlobalConfig: boolean;\n\n	constructor(opts: IConfigOptions) {\n		this.appPath = opts.appPath;\n		this.disableGlobalConfig = !!opts?.disableGlobalConfig;\n	}\n	async init(configEnv: { mode: string; command: string }) {\n		// 代码省略\n	}\n	initGlobalConfig() {\n		// 代码省略\n	}\n	getConfigWithNamed(platform, configName) {\n		// 代码省略\n	}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Config"})," 构造函数有两个属性。\n",(0,s.jsx)(n.code,{children:"appPath"})," 是 ",(0,s.jsx)(n.code,{children:"taro"})," 项目路径。\n",(0,s.jsx)(n.code,{children:"disableGlobalConfig"})," 是禁用全局配置。"]}),"\n",(0,s.jsxs)(n.p,{children:["接着我们来看 ",(0,s.jsx)(n.code,{children:"Config"})," 类的实例上的 ",(0,s.jsx)(n.code,{children:"init"})," 方法。"]}),"\n",(0,s.jsxs)(n.h4,{id:"621-configinit-初始化配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#621-configinit-初始化配置",children:"#"}),"6.2.1 config.init 初始化配置"]}),"\n",(0,s.jsxs)(n.p,{children:["读取的是 ",(0,s.jsx)(n.code,{children:"config/index"})," ",(0,s.jsx)(n.code,{children:".ts"})," 或者 ",(0,s.jsx)(n.code,{children:".js"})," 后缀。\n判断是否禁用 ",(0,s.jsx)(n.code,{children:"disableGlobalConfig"})," 全局配置。不禁用则读取全局配置 ",(0,s.jsx)(n.code,{children:"~/.taro-global-config/index.json"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"async init (configEnv: {\n    mode: string\n    command: string\n  }) {\n    this.initialConfig = {}\n    this.initialGlobalConfig = {}\n    this.isInitSuccess = false\n    this.configPath = resolveScriptPath(path.join(this.appPath, CONFIG_DIR_NAME, DEFAULT_CONFIG_FILE))\n    if (!fs.existsSync(this.configPath)) {\n      if (this.disableGlobalConfig) return\n      this.initGlobalConfig()\n    } else {\n      createSwcRegister({\n        only: [\n          filePath => filePath.indexOf(path.join(this.appPath, CONFIG_DIR_NAME)) >= 0\n        ]\n      })\n      try {\n        const userExport = getModuleDefaultExport(require(this.configPath))\n        this.initialConfig = typeof userExport === 'function' ? await userExport(merge, configEnv) : userExport\n        this.isInitSuccess = true\n      } catch (err) {\n        console.log(err)\n      }\n    }\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"值得一提的是："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"createSwcRegister",src:u})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createSwcRegister"})," 使用了 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@swc/register",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"@swc/register"})})," 来编译 ",(0,s.jsx)(n.code,{children:"ts"})," 等转换成 ",(0,s.jsx)(n.code,{children:"commonjs"}),"。可以直接用 ",(0,s.jsx)(n.code,{children:"require"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 swc 的方法之一是通过 ",(0,s.jsx)(n.code,{children:"require"})," 钩子。",(0,s.jsx)(n.code,{children:"require"})," 钩子会将自身绑定到 ",(0,s.jsx)(n.code,{children:"node"})," 的 ",(0,s.jsx)(n.code,{children:"require"})," 并自动动态编译文件。不过现在更推荐 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@swc-node/register",rel:"noopener noreferrer",target:"_blank",children:"@swc-node/register"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export const getModuleDefaultExport = (exports) =>\n	exports.__esModule ? exports.default : exports;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"this.initialConfig = typeof userExport === 'function' ? await userExport(merge, configEnv) : userExport"}),"。这句就是 ",(0,s.jsx)(n.code,{children:"config/index.ts"})," 支持函数也支持对象的实现。"]}),"\n",(0,s.jsxs)(n.p,{children:["接着我们来看 ",(0,s.jsx)(n.code,{children:"Config"})," 类的实例上的 ",(0,s.jsx)(n.code,{children:"initGlobalConfig"})," 方法。"]}),"\n",(0,s.jsxs)(n.h4,{id:"622-configinitglobalconfig-初始化全局配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#622-configinitglobalconfig-初始化全局配置",children:"#"}),"6.2.2 config.initGlobalConfig 初始化全局配置"]}),"\n",(0,s.jsxs)(n.p,{children:["读取配置 ",(0,s.jsx)(n.code,{children:"~/.taro-global-config/index.json"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"plugins": [],\n	"presets": []\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"initGlobalConfig () {\n    const homedir = getUserHomeDir()\n    if (!homedir) return console.error('获取不到用户 home 路径')\n    const globalPluginConfigPath = path.join(getUserHomeDir(), TARO_GLOBAL_CONFIG_DIR, TARO_GLOBAL_CONFIG_FILE)\n    if (!fs.existsSync(globalPluginConfigPath)) return\n    const spinner = ora(`开始获取 taro 全局配置文件： ${globalPluginConfigPath}`).start()\n    try {\n      this.initialGlobalConfig = fs.readJSONSync(globalPluginConfigPath) || {}\n      spinner.succeed('获取 taro 全局配置成功')\n    } catch (e) {\n      spinner.stop()\n      console.warn(`获取全局配置失败，如果需要启用全局插件请查看配置文件: ${globalPluginConfigPath} `)\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getUserHomeDir"})," 函数主要是获取用户的主页路径。比如 ",(0,s.jsx)(n.code,{children:"mac"})," 中是 ",(0,s.jsx)(n.code,{children:"/Users/用户名/"}),"。\n如果支持 ",(0,s.jsx)(n.code,{children:"os.homedir()"})," 直接获取返回，如果不支持则根据各种操作系统和环境变量判断获取。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/ora",rel:"noopener noreferrer",target:"_blank",children:"ora"})," 是控制台的 loading 小动画。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"优雅的终端旋转器"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这里的是 ",(0,s.jsx)(n.code,{children:"fs"})," 是 ",(0,s.jsx)(n.code,{children:"@tarojs/helper"})," 。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Taro 编译时工具库，主要供 CLI、编译器插件使用。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["导出的 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/fs-extra",rel:"noopener noreferrer",target:"_blank",children:"fs-extra"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"fs-extra 添加本机模块中未包含的文件系统方法 fs，并为这些方法添加承诺支持 fs。它还用于 graceful-fs 防止 EMFILE 错误。它应该是 的替代品 fs。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.a,{href:"https://github.com/jprichardson/node-fs-extra/blob/master/docs/readJson-sync.md",rel:"noopener noreferrer",target:"_blank",children:"fs.readJSONSync"})," 同步读取 ",(0,s.jsx)(n.code,{children:"json"})," 的方法。"]}),"\n",(0,s.jsx)(n.p,{children:"文档中也有对这个全局参数的描述。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/next/cli/#%E5%85%A8%E5%B1%80%E6%8F%92%E4%BB%B6%E6%88%96%E6%8F%92%E4%BB%B6%E9%9B%86%E9%85%8D%E7%BD%AE",rel:"noopener noreferrer",target:"_blank",children:"全局插件或插件集配置"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"global-config",src:m})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Config"})," 部分我们基本分析完成，接下来我们学习 ",(0,s.jsx)(n.code,{children:"Kernel"})," （内核）部分。"]}),"\n",(0,s.jsxs)(n.h2,{id:"7-kernel-内核",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-kernel-内核",children:"#"}),"7. Kernel （内核）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// packages/taro-cli/src/cli.ts\n\n// 省略若干代码\nconst kernel = new Kernel({\n	appPath,\n	presets: [path.resolve(__dirname, ".", "presets", "index.js")],\n	config,\n	plugins: [],\n});\nkernel.optsPlugins ||= [];\n'})}),"\n",(0,s.jsxs)(n.p,{children:["接着我们来看 ",(0,s.jsx)(n.code,{children:"Kernel"})," 类， ",(0,s.jsx)(n.code,{children:"Kernel"})," 类继承自 ",(0,s.jsx)(n.code,{children:"Nodejs"})," 的事件模块",(0,s.jsx)(n.code,{children:"EventEmitter"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// packages/taro-service/src/Kernel.ts\nexport default class Kernel extends EventEmitter {\n	constructor(options: IKernelOptions) {\n		super();\n		this.debugger =\n			process.env.DEBUG === "Taro:Kernel"\n				? helper.createDebug("Taro:Kernel")\n				: function () {};\n		// taro 项目路径\n		this.appPath = options.appPath || process.cwd();\n		// 预设插件集合\n		this.optsPresets = options.presets;\n		// 插件\n		this.optsPlugins = options.plugins;\n		// 配置\n		this.config = options.config;\n		// 钩子，Map 存储\n		this.hooks = new Map();\n		// 存储方法\n		this.methods = new Map();\n		// 存储命令\n		this.commands = new Map();\n		// 存储平台\n		this.platforms = new Map();\n		this.initHelper();\n		this.initConfig();\n		this.initPaths();\n		this.initRunnerUtils();\n	}\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// packages/taro-helper/src/index.ts\nexport const createDebug = (id: string) => require("debug")(id);\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"this.debugger"})," 当没有配置 ",(0,s.jsx)(n.code,{children:"DEBUG"})," 环境变量时，则 ",(0,s.jsx)(n.code,{children:"debugger"})," 是空函数。配置了 ",(0,s.jsx)(n.code,{children:'process.env.DEBUG === "Taro:Kernel"'})," 为则调用的 ",(0,s.jsx)(n.code,{children:"npm"})," 包 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/debug",rel:"noopener noreferrer",target:"_blank",children:"debug"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["一个仿照 ",(0,s.jsx)(n.code,{children:"Node.js"})," 核心调试技术的微型 ",(0,s.jsx)(n.code,{children:"JavaScript"})," 调试实用程序。适用于 ",(0,s.jsx)(n.code,{children:"Node.js"})," 和 ",(0,s.jsx)(n.code,{children:"Web"})," 浏览器。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"我们接着看构造器函数里调用的几个初始化函数，基本都是顾名知义。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\ninitConfig () {\n	this.initialConfig = this.config.initialConfig\n	this.initialGlobalConfig = this.config.initialGlobalConfig\n	this.debugger('initConfig', this.initialConfig)\n}\n\ninitHelper () {\n	this.helper = helper\n	this.debugger('initHelper')\n}\n\ninitRunnerUtils () {\n	this.runnerUtils = runnerUtils\n	this.debugger('initRunnerUtils')\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\ninitPaths () {\n	this.paths = {\n		appPath: this.appPath,\n		nodeModulesPath: helper.recursiveFindNodeModules(path.join(this.appPath, helper.NODE_MODULES))\n	} as IPaths\n	if (this.config.isInitSuccess) {\n		Object.assign(this.paths, {\n		configPath: this.config.configPath,\n		sourcePath: path.join(this.appPath, this.initialConfig.sourceRoot as string),\n		outputPath: path.resolve(this.appPath, this.initialConfig.outputRoot as string)\n		})\n	}\n	this.debugger(`initPaths:${JSON.stringify(this.paths, null, 2)}`)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["初始化后的参数，如 ",(0,s.jsxs)(n.a,{href:"https://docs.taro.zone/docs/next/plugin-custom#api",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"taro"})," 官方文档 - 编写插件 api"]}),"中所示。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"initConfig",src:f})}),"\n",(0,s.jsxs)(n.h3,{id:"71-cli-kerneloptsplugins-等",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-cli-kerneloptsplugins-等",children:"#"}),"7.1 cli kernel.optsPlugins 等"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"parseArgs-3",src:b})}),"\n",(0,s.jsxs)(n.p,{children:["我们接下来看，",(0,s.jsx)(n.code,{children:"customCommand"})," 函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"72-cli-customcommand-函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-cli-customcommand-函数",children:"#"}),"7.2 cli customCommand 函数"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"parseArgs-4",src:k})}),"\n",(0,s.jsxs)(n.p,{children:["我们可以看到最终调用的是 ",(0,s.jsx)(n.code,{children:"customCommand"})," 函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// packages/taro-cli/src/commands/customCommand.ts\nimport { Kernel } from "@tarojs/service";\n\nexport default function customCommand(\n	command: string,\n	kernel: Kernel,\n	args: { _: string[]; [key: string]: any }\n) {\n	if (typeof command === "string") {\n		const options: any = {};\n		const excludeKeys = [\n			"_",\n			"version",\n			"v",\n			"help",\n			"h",\n			"disable-global-config",\n		];\n		Object.keys(args).forEach((key) => {\n			if (!excludeKeys.includes(key)) {\n				options[key] = args[key];\n			}\n		});\n\n		kernel.run({\n			name: command,\n			opts: {\n				_: args._,\n				options,\n				isHelp: args.h,\n			},\n		});\n	}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"customCommand"})," 函数移除一些 ",(0,s.jsx)(n.code,{children:"run"})," 函数不需要的参数，最终调用的是 ",(0,s.jsx)(n.code,{children:"kernal.run"})," 函数。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我们来看 ",(0,s.jsx)(n.code,{children:"kernal.run"})," 函数的具体实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"8-kernalrun-执行函数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-kernalrun-执行函数",children:"#"}),"8. kernal.run 执行函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\nasync run (args: string | { name: string, opts?: any }) {\n	// 上半部分\n    let name\n    let opts\n    if (typeof args === 'string') {\n      name = args\n    } else {\n      name = args.name\n      opts = args.opts\n    }\n    this.debugger('command:run')\n    this.debugger(`command:run:name:${name}`)\n    this.debugger('command:runOpts')\n    this.debugger(`command:runOpts:${JSON.stringify(opts, null, 2)}`)\n    this.setRunOpts(opts)\n	// 拆解下半部分\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"run"})," 函数中，开头主要是兼容两种参数传递。"]}),"\n",(0,s.jsxs)(n.h2,{id:"9-kernalsetrunopts",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-kernalsetrunopts",children:"#"}),"9. kernal.setRunOpts"]}),"\n",(0,s.jsx)(n.p,{children:"把参数先存起来。便于给插件使用。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\nsetRunOpts (opts) {\n	this.runOpts = opts\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://taro-docs.jd.com/docs/plugin-custom#ctxrunopts",rel:"noopener noreferrer",target:"_blank",children:"Taro 文档 - 编写插件 - ctx.runOpts"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"ctx.runOpts",src:_})}),"\n",(0,s.jsxs)(n.p,{children:["我们接着来看，",(0,s.jsx)(n.code,{children:"run"})," 函数的下半部分。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\nasync run (args: string | { name: string, opts?: any }) {\n    // 下半部分\n    this.debugger('initPresetsAndPlugins')\n    this.initPresetsAndPlugins()\n\n    await this.applyPlugins('onReady')\n\n    this.debugger('command:onStart')\n    await this.applyPlugins('onStart')\n\n    if (!this.commands.has(name)) {\n      throw new Error(`${name} 命令不存在`)\n    }\n\n    if (opts?.isHelp) {\n      return this.runHelp(name)\n    }\n\n    if (opts?.options?.platform) {\n      opts.config = this.runWithPlatform(opts.options.platform)\n      await this.applyPlugins({\n        name: 'modifyRunnerOpts',\n        opts: {\n          opts: opts?.config\n        }\n      })\n    }\n\n    await this.applyPlugins({\n      name,\n      opts\n    })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"run"})," 函数下半部分主要有三个函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. this.initPresetsAndPlugins() 函数，顾名知义。初始化预设插件集合和插件。\n2. this.applyPlugins() 执行插件\n3. this.runHelp() 执行 命令行的帮助信息，例：taro init --help\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们分开叙述"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"this.initPresetsAndPlugins()"}),"函数，因为此处涉及到的代码相对较多，容易影响主线流程。所以本文在此先不展开深入学习了。将放在下一篇文章中详细讲述。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["执行 ",(0,s.jsx)(n.code,{children:"this.initPresetsAndPlugins()"})," 函数之后。我们完全可以在调试时把 ",(0,s.jsx)(n.code,{children:"kernal"})," 实例对象打印出来。"]}),"\n",(0,s.jsx)(n.p,{children:"我们来看插件的注册。"}),"\n",(0,s.jsxs)(n.h2,{id:"10-kernal-ctxregistercommand-注册-init-命令",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-kernal-ctxregistercommand-注册-init-命令",children:"#"}),"10. kernal ctx.registerCommand 注册 init 命令"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// packages/taro-cli/src/presets/commands/init.ts\nimport type { IPluginContext } from "@tarojs/service";\n\nexport default (ctx: IPluginContext) => {\n	ctx.registerCommand({\n		name: "init",\n		optionsMap: {\n			"--name [name]": "项目名称",\n			"--description [description]": "项目介绍",\n			"--typescript": "使用TypeScript",\n			"--npm [npm]": "包管理工具",\n			"--template-source [templateSource]": "项目模板源",\n			"--clone [clone]": "拉取远程模板时使用git clone",\n			"--template [template]": "项目模板",\n			"--css [css]": "CSS预处理器(sass/less/stylus/none)",\n			"-h, --help": "output usage information",\n		},\n		async fn(opts) {\n			// init project\n			const { appPath } = ctx.paths;\n			const { options } = opts;\n			const {\n				// 省略若干参数\n			} = options;\n			const Project = require("../../create/project").default;\n			console.log(Project, "Project");\n			const project = new Project({\n				projectName,\n				projectDir: appPath,\n				// 省略若干参数\n			});\n\n			project.create();\n		},\n	});\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.code,{children:"ctx.registerCommand"})," 注册了一个 ",(0,s.jsx)(n.code,{children:"name"})," 为 ",(0,s.jsx)(n.code,{children:"init"})," 的命令，会存入到内核 ",(0,s.jsx)(n.code,{children:"Kernal"})," 实例对象的 ",(0,s.jsx)(n.code,{children:"hooks"})," 属性中，其中 ",(0,s.jsx)(n.code,{children:"ctx"})," 就是 ",(0,s.jsx)(n.code,{children:"Kernal"})," 的实例对象。具体实现是 ",(0,s.jsx)(n.code,{children:"fn"})," 函数。"]}),"\n",(0,s.jsxs)(n.h2,{id:"11-kernalapplyplugins-触发插件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-kernalapplyplugins-触发插件",children:"#"}),"11. kernal.applyPlugins 触发插件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\nasync applyPlugins (args: string | { name: string, initialVal?: any, opts?: any }) {\n	// 上半部分\n    let name\n    let initialVal\n    let opts\n    if (typeof args === 'string') {\n      name = args\n    } else {\n      name = args.name\n      initialVal = args.initialVal\n      opts = args.opts\n    }\n    this.debugger('applyPlugins')\n    this.debugger(`applyPlugins:name:${name}`)\n    this.debugger(`applyPlugins:initialVal:${initialVal}`)\n    this.debugger(`applyPlugins:opts:${opts}`)\n    if (typeof name !== 'string') {\n      throw new Error('调用失败，未传入正确的名称！')\n    }\n	// 拆解到下半部分\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"上半部分，主要是适配两种传参的方式。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\nasync applyPlugins (args: string | { name: string, initialVal?: any, opts?: any }) {\n	// 下半部分\n	const hooks = this.hooks.get(name) || []\n    if (!hooks.length) {\n      return await initialVal\n    }\n    const waterfall = new AsyncSeriesWaterfallHook(['arg'])\n    if (hooks.length) {\n      const resArr: any[] = []\n      for (const hook of hooks) {\n        waterfall.tapPromise({\n          name: hook.plugin!,\n          stage: hook.stage || 0,\n          // @ts-ignore\n          before: hook.before\n        }, async arg => {\n          const res = await hook.fn(opts, arg)\n          if (IS_MODIFY_HOOK.test(name) && IS_EVENT_HOOK.test(name)) {\n            return res\n          }\n          if (IS_ADD_HOOK.test(name)) {\n            resArr.push(res)\n            return resArr\n          }\n          return null\n        })\n      }\n    }\n    return await waterfall.promise(initialVal)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Taro"})," 的插件架构基于 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/tapable",rel:"noopener noreferrer",target:"_blank",children:"Tapable"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这里使用了这个函数：",(0,s.jsx)(n.code,{children:"AsyncSeriesWaterfallHook"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"The hook type is reflected in its class name. E.g., AsyncSeriesWaterfallHook allows asynchronous functions and runs them in series, passing each function’s return value into the next function."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"简言之就是异步或者同步方法串联起来，上一个函数的结果作为下一个函数的参数依次执行。依次执行。"}),"\n",(0,s.jsx)(n.p,{children:"这时让我想起一句小虎队的爱的歌词。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"喔，把你的心我的心串一串，串一株幸运草串一个同心圆..."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["举个例子用户写的插件中有多个钩子函数。比如 ",(0,s.jsx)(n.code,{children:"onReday"})," 等可以有多个。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"插件方法",src:P})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"插件 hooks",src:v})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"applyPlugins"})," 根据执行的命令 ",(0,s.jsx)(n.code,{children:"init"})," 从 ",(0,s.jsx)(n.code,{children:"hooks"})," 取出，串起来，然后依次执行插件的 ",(0,s.jsx)(n.code,{children:"fn"})," 方法。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们顺便来看一下，",(0,s.jsx)(n.code,{children:"kernal.runHelp"})," 的实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"12-kernalrunhelp-命令帮助信息",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-kernalrunhelp-命令帮助信息",children:"#"}),"12. kernal.runHelp 命令帮助信息"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"kernal.run"})," 函数中，有一个 ",(0,s.jsx)(n.code,{children:"opts.isHelp"})," 的判断，执行 ",(0,s.jsx)(n.code,{children:"kernal.runHelp"})," 方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\n// run 函数\nif (opts?.isHelp) {\n	return this.runHelp(name);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["以 ",(0,s.jsx)(n.code,{children:"taro init --help"})," 为例。输出结果如下图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"命令行 help",src:N})}),"\n",(0,s.jsx)(n.p,{children:"具体实现代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-service/src/Kernel.ts\nrunHelp (name: string) {\n    const command = this.commands.get(name)\n    const defaultOptionsMap = new Map()\n    defaultOptionsMap.set('-h, --help', 'output usage information')\n    let customOptionsMap = new Map()\n    if (command?.optionsMap) {\n      customOptionsMap = new Map(Object.entries(command?.optionsMap))\n    }\n    const optionsMap = new Map([...customOptionsMap, ...defaultOptionsMap])\n    printHelpLog(name, optionsMap, command?.synopsisList ? new Set(command?.synopsisList) : new Set())\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["根据 ",(0,s.jsx)(n.code,{children:"name"})," 从 ",(0,s.jsx)(n.code,{children:"this.commands"})," ",(0,s.jsx)(n.code,{children:"Map"})," 中获取到命令，输出对应的 ",(0,s.jsx)(n.code,{children:"optionsMap"})," 和 ",(0,s.jsx)(n.code,{children:"synopsisList"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"13-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-总结",children:"#"}),"13. 总结"]}),"\n",(0,s.jsx)(n.p,{children:"我们主要学了"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"学会通过两种方式调试 taro 源码"}),"\n",(0,s.jsx)(n.li,{children:"学会入口 taro-cli 具体实现方式"}),"\n",(0,s.jsx)(n.li,{children:"学会 cli init 命令实现原理，读取用户项目配置文件和用户全局配置文件"}),"\n",(0,s.jsx)(n.li,{children:"学会 taro-service kernal （内核）解耦实现"}),"\n",(0,s.jsx)(n.li,{children:"初步学会 taro 插件架构，学会了如何编写一个 taro 插件"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["taro-cli 使用了",(0,s.jsx)(n.a,{href:"https://github.com/minimistjs/minimist",rel:"noopener noreferrer",target:"_blank",children:"minimist"}),"，命令行参数解析工具。"]}),"\n",(0,s.jsxs)(n.p,{children:["使用了 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@swc/register",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"@swc/register"})})," 读取 config/index .js 或者 .ts 配置文件和用 fs-extra ",(0,s.jsx)(n.a,{href:"https://github.com/jprichardson/node-fs-extra/blob/master/docs/readJson-sync.md",rel:"noopener noreferrer",target:"_blank",children:"fs.readJSONSync"})," 全局配置文件。"]}),"\n",(0,s.jsxs)(n.p,{children:["CLI 部分有各种预设插件集合 ",(0,s.jsx)(n.code,{children:"presets"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["taro 单独抽离了一个 ",(0,s.jsx)(n.code,{children:"tarojs/service"})," (",(0,s.jsx)(n.code,{children:"packages/taro-service"}),") 模块，包含 ",(0,s.jsx)(n.code,{children:"Kernal"})," 内核、",(0,s.jsx)(n.code,{children:"Config"}),"、",(0,s.jsx)(n.code,{children:"Plugin"})," 等。"]}),"\n",(0,s.jsxs)(n.p,{children:["taro 的基于 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/tapable",rel:"noopener noreferrer",target:"_blank",children:"Tapable"})," 的 ",(0,s.jsx)(n.code,{children:"AsyncSeriesWaterfallHook"})," (把函数组合在一起串行) 实现的插件机制。各个插件可以分开在各个地方，达到解耦效果。非常值得我们学习。"]}),"\n",(0,s.jsx)(n.p,{children:"简单做了一个本文的总结图。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"简单总结",src:w})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,s.jsx)(n.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后可以持续关注我",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(C,e)})):C(e)}let E=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["taro%2Fcli-init%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-准备工作",text:"2. 准备工作",depth:2},{id:"3-调试",text:"3. 调试",depth:2},{id:"31-入口文件-packagestaro-clibintaro",text:"3.1 入口文件 packages/taro-cli/bin/taro",depth:3},{id:"32-调试方法-1-javascript-debug-terminal",text:"3.2 调试方法 1 JavaScript Debug Terminal",depth:3},{id:"33-调试方式-2-配置-vscodelaunchjson",text:"3.3 调试方式 2 配置 .vscode/launch.json",depth:3},{id:"4-taro-clisrcutilsindexts",text:"4. taro-cli/src/utils/index.ts",depth:2},{id:"5-cli-整体结构",text:"5. CLI 整体结构",depth:2},{id:"6-cli-parseargs",text:"6. cli parseArgs",depth:2},{id:"61-presets-预设插件集合",text:"6.1 presets 预设插件集合",depth:3},{id:"62-config",text:"6.2 Config",depth:3},{id:"621-configinit-初始化配置",text:"6.2.1 config.init 初始化配置",depth:4},{id:"622-configinitglobalconfig-初始化全局配置",text:"6.2.2 config.initGlobalConfig 初始化全局配置",depth:4},{id:"7-kernel-内核",text:"7. Kernel （内核）",depth:2},{id:"71-cli-kerneloptsplugins-等",text:"7.1 cli kernel.optsPlugins 等",depth:3},{id:"72-cli-customcommand-函数",text:"7.2 cli customCommand 函数",depth:3},{id:"8-kernalrun-执行函数",text:"8. kernal.run 执行函数",depth:2},{id:"9-kernalsetrunopts",text:"9. kernal.setRunOpts",depth:2},{id:"10-kernal-ctxregistercommand-注册-init-命令",text:"10. kernal ctx.registerCommand 注册 init 命令",depth:2},{id:"11-kernalapplyplugins-触发插件",text:"11. kernal.applyPlugins 触发插件",depth:2},{id:"12-kernalrunhelp-命令帮助信息",text:"12. kernal.runHelp 命令帮助信息",depth:2},{id:"13-总结",text:"13. 总结",depth:2}],title:"Taro 源码揭秘：1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密",headingTitle:"Taro 源码揭秘：1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(e,n,r){r.d(n,{Z:()=>l});var s=r(52676),i=r(75271),t=r(92815);r(18544);let a={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function c(e,n,r){let s=Object.keys(a).includes(n)?n:r;return a[s](e)}let l=e=>{let{defaultLocale:n="en-US"}=e,r=(0,t.Vi)().page.readingTimeData,a=(0,t.Jr)(),l=(0,t.e7)(),[o,d]=(0,i.useState)(c(r,a,n));return(0,i.useEffect)(()=>{d(c(r,a,n))},[a,r]),(0,s.jsx)("span",{"data-dark":String(l),className:"rp-reading-time",children:o})}}}]);