"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["2479"],{46884:function(e,n,s){s.r(n),s.d(n,{default:()=>a});var t=s(52676),c=s(40453),i=s(20713);let r=s.p+"static/image/store.dispatch.7ae23c84.jpg";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",img:"img",strong:"strong",ol:"ol",li:"li",hr:"hr"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"面对-this-指向丢失尤雨溪在-vuex-源码中是怎么处理的",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#面对-this-指向丢失尤雨溪在-vuex-源码中是怎么处理的",children:"#"}),"面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的"]}),"\n",(0,t.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,t.jsxs)(n.h2,{id:"1-前言",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,t.jsxs)(n.p,{children:["大家好，我是",(0,t.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650755227&idx=2&sn=1ee6c425188ceda81e1e972c32cbc457&chksm=88665317bf11da01cd320678f6da9d4395b0efb93b7074efc5e72ba65d08deeaf9be6b4037dd&token=1249549694&lang=zh_CN#rd",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。好久以前我有写过",(0,t.jsx)(n.a,{href:"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&action=getalbum&album_id=1342989113611419648#wechat_redirect",rel:"noopener noreferrer",target:"_blank",children:"《面试官问系列》"}),"，旨在帮助读者提升JS基础知识，包含",(0,t.jsx)(n.code,{children:"new、call、apply、this、继承"}),"相关知识。其中写了 ",(0,t.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650744695&idx=1&sn=63c761b9129c3c55ad7a2c21ddb4d82b&chksm=886624fbbf11aded9c57e7846c98961848cee7871f5e10bac3bdb949e9135fbc2095ae677102&token=1471663946&lang=zh_CN&scene=21#wechat_redirect",rel:"noopener noreferrer",target:"_blank",children:"面试官问：this 指向"})," 文章。在掘金等平台收获了还算不错的反馈。"]}),"\n",(0,t.jsxs)(n.p,{children:["最近有小伙伴看我的 ",(0,t.jsx)(n.a,{href:"http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650744584&idx=1&sn=b14f8a762f132adcf0f7e3e075ee2ded&chksm=88662484bf11ad922ed27d45873af838298949eea381545e82a511cabf0c6fc6876a8370c6fb&scene=21#wechat_redirect",rel:"noopener noreferrer",target:"_blank",children:"Vuex源码"})," 文章，提到有一处",(0,t.jsx)(n.code,{children:"this"}),"指向有点看不懂（好不容易终于有人看我的源码文章了，感动的要流泪了",(0,t.jsx)(n.code,{children:"^_^"}),"）。于是我写篇文章答疑解惑，简单再说说 ",(0,t.jsx)(n.code,{children:"this"})," 指向和",(0,t.jsx)(n.code,{children:"尤大在 Vuex 源码中"}),"是怎么处理 ",(0,t.jsx)(n.code,{children:"this"})," 指向丢失的。"]}),"\n",(0,t.jsxs)(n.h2,{id:"2-对象中的this指向",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-对象中的this指向",children:"#"}),"2. 对象中的this指向"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"var person = {\n  name: '若川',\n  say: function(text){\n    console.log(this.name + ', ' + text);\n  }\n}\nconsole.log(person.name);\nconsole.log(person.say('在写文章')); // 若川, 在写文章\nvar say = person.say;\nsay('在写文章'); // 这里的this指向就丢失了，指向window了。(非严格模式)\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"3-类中的this指向",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-类中的this指向",children:"#"}),"3. 类中的this指向"]}),"\n",(0,t.jsxs)(n.h3,{id:"31-es5",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-es5",children:"#"}),"3.1 ES5"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// ES5\nvar Person = function(){\n  this.name = '若川';\n}\nPerson.prototype.say = function(text){\n  console.log(this.name + ', ' + text);\n}\nvar person = new Person();\nconsole.log(person.name); // 若川\nconsole.log(person.say('在写文章'));\nvar say = person.say;\nsay('在写文章'); // 这里的this指向就丢失了，指向 window 了。\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"32-es6",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-es6",children:"#"}),"3.2 ES6"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// ES6\nclass Person{\n  construcor(name = '若川'){\n     this.name = name;\n  }\n  say(text){\n    console.log(`${this.name}, ${text}`);\n  }\n}\nconst person = new Person();\nperson.say('在写文章')\n// 解构\nconst { say } = person;\nsay('在写文章'); // 报错 this ，因为ES6 默认启用严格模式，严格模式下指向 undefined\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"4-尤大在vuex源码中是怎么处理的",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-尤大在vuex源码中是怎么处理的",children:"#"}),"4. 尤大在Vuex源码中是怎么处理的"]}),"\n",(0,t.jsx)(n.p,{children:"先看代码"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Store{\n  constructor(options = {}){\n     this._actions = Object.create(null);\n  // bind commit and dispatch to self\n      // 给自己 绑定 commit 和 dispatch\n      const store = this\n      const { dispatch, commit } = this\n      // 为何要这样绑定 ?\n      // 说明调用commit和dispach 的 this 不一定是 store 实例\n      // 这是确保这两个函数里的this是store实例\n      this.dispatch = function boundDispatch (type, payload) {\n        return dispatch.call(store, type, payload)\n      }\n      this.commit = function boundCommit (type, payload, options) {\n        return commit.call(store, type, payload, options)\n      }\n  }\n  dispatch(){\n     console.log('dispatch', this);\n  }\n  commit(){\n     console.log('commit', this);\n  }\n}\nconst store = new Store();\nstore.dispatch(); // 输出结果 this 是什么呢？\n\nconst { dispatch, commit } = store;\ndispatch(); // 输出结果 this 是什么呢？\ncommit();  // 输出结果 this 是什么呢？\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"输出结果截图",src:r})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"结论"}),"：非常巧妙的用了",(0,t.jsx)(n.code,{children:"call"}),"把",(0,t.jsx)(n.code,{children:"dispatch"}),"和",(0,t.jsx)(n.code,{children:"commit"}),"函数的",(0,t.jsx)(n.code,{children:"this"}),"指向强制绑定到",(0,t.jsx)(n.code,{children:"store"}),"实例对象上。如果不这么绑定就报错了。"]}),"\n",(0,t.jsxs)(n.h3,{id:"41-actions-解构-store",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-actions-解构-store",children:"#"}),"4.1 actions 解构 store"]}),"\n",(0,t.jsxs)(n.p,{children:["其实",(0,t.jsx)(n.code,{children:"Vuex"}),"源码里就有上面解构",(0,t.jsx)(n.code,{children:"const { dispatch, commit } = store;"}),"的写法。想想我们平时是如何写",(0,t.jsx)(n.code,{children:"actions"}),"的。",(0,t.jsx)(n.code,{children:"actions"}),"中自定义函数的第一个参数其实就是 ",(0,t.jsx)(n.code,{children:"store"})," 实例。"]}),"\n",(0,t.jsxs)(n.p,{children:["这时我们翻看下",(0,t.jsx)(n.code,{children:"actions文档"}),"：",(0,t.jsx)(n.code,{children:"https://vuex.vuejs.org/zh/guide/actions.html"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"也可以用解构赋值的写法。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"actions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["有了",(0,t.jsx)(n.code,{children:"Vuex"}),"源码构造函数里的",(0,t.jsx)(n.code,{children:"call"}),"绑定，这样",(0,t.jsx)(n.code,{children:"this"}),"指向就被修正啦~",(0,t.jsx)(n.strong,{children:"不得不说祖师爷就是厉害"}),"。这一招，大家可以免费学走~"]}),"\n",(0,t.jsxs)(n.p,{children:["接着我们带着问题，为啥上文中的",(0,t.jsx)(n.code,{children:"context"}),"就是",(0,t.jsx)(n.code,{children:"store"}),"实例，有",(0,t.jsx)(n.code,{children:"dispatch"}),"、",(0,t.jsx)(n.code,{children:"commit"}),"这些方法呢。继续往下看。"]}),"\n",(0,t.jsxs)(n.h3,{id:"42-为什么-actions-对象里的自定义函数-第一个参数就是-store-实例",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-为什么-actions-对象里的自定义函数-第一个参数就是-store-实例",children:"#"}),"4.2 为什么 actions 对象里的自定义函数 第一个参数就是 store 实例。"]}),"\n",(0,t.jsxs)(n.p,{children:["以下是简单源码，有缩减，感兴趣的可以看我的文章 ",(0,t.jsx)(n.a,{href:"https://ruochuan12.github.io/vuex",rel:"noopener noreferrer",target:"_blank",children:"Vuex 源码文章"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Store{\n construcor(){\n    // 初始化 根模块\n    // 并且也递归的注册所有子模块\n    // 并且收集所有模块的 getters 放在 this._wrappedGetters 里面\n    installModule(this, state, [], this._modules.root)\n }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["接着我们看",(0,t.jsx)(n.code,{children:"installModule"}),"函数中的遍历注册 ",(0,t.jsx)(n.code,{children:"actions"})," 实现"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function installModule (store, rootState, path, module, hot) {\n    // 省略若干代码\n    // 循环遍历注册 action\n    module.forEachAction((action, key) => {\n      const type = action.root ? key : namespace + key\n      const handler = action.handler || action\n      registerAction(store, type, handler, local)\n    })\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["接着看注册 ",(0,t.jsx)(n.code,{children:"actions"})," 函数实现 ",(0,t.jsx)(n.code,{children:"registerAction"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"/**\n* 注册 mutation\n* @param {Object} store 对象\n* @param {String} type 类型\n* @param {Function} handler 用户自定义的函数\n* @param {Object} local local 对象\n*/\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  // payload 是actions函数的第二个参数\n  entry.push(function wrappedActionHandler (payload) {\n    /**\n     * 也就是为什么用户定义的actions中的函数第一个参数有\n     *  { dispatch, commit, getters, state, rootGetters, rootState } 的原因\n     * actions: {\n     *    checkout ({ commit, state }, products) {\n     *        console.log(commit, state);\n     *    }\n     * }\n     */\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload)\n    // 源码有删减\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["比较容易发现调用顺序是 ",(0,t.jsx)(n.code,{children:"new Store() => installModule(this) => registerAction(store) => let res = handler.call(store)"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["其中",(0,t.jsx)(n.code,{children:"handler"})," 就是 用户自定义的函数，也就是对应上文的例子",(0,t.jsx)(n.code,{children:"increment"}),"函数。",(0,t.jsx)(n.code,{children:"store"}),"实例对象一路往下传递，到",(0,t.jsx)(n.code,{children:"handler"}),"执行时，也是用了",(0,t.jsx)(n.code,{children:"call"}),"函数，强制绑定了第一个参数是",(0,t.jsx)(n.code,{children:"store"}),"实例对象。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"actions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这也就是为什么 ",(0,t.jsx)(n.code,{children:"actions"})," 对象中的自定义函数的第一个参数是 ",(0,t.jsx)(n.code,{children:"store"})," 对象实例了。"]}),"\n",(0,t.jsx)(n.p,{children:"好啦，文章到这里就基本写完啦~相对简短一些。应该也比较好理解。"}),"\n",(0,t.jsxs)(n.h2,{id:"5-最后再总结下-this-指向",children:[(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-最后再总结下-this-指向",children:"#"}),"5. 最后再总结下 this 指向"]}),"\n",(0,t.jsxs)(n.p,{children:["摘抄下",(0,t.jsx)(n.a,{href:"https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650744695&idx=1&sn=63c761b9129c3c55ad7a2c21ddb4d82b&chksm=886624fbbf11aded9c57e7846c98961848cee7871f5e10bac3bdb949e9135fbc2095ae677102&token=1471663946&lang=zh_CN&scene=21#wechat_redirect",rel:"noopener noreferrer",target:"_blank",children:"面试官问：this 指向"}),"文章结尾。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果要判断一个运行中函数的 ",(0,t.jsx)(n.code,{children:"this"})," 绑定， 就需要找到这个函数的直接调用位置。 找到之后\n就可以顺序应用下面这四条规则来判断 ",(0,t.jsx)(n.code,{children:"this"})," 的绑定对象。"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"new"})," 调用：绑定到新创建的对象，注意：显示",(0,t.jsx)(n.code,{children:"return"}),"函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"call"})," 或者 ",(0,t.jsx)(n.code,{children:"apply"}),"（ 或者 ",(0,t.jsx)(n.code,{children:"bind"}),"） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，",(0,t.jsx)(n.code,{children:"null"}),"和",(0,t.jsx)(n.code,{children:"undefined"}),"，指向全局对象（浏览器中是",(0,t.jsx)(n.code,{children:"window"}),"），其余值指向被",(0,t.jsx)(n.code,{children:"new Object()"}),"包装的对象。"]}),"\n",(0,t.jsx)(n.li,{children:"对象上的函数调用：绑定到那个对象。"}),"\n",(0,t.jsxs)(n.li,{children:["普通函数调用： 在严格模式下绑定到 ",(0,t.jsx)(n.code,{children:"undefined"}),"，否则绑定到全局对象。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ES6"})," 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定",(0,t.jsx)(n.code,{children:"this"}),"， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是",(0,t.jsx)(n.code,{children:"window"}),"）。 这其实和 ",(0,t.jsx)(n.code,{children:"ES6"})," 之前代码中的 ",(0,t.jsx)(n.code,{children:"self = this"})," 机制一样。"]}),"\n",(0,t.jsx)(n.hr,{})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(d,e)})):d(e)}let a=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["vuex-this%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-对象中的this指向",text:"2. 对象中的this指向",depth:2},{id:"3-类中的this指向",text:"3. 类中的this指向",depth:2},{id:"31-es5",text:"3.1 ES5",depth:3},{id:"32-es6",text:"3.2 ES6",depth:3},{id:"4-尤大在vuex源码中是怎么处理的",text:"4. 尤大在Vuex源码中是怎么处理的",depth:2},{id:"41-actions-解构-store",text:"4.1 actions 解构 store",depth:3},{id:"42-为什么-actions-对象里的自定义函数-第一个参数就是-store-实例",text:"4.2 为什么 actions 对象里的自定义函数 第一个参数就是 store 实例。",depth:3},{id:"5-最后再总结下-this-指向",text:"5. 最后再总结下 this 指向",depth:2}],title:"面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的",headingTitle:"面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的",frontmatter:{}}},20713:function(e,n,s){s.d(n,{Z:()=>o});var t=s(52676),c=s(75271),i=s(92815);s(18544);let r={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function d(e,n,s){let t=Object.keys(r).includes(n)?n:s;return r[t](e)}let o=e=>{let{defaultLocale:n="en-US"}=e,s=(0,i.Vi)().page.readingTimeData,r=(0,i.Jr)(),o=(0,i.e7)(),[a,h]=(0,c.useState)(d(s,r,n));return(0,c.useEffect)(()=>{h(d(s,r,n))},[r,s]),(0,t.jsx)("span",{"data-dark":String(o),className:"rp-reading-time",children:a})}}}]);