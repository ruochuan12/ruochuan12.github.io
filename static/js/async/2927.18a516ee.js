"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["2927"],{5160:function(e,n,i){i.r(n),i.d(n,{default:()=>y});var s=i(52676),r=i(40453),t=i(20713),a=i(15925);let c=i.p+"static/image/taro-webpack.f2577a1e.png",o=i.p+"static/image/modifyAppConfig.b47a43a5.png",l=i.p+"static/image/release-4.0.9.05dc76a1.webp",d=i.p+"static/image/pages-build.5a7027d3.webp",p=i.p+"static/image/pages-build-2.d63cdcf8.webp",h=i.p+"static/image/pages-app-config.9a580484.webp",g=i.p+"static/image/filesConfig.17342efe.png",x=i.p+"static/image/page.config.78ec3688.png",f=i.p+"static/image/page-js.1d2b744d.png",j=i.p+"static/image/console.7ac5eec6.png",u=i.p+"static/image/pages.1876994f.png",m=i.p+"static/image/pages.config.b851c700.png",b=i.p+"static/image/darkmode.f06112f8.png",k=i.p+"static/image/dependencies.03b139c9.png";function P(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",blockquote:"blockquote",ul:"ul",li:"li",input:"input",pre:"pre",img:"img",h3:"h3",h4:"h4",ol:"ol",hr:"hr",strong:"strong"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"taro-源码揭秘11-taro-项目开发编译速度太慢怎么办写个简单插件按需编译",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘11-taro-项目开发编译速度太慢怎么办写个简单插件按需编译",children:"#"}),"Taro 源码揭秘：11. Taro 项目开发编译速度太慢，怎么办？写个简单插件按需编译"]}),"\n",(0,s.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["截至目前（",(0,s.jsx)(n.code,{children:"2025-04-16"}),"），目前最新是 ",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.12",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"4.0.12"})}),"，官方",(0,s.jsx)(n.code,{children:"4.0"}),"正式版本的介绍文章暂未发布。官方之前发过",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"时隔3个月才继续写第 11 篇，我会继续持续写下去，争取做全网最新最全的 Taro 源码系列。"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。"}),"\n",(0,s.jsx)(n.p,{children:"第 5-7 篇讲述的是运行时相关的 Events、API、request 等。"}),"\n",(0,s.jsx)(n.p,{children:"第 10 篇接着继续追随第 4 篇和第 8、9 篇的脚步，分析 TaroMiniPlugin webpack 的插件实现（全流程讲述）。"}),"\n",(0,s.jsx)(n.p,{children:"第 11 篇，我们继续分析 TaroMiniPlugin webpack 的插件实现。分析 Taro 是如何解析入口文件和页面的？"}),"\n",(0,s.jsxs)(n.p,{children:["关于克隆项目、环境准备、如何调试代码等，参考",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第 1 篇文章-准备工作、调试"}),"和",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612#heading-2",rel:"noopener noreferrer",target:"_blank",children:"第 4 篇 npm run dev:weapp（本文以这篇文章中的调试为例）"}),"。后续文章基本不再过多赘述。"]}),"\n",(0,s.jsx)(n.p,{children:"学完本文，你将学到："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. Taro 是如何解析入口配置 app.config.ts 和页面配置的？\n2. 学会写一个 Taro 插件，解决 Taro 项目编译速度太慢的问题\n3. 学完能对自己平时写的 Taro 项目更理解透彻\n等等\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"taro-mini-plugin",src:c})}),"\n",(0,s.jsx)(n.p,{children:"我们先来看 TaroMiniPlugin 结构"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\nexport default class TaroMiniPlugin {\n	constructor (options: ITaroMiniPluginOptions) {\n		// 省略\n	}\n	/**\n	* 插件入口\n	*/\n	apply (compiler: Compiler) {\n		this.context = compiler.context\n		//  根据 webpack entry 配置获取入口文件路径\n		//  @returns app 入口文件路径\n		this.appEntry = this.getAppEntry(compiler)\n		// 省略代码\n		/** build mode */\n		compiler.hooks.run.tapAsync(\n			PLUGIN_NAME,\n			this.tryAsync<Compiler>(async compiler => {\n				await this.run(compiler)\n				// 省略\n			})\n		)\n	}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["插件入口 apply 方法，获取到 ",(0,s.jsx)(n.code,{children:"this.appEntry"})," ",(0,s.jsx)(n.code,{children:"src/app.[js|jsx|ts|tsx]"}),"，调用 ",(0,s.jsx)(n.code,{children:"run"})," 方法。"]}),"\n",(0,s.jsxs)(n.p,{children:["这里的 ",(0,s.jsx)(n.code,{children:"this.appEntry"})," 是 ",(0,s.jsx)(n.code,{children:'"/Users/ruochuan/git-source/github/taro4-debug/src/app.ts"'})]}),"\n",(0,s.jsxs)(n.p,{children:["本文主要讲述 ",(0,s.jsx)(n.code,{children:"run"})," 方法的具体实现。分析 ",(0,s.jsx)(n.code,{children:"app"})," 入口文件，搜集页面、组件信息，往 ",(0,s.jsx)(n.code,{children:"this.dependencies"})," 中添加资源模块。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\nexport default class TaroMiniPlugin {\n	/**\n	 * 分析 app 入口文件，搜集页面、组件信息，\n	 * 往 this.dependencies 中添加资源模块\n	 */\n	async run(compiler: Compiler) {\n		if (this.options.isBuildPlugin) {\n			this.getPluginFiles();\n			this.getConfigFiles(compiler);\n		} else {\n			this.appConfig = await this.getAppConfig();\n			this.getPages();\n			this.getPagesConfig();\n			this.getDarkMode();\n			this.getConfigFiles(compiler);\n			this.addEntries();\n		}\n	}\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["插件构建模式 ( this.options.isBuildPlugin 为 true 时)：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"调用 getPluginFiles() 获取插件文件"}),"\n",(0,s.jsx)(n.li,{children:"调用 getConfigFiles(compiler) 获取配置文件"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["正常构建模式：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先通过 getAppConfig() 获取应用配置"}),"\n",(0,s.jsxs)(n.li,{children:["然后依次执行：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"getPages() 获取页面信息"}),"\n",(0,s.jsx)(n.li,{children:"getPagesConfig() 获取页面配置"}),"\n",(0,s.jsx)(n.li,{children:"getDarkMode() 获取暗黑模式配置"}),"\n",(0,s.jsx)(n.li,{children:"getConfigFiles(compiler) 获取配置文件"}),"\n",(0,s.jsx)(n.li,{children:"addEntries() 在 this.dependencies 中新增或修改 app、模板组件、页面、组件等资源模块"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.Z,Object.assign({code:'graph TD\n    A[开始] --\x3e B{是否为插件构建模式?}\n    B -- 是 --\x3e C[调用 getPluginFiles]\n    C --\x3e D[调用 getConfigFiles]\n    B -- 否 --\x3e E[调用 getAppConfig]\n    E --\x3e F[调用 getPages]\n    F --\x3e G[调用 getPagesConfig]\n    G --\x3e H[调用 getDarkMode]\n    H --\x3e I[调用 getConfigFiles]\n    I --\x3e J[调用 addEntries]\n    D --\x3e K[结束]\n    J --\x3e K\n\n    subgraph 函数解释\n        C["getPluginFiles: 获取插件文件，处理插件相关配置"]\n        D["getConfigFiles: 获取配置文件，处理配置相关逻辑"]\n        E["getAppConfig: 获取应用全局配置"]\n        F["getPages: 根据app配置收集页面信息，处理分包和tabbar"]\n        G["getPagesConfig: 读取页面及其依赖组件的配置"]\n        H["getDarkMode: 获取暗黑模式相关配置"]\n        I["getConfigFiles: 获取配置文件，处理配置相关逻辑"]\n        J["addEntries: 在 this.dependencies 中新增或修改 app、模板组件、页面、组件等资源模块"]\n    end'},{config:{theme:"forest"}})),"\n",(0,s.jsxs)(n.h2,{id:"2-getappconfig-获取入口配置文件配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-getappconfig-获取入口配置文件配置",children:"#"}),"2. getAppConfig 获取入口配置文件配置"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\nthis.appConfig = await this.getAppConfig();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["入口文件是 ",(0,s.jsx)(n.code,{children:"src/app.[js|jsx|ts|tsx]"}),"。\n",(0,s.jsx)(n.code,{children:"getAppConfig"})," 获取入口文件的配置。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个函数要做的事情是把配置文件 ",(0,s.jsx)(n.code,{children:"src/app.config.ts"})," 转换成"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// src/app.config.ts\nexport default defineAppConfig({\n  pages: [\n    'pages/index/index'\n  ],\n  window: {\n    backgroundTextStyle: 'light',\n    navigationBarBackgroundColor: '#fff',\n    navigationBarTitleText: 'WeChat',\n    navigationBarTextStyle: 'black'\n  }\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最终这样的对象，方便读取 ",(0,s.jsx)(n.code,{children:"pages"})," 等相关配置，再进行处理。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'{\n  pages: [\n    "pages/index/index",\n  ],\n  window: {\n    backgroundTextStyle: "light",\n    navigationBarBackgroundColor: "#fff",\n    navigationBarTitleText: "WeChat",\n    navigationBarTextStyle: "black",\n  },\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["我们来看 ",(0,s.jsx)(n.code,{children:"getAppConfig"})," 的具体实现。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\nasync getAppConfig (): Promise<AppConfig> {\n	// 'app'\n    const appName = path.basename(this.appEntry).replace(path.extname(this.appEntry), '')\n\n	// 编译处理入口配置文件 app.config.ts\n    this.compileFile({\n      name: appName,\n      path: this.appEntry,\n      isNative: false\n    })\n\n	// 编译完成，获取文件内容\n    const fileConfig = this.filesConfig[this.getConfigFilePath(appName)]\n    const appConfig = fileConfig ? fileConfig.content || {} : {}\n\n    if (isEmptyObject(appConfig)) {\n      throw new Error('缺少 app 全局配置文件，请检查！')\n    }\n	// 预留钩子函数可修改配置文件\n    const { modifyAppConfig } = this.options.combination.config\n    if (typeof modifyAppConfig === 'function') {\n      await modifyAppConfig(appConfig)\n    }\n    return appConfig as AppConfig\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"compileFile"})," 函数，简单来说就是读取配置，然后存储到 ",(0,s.jsx)(n.code,{children:"this.filesConfig"})," 上。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"modifyAppConfig"})," 是传入的修改 ",(0,s.jsx)(n.code,{children:"app.config.ts"})," 配置文件的钩子函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-modifyappconfig-修改-appconfigts-配置文件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-modifyappconfig-修改-appconfigts-配置文件",children:"#"}),"2.1 modifyAppConfig 修改 app.config.ts 配置文件"]}),"\n",(0,s.jsxs)(n.p,{children:["可以搜索 Taro 项目中的 ",(0,s.jsx)(n.code,{children:"modifyAppConfig"}),"，查看使用场景。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，有一种场景，小程序开发页面过多时，加载打包更新就很缓慢。比如这篇文章",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7339024907718967359#heading-15",rel:"noopener noreferrer",target:"_blank",children:"古茗是如何将小程序编译速度提升3倍的"}),"，不过这篇文章主要是劫持 ",(0,s.jsx)(n.code,{children:"app.config.ts"}),"，当时估计没有这个 ",(0,s.jsx)(n.code,{children:"modifyAppConfig"})," 钩子函数，且他们写的插件没有开源。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以在开发环境，修改 ",(0,s.jsx)(n.code,{children:"config"})," 配置，只设置当前开发的页面。这是一个异步方法，可以直接手动修改，当前要开发的文件，也可以用读取页面出来再选择设置（利用 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/enquirer",rel:"noopener noreferrer",target:"_blank",children:"enquire"})," 类似 ",(0,s.jsx)(n.code,{children:"npm"})," 包实现）。这样就可以解决开发环境时打包更新比较慢的情况。"]}),"\n",(0,s.jsxs)(n.p,{children:["在项目路径 ",(0,s.jsx)(n.code,{children:"config/modifyAppConfig.ts"})," 开发一个插件修改。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// config/modifyAppConfig.ts\nexport default async (ctx, options) => {\n  await ctx.modifyAppConfig((config) => {\n	// 开发环境才修改 config 配置\n    if(process.env.NODE_ENV === 'development'){\n	  // 只是示例代码\n      config.appConfig.pages.push('pages/demo/index');\n      console.log('config', config);\n    }\n  });\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["再在项目路径 ",(0,s.jsx)(n.code,{children:"config/index.ts"})," 添加写的 ",(0,s.jsx)(n.code,{children:"modifyAppConfig"})," 插件。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// config/index.ts\nimport path from 'node:path';\n\nconst baseConfig = {\n	// 插件\n	plugins: [\n		path.resolve(__dirname, './modifyAppConfig.ts'),\n	]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们重新执行 ",(0,s.jsx)(n.code,{children:"pnpm run dev:weapp"})," 或其他，即可看到输出的配置信息和修改的页面路径。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"modifyAppConfig",src:o})}),"\n",(0,s.jsxs)(n.p,{children:["目前 ",(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/plugin-custom",rel:"noopener noreferrer",target:"_blank",children:"Taro 编写插件文档"})," 上暂时没有体现这个 ",(0,s.jsx)(n.code,{children:"modifyAppConfig"})," 钩子。所以有些时候还是需要深入学习源码，理解源码才能更好的针对项目做相应的优化。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们继续来看实现 ",(0,s.jsx)(n.code,{children:"compileFile"})," 函数的实现。"]}),"\n",(0,s.jsxs)(n.h3,{id:"22-taro-409-版本增加按需编译-pages-或-components-能力",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-taro-409-版本增加按需编译-pages-或-components-能力",children:"#"}),"2.2 Taro 4.0.9 版本增加按需编译 pages 或 components 能力"]}),"\n",(0,s.jsxs)(n.p,{children:["最近发现 release 4.0.9 有按需编译页面或者组件的功能：",(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.9",rel:"noopener noreferrer",target:"_blank",children:"release 4.0.9"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"release-4.0.9",src:l})}),"\n",(0,s.jsx)(n.p,{children:"我们来看下是如何实现的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/commit/47722ef882f3eaadbcc990a95e3c3484bdf68adc",rel:"noopener noreferrer",target:"_blank",children:"feat(cli): 增加按需编译pages或components能力"})}),"\n",(0,s.jsx)(n.p,{children:"我们看下代码修改记录，看看是如何实现的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pages-build",src:d})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"taro build --type weapp --watch --pages pages/index/index\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以在终端这样执行命令，可以按需编译 pages 或 components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pnpm run dev:weapp --pages pages/index/index\npnpm run dev:weapp --components pages/components/index\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pages-build-2",src:p})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"taro build"})," 命令中 ",(0,s.jsx)(n.code,{children:"modifyAppConfig"})," 中有个函数 ",(0,s.jsx)(n.code,{children:"extratCompileEntry"}),"，我们来看它的具体实现。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pages-app-config",src:h})}),"\n",(0,s.jsxs)(n.p,{children:["我们可以看出，简单来说就是解析命令行参数的 ",(0,s.jsx)(n.code,{children:"pages"})," 或者 ",(0,s.jsx)(n.code,{children:"components"}),"，逗号分割是路径（没有配置则不修改），通过 ",(0,s.jsx)(n.code,{children:"modifyAppConfig"})," 钩子函数，修改 ",(0,s.jsx)(n.code,{children:"app.config.ts (appConfig)"})," 的配置文件，",(0,s.jsx)(n.code,{children:"pages"})," 或者 ",(0,s.jsx)(n.code,{children:"components"}),"，",(0,s.jsx)(n.code,{children:"subPackages"})," 置为空。从而实现了按需编译 ",(0,s.jsx)(n.code,{children:"pages"})," 或者 ",(0,s.jsx)(n.code,{children:"components"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"23-compilefile-读取页面组件的配置并递归读取依赖的组件的配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-compilefile-读取页面组件的配置并递归读取依赖的组件的配置",children:"#"}),"2.3 compileFile 读取页面、组件的配置，并递归读取依赖的组件的配置"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n   * 读取页面、组件的配置，并递归读取依赖的组件的配置\n   */\n  compileFile (file: IComponent, independentPackage?: IndependentPackage) {\n    const filePath = file.path\n    const fileConfigPath = file.isNative ? this.replaceExt(filePath, '.json') : this.getConfigFilePath(filePath)\n    const fileConfig = readConfig(fileConfigPath, this.options.combination.config)\n    const { componentGenerics, usingComponents } = fileConfig\n\n    if (this.options.isBuildPlugin && componentGenerics) {\n      // 省略...\n    }\n\n    // 递归收集依赖的第三方组件\n    if (usingComponents) {\n      // 省略...\n    }\n\n    this.filesConfig[this.getConfigFilePath(file.name)] = {\n      content: fileConfig,\n      path: fileConfigPath\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"compileFile"})," 相对比较复杂，我们省略了一些代码。"]}),"\n",(0,s.jsxs)(n.p,{children:["最终给 ",(0,s.jsx)(n.code,{children:"this.filesConfig"})," 赋值，对象如下图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"filesConfig",src:g})}),"\n",(0,s.jsx)(n.p,{children:"包含配置文件的路径和配置的内容。"}),"\n",(0,s.jsxs)(n.p,{children:["这个函数中，其中有一个很关键的函数 ",(0,s.jsx)(n.code,{children:"readConfig"}),"，我们来看它的具体实现。"]}),"\n",(0,s.jsxs)(n.h3,{id:"24-readconfig-读取配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-readconfig-读取配置",children:"#"}),"2.4 readConfig 读取配置"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.taro.zone/docs/page-config",rel:"noopener noreferrer",target:"_blank",children:"页面配置"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"page.config",src:x})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-helper/src/utils.ts\nexport function readConfig<T extends IReadConfigOptions> (configPath: string, options: T = {} as T) {\n  let result: any = {}\n  if (fs.existsSync(configPath)) {\n    if (REG_JSON.test(configPath)) {\n      result = fs.readJSONSync(configPath)\n    } else {\n      result = requireWithEsbuild(configPath, {\n		// 省略若干代码\n	  })\n    }\n\n    result = getModuleDefaultExport(result)\n  } else {\n    result = readPageConfig(configPath)\n  }\n  return result\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/main/packages/taro-helper/src/__tests__/config.spec.ts",rel:"noopener noreferrer",target:"_blank",children:"仓库里有更多 readConfig 测试用例"})}),"\n",(0,s.jsxs)(n.p,{children:["我们很容易看出，存在配置文件，如果是JSON，则用 ",(0,s.jsx)(n.code,{children:"fs.readJSONSync"})," 读取。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"支持多种配置文件格式（支持 JSON 和 JS/TS 文件格式）"}),"\n",(0,s.jsx)(n.li,{children:"支持路径别名和常量定义"}),"\n",(0,s.jsx)(n.li,{children:"使用 esbuild、SWC 进行快速编译"}),"\n",(0,s.jsx)(n.li,{children:"处理模块默认导出"}),"\n",(0,s.jsx)(n.li,{children:"支持页面配置读取"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"requireWithEsbuild"})," 函数，看函数名即可猜测出具体含义。基于 ",(0,s.jsx)(n.code,{children:"esbuild"})," 的 ",(0,s.jsx)(n.code,{children:"require"})," 实现。"]}),"\n",(0,s.jsxs)(n.h4,{id:"241-requirewithesbuild",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#241-requirewithesbuild",children:"#"}),"2.4.1 requireWithEsbuild"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-helper/src/esbuild/index.ts\nimport { Config, transformSync } from '@swc/core'\nimport esbuild from 'esbuild'\nimport requireFromString from 'require-from-string'\n// 省略若干代码\n\n/** 基于 esbuild 的 require 实现 */\nexport function requireWithEsbuild(\n  id: string,\n  { customConfig = {}, customSwcConfig = {}, cwd = process.cwd() }: IRequireWithEsbuildOptions = {}\n) {\n  const { outputFiles = [] } = esbuild.buildSync(\n	// 省略若干代码\n  )\n\n  // Note: esbuild.buildSync 模式下不支持引入插件，所以这里需要手动转换\n  const { code = '' } = transformSync(\n    outputFiles[0].text,\n    defaults(customSwcConfig, {\n      jsc: { target: 'es2015' },\n    })\n  )\n  return requireFromString(code, id)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这块可以调试细看，当然我知道大部分人不会去调试，问题不大，知道个大概即可。后续碰到类似问题能想到这里的解决方案即可。"}),"\n",(0,s.jsxs)(n.h4,{id:"242-getmoduledefaultexport-处理模块默认导出",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#242-getmoduledefaultexport-处理模块默认导出",children:"#"}),"2.4.2 getModuleDefaultExport 处理模块默认导出"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-helper/src/utils.ts\nexport const getModuleDefaultExport = (exports) => (exports.__esModule ? exports.default : exports)\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"243-readpageconfig-读取页面配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#243-readpageconfig-读取页面配置",children:"#"}),"2.4.3 readPageConfig 读取页面配置"]}),"\n",(0,s.jsxs)(n.p,{children:["这个函数要实现的功能是：在页面 JS 文件中使用 ",(0,s.jsx)(n.code,{children:"definePageConfig"})," 也能配置读取。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"page-js",src:f})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-helper/src/utils.ts\nexport function readPageConfig(configPath: string) {\n  let result: any = {}\n  const extNames = ['.js', '.jsx', '.ts', '.tsx', '.vue']\n\n  // check source file extension\n  extNames.some((ext) => {\n    const tempPath = configPath.replace('.config', ext)\n    if (fs.existsSync(tempPath)) {\n      try {\n        result = readSFCPageConfig(tempPath)\n      } catch (error) {\n        result = {}\n      }\n      return true\n    }\n  })\n  return result\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"读取页面配置文件"}),"\n",(0,s.jsx)(n.li,{children:"支持多种文件格式（.js, .jsx, .ts, .tsx, .vue）"}),"\n",(0,s.jsx)(n.li,{children:"调用 readSFCPageConfig 解析文件内容"}),"\n",(0,s.jsx)(n.li,{children:"返回解析后的配置对象"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"244-readsfcpageconfig",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#244-readsfcpageconfig",children:"#"}),"2.4.4 readSFCPageConfig"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-helper/src/utils.ts\n// read page config from a sfc file instead of the regular config file\nfunction readSFCPageConfig(configPath: string) {\n  if (!fs.existsSync(configPath)) return {}\n\n  const sfcSource = fs.readFileSync(configPath, 'utf8')\n  const dpcReg = /definePageConfig\\(\\{[\\w\\W]+?\\}\\)/g\n  const matches = sfcSource.match(dpcReg)\n\n  let result: any = {}\n\n  if (matches && matches.length === 1) {\n    const callExprHandler = (p: any) => {\n      const { callee } = p.node\n      if (!callee.name) return\n      if (callee.name && callee.name !== 'definePageConfig') return\n\n      const configNode = p.node.arguments[0]\n      result = exprToObject(configNode)\n      p.stop()\n    }\n    const configSource = matches[0]\n    const program = (babel.parse(configSource, { filename: '' }))?.program\n\n    program && babel.traverse(program, { CallExpression: callExprHandler })\n  }\n\n  return result\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"从单文件组件（SFC）中读取页面配置"}),"\n",(0,s.jsx)(n.li,{children:"解析 definePageConfig 函数调用"}),"\n",(0,s.jsx)(n.li,{children:"将 AST 节点转换为 JavaScript 对象"}),"\n",(0,s.jsx)(n.li,{children:"返回解析后的配置对象"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/NervJS/taro/blob/main/packages/taro-helper/src/__tests__/config.spec.ts",rel:"noopener noreferrer",target:"_blank",children:"仓库里有更多 readConfig 测试用例"})}),"\n",(0,s.jsxs)(n.p,{children:["上述提到的测试用例缺失，有读者感兴趣可以补上，提 ",(0,s.jsx)(n.code,{children:"PR"})," 的机会来了。也可以修改项目中的配置为页面中的 JS 进行调试。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-getpages-获取页面信息",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-getpages-获取页面信息",children:"#"}),"3. getPages 获取页面信息"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n * 根据 app config 的 pages 配置项，收集所有页面信息，\n * 包括处理分包和 tabbar\n */\ngetPages () {\n	if (isEmptyObject(this.appConfig)) {\n		throw new Error('缺少 app 全局配置文件，请检查！')\n	}\n\n	const appPages = this.appConfig.pages\n	if (!appPages || !appPages.length) {\n		throw new Error('全局配置缺少 pages 字段，请检查！')\n	}\n\n	if (!this.isWatch && this.options.logger?.quiet === false) {\n		printLog(processTypeEnum.COMPILE, '发现入口', this.getShowPath(this.appEntry))\n	}\n\n	const { newBlended, frameworkExts, combination } = this.options\n	const { prerender } = combination.config\n\n	// 拆分到下方\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["一些判断和校验。\n其中经常能在控制台看到的一句提示",(0,s.jsx)(n.code,{children:"发现入口"}),"，源码就是在这里实现的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image",src:j})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n	this.prerenderPages = new Set(validatePrerenderPages(appPages, prerender).map(p => p.path))\n	this.getTabBarFiles(this.appConfig)\n	this.pages = new Set([\n		...appPages.map<IComponent>(item => {\n			const pagePath = resolveMainFilePath(path.join(this.options.sourceDir, item), frameworkExts)\n			const pageTemplatePath = this.getTemplatePath(pagePath)\n			const isNative = this.isNativePageORComponent(pageTemplatePath)\n			return {\n				name: item,\n				path: pagePath,\n				isNative,\n				stylePath: isNative ? this.getStylePath(pagePath) : undefined,\n				templatePath: isNative ? this.getTemplatePath(pagePath) : undefined\n			}\n		})\n	])\n	this.getSubPackages(this.appConfig)\n	// 新的混合原生编译模式 newBlended 下，需要收集独立编译为原生自定义组件\n	newBlended && this.getNativeComponent()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["执行这个函数过后，",(0,s.jsx)(n.code,{children:"this.pages"})," 会得到所有的页面数据。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pages",src:u})}),"\n",(0,s.jsx)(n.p,{children:"接下来是获取页面配置信息和组件等。"}),"\n",(0,s.jsxs)(n.h2,{id:"4-getpagesconfig-读取页面及其依赖的组件的配置",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-getpagesconfig-读取页面及其依赖的组件的配置",children:"#"}),"4. getPagesConfig 读取页面及其依赖的组件的配置"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n * 读取页面及其依赖的组件的配置\n */\ngetPagesConfig () {\n	this.pages.forEach(page => {\n		if (!this.isWatch && this.options.logger?.quiet === false) {\n			printLog(processTypeEnum.COMPILE, '发现页面', this.getShowPath(page.path))\n		}\n\n		const pagePath = page.path\n		const independentPackage = this.getIndependentPackage(pagePath)\n\n		this.compileFile(page, independentPackage)\n	})\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中经常能在控制台看到的一句提示",(0,s.jsx)(n.code,{children:"发现页面"}),"，源码就是在这里实现的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image",src:j})}),"\n",(0,s.jsx)(n.p,{children:"pages 的配置。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"pages.config",src:m})}),"\n",(0,s.jsxs)(n.h2,{id:"5-getdarkmode-收集-dark-mode-配置中的文件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-getdarkmode-收集-dark-mode-配置中的文件",children:"#"}),"5. getDarkMode 收集 dark mode 配置中的文件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n   * 收集 dark mode 配置中的文件\n   */\n  getDarkMode () {\n    const themeLocation = this.appConfig.themeLocation\n    const darkMode = this.appConfig.darkmode\n    if (darkMode && themeLocation && typeof themeLocation === 'string') {\n      this.themeLocation = themeLocation\n    }\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/darkmode.html",rel:"noopener noreferrer",target:"_blank",children:"DarkMode 适配指南"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"darkmode",src:b})}),"\n",(0,s.jsx)(n.p,{children:"收集起来，后续再使用。"}),"\n",(0,s.jsxs)(n.p,{children:["我们接下来看 ",(0,s.jsx)(n.code,{children:"getConfigFiles"})," 的实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-getconfigfiles-往-thisdependencies-中新增或修改所有-config-配置模块",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-getconfigfiles-往-thisdependencies-中新增或修改所有-config-配置模块",children:"#"}),"6. getConfigFiles 往 this.dependencies 中新增或修改所有 config 配置模块"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n   * 往 this.dependencies 中新增或修改所有 config 配置模块\n   */\n  getConfigFiles (compiler: Compiler) {\n    const filesConfig = this.filesConfig\n    Object.keys(filesConfig).forEach(item => {\n      if (fs.existsSync(filesConfig[item].path)) {\n        this.addEntry(filesConfig[item].path, item, META_TYPE.CONFIG)\n      }\n    })\n\n    // webpack createChunkAssets 前一刻，去除所有 config chunks\n    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {\n      compilation.hooks.beforeChunkAssets.tap(PLUGIN_NAME, () => {\n        const chunks = compilation.chunks\n        const configNames = Object.keys(filesConfig)\n\n        for (const chunk of chunks) {\n          if (configNames.find(configName => configName === chunk.name)) chunks.delete(chunk)\n        }\n      })\n    })\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["把 ",(0,s.jsx)(n.code,{children:"compileFile"})," 编译的文件，全部遍历标记为配置文件，添加到 ",(0,s.jsx)(n.code,{children:"dependencies"})," 中。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"webpack"})," ",(0,s.jsx)(n.code,{children:"createChunkAssets"})," 前一刻，去除所有 ",(0,s.jsx)(n.code,{children:"config chunks"})]}),"\n",(0,s.jsxs)(n.h2,{id:"7-addentries-在-thisdependencies-中新增或修改-app模板组件页面组件等资源模块",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-addentries-在-thisdependencies-中新增或修改-app模板组件页面组件等资源模块",children:"#"}),"7. addEntries 在 this.dependencies 中新增或修改 app、模板组件、页面、组件等资源模块"]}),"\n",(0,s.jsxs)(n.p,{children:["加入依赖项中的类型。方便针对不同类型，采用不同的 ",(0,s.jsx)(n.code,{children:"loader"})," 处理。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-helper/src/constants.ts\nexport enum META_TYPE {\n  ENTRY = 'ENTRY',\n  PAGE = 'PAGE',\n  COMPONENT = 'COMPONENT',\n  NORMAL = 'NORMAL',\n  STATIC = 'STATIC',\n  CONFIG = 'CONFIG',\n  EXPORTS = 'EXPORTS',\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n   * 在 this.dependencies 中新增或修改 app、模板组件、页面、组件等资源模块\n   */\n  addEntries () {\n    const { template } = this.options\n\n    this.addEntry(this.appEntry, 'app', META_TYPE.ENTRY)\n    if (!template.isSupportRecursive) {\n      this.addEntry(path.resolve(__dirname, '..', 'template/comp'), 'comp', META_TYPE.STATIC)\n    }\n    this.addEntry(path.resolve(__dirname, '..', 'template/custom-wrapper'), 'custom-wrapper', META_TYPE.STATIC)\n	// 拆分到下方\n  }\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"添加应用入口"}),"\n",(0,s.jsx)(n.li,{children:"添加模板组件"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果模板不支持递归，添加 comp 组件"}),"\n",(0,s.jsx)(n.li,{children:"添加 custom-wrapper 组件"}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"添加页面"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果是原生页面，添加页面文件、样式文件和模板文件"}),"\n",(0,s.jsx)(n.li,{children:"如果是普通页面，只添加页面文件"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"遍历页面添加到依赖项中。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n    this.pages.forEach(item => {\n      if (item.isNative) {\n        this.addEntry(item.path, item.name, META_TYPE.NORMAL, { isNativePage: true })\n        if (item.stylePath && fs.existsSync(item.stylePath)) {\n          this.addEntry(item.stylePath, this.getStylePath(item.name), META_TYPE.NORMAL)\n        }\n        if (item.templatePath && fs.existsSync(item.templatePath)) {\n          this.addEntry(item.templatePath, this.getTemplatePath(item.name), META_TYPE.NORMAL)\n        }\n      } else {\n        this.addEntry(item.path, item.name, META_TYPE.PAGE)\n      }\n    })\n"})}),"\n",(0,s.jsx)(n.p,{children:"遍历组件添加到依赖项中。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n    this.components.forEach(item => {\n      if (item.isNative) {\n        this.addEntry(item.path, item.name, META_TYPE.NORMAL, { isNativePage: true })\n        if (item.stylePath && fs.existsSync(item.stylePath)) {\n          this.addEntry(item.stylePath, this.getStylePath(item.name), META_TYPE.NORMAL)\n        }\n        if (item.templatePath && fs.existsSync(item.templatePath)) {\n          this.addEntry(item.templatePath, this.getTemplatePath(item.name), META_TYPE.NORMAL)\n        }\n      } else {\n        this.addEntry(item.path, item.name, META_TYPE.COMPONENT)\n      }\n    })\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"71-addentry-在-thisdependencies-中新增或修改模块",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-addentry-在-thisdependencies-中新增或修改模块",children:"#"}),"7.1 addEntry 在 this.dependencies 中新增或修改模块"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\n/**\n   * 在 this.dependencies 中新增或修改模块\n   */\n  addEntry (entryPath: string, entryName: string, entryType: META_TYPE, options = {}) {\n    let dep: TaroSingleEntryDependency\n    if (this.dependencies.has(entryPath)) {\n      dep = this.dependencies.get(entryPath)!\n      dep.name = entryName\n      dep.loc = { name: entryName }\n      dep.request = entryPath\n      dep.userRequest = entryPath\n      dep.miniType = entryType\n      dep.options = options\n    } else {\n      dep = new TaroSingleEntryDependency(entryPath, entryName, { name: entryName }, entryType, options)\n    }\n    this.dependencies.set(entryPath, dep)\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"this.dependencies 是这样的结构。存储的是路径和 TaroSingleEntryDependency 实例对象。如果存在则更新。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"dependencies",src:k})}),"\n",(0,s.jsxs)(n.p,{children:["行文至此，我们完成了对 ",(0,s.jsx)(n.code,{children:"run"})," 函数的分析。分析 ",(0,s.jsx)(n.code,{children:"app"})," 入口文件，搜集页面、组件信息，往 ",(0,s.jsx)(n.code,{children:"this.dependencies"})," 中添加资源模块。后续针对不同的类型，采用不同的 ",(0,s.jsx)(n.code,{children:"loader"})," 处理等。"]}),"\n",(0,s.jsxs)(n.h2,{id:"8-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-总结",children:"#"}),"8. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["根据 webpack entry 配置获取入口文件路径\n这里的 ",(0,s.jsx)(n.code,{children:"this.appEntry"})," 是 ",(0,s.jsx)(n.code,{children:'"/Users/ruochuan/git-source/github/taro4-debug/src/app.ts"'})]}),"\n",(0,s.jsxs)(n.p,{children:["根据入口文件获取到配置文件，",(0,s.jsx)(n.code,{children:"app.config.ts"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"run 函数"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["首先通过 getAppConfig() 获取应用配置","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["然后依次执行：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"getPages() 获取页面信息（从 app.config.ts 中 pages 读取）"}),"\n",(0,s.jsx)(n.li,{children:"getPagesConfig() 获取页面配置（找到对应的页面配置）"}),"\n",(0,s.jsx)(n.li,{children:"getDarkMode() 获取暗黑模式配置"}),"\n",(0,s.jsx)(n.li,{children:"getConfigFiles(compiler) 获取配置文件（包含第三方组件等）"}),"\n",(0,s.jsx)(n.li,{children:"addEntries() 在 this.dependencies 中新增或修改 app、模板组件、页面、组件等资源模块"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"compileFile"})," 函数是重点，读取页面、组件的配置，并递归读取依赖的组件的配置。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"readConfig"})," 读取配置文件"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fs.readJSONSync"})," 读取 JSON"]}),"\n",(0,s.jsxs)(n.li,{children:["通过 ",(0,s.jsx)(n.code,{children:"esbuild"})," 的 ",(0,s.jsx)(n.code,{children:"require"})," 实现"]}),"\n",(0,s.jsxs)(n.li,{children:["或者通过 ",(0,s.jsx)(n.code,{children:"AST"})," 读取页面配置文件"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"启发：Taro 是非常知名的跨端框架，我们在使用它，享受它带来便利的同时，有余力也可以多为其做出一些贡献。比如帮忙解答一些 issue 或者提 pr 修改 bug 等。\n在这个过程，我们会不断学习，促使我们去解决问题，带来的好处则是不断拓展知识深度和知识广度。\n有些时候还是需要深入学习源码，理解源码才能更好的针对项目做相应的优化。"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,s.jsx)(n.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后可以持续关注我",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function C(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(P,e)})):P(e)}let y=C;C.__RSPRESS_PAGE_META={},C.__RSPRESS_PAGE_META["taro%2Fmini-plugin-2%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-getappconfig-获取入口配置文件配置",text:"2. getAppConfig 获取入口配置文件配置",depth:2},{id:"21-modifyappconfig-修改-appconfigts-配置文件",text:"2.1 modifyAppConfig 修改 app.config.ts 配置文件",depth:3},{id:"22-taro-409-版本增加按需编译-pages-或-components-能力",text:"2.2 Taro 4.0.9 版本增加按需编译 pages 或 components 能力",depth:3},{id:"23-compilefile-读取页面组件的配置并递归读取依赖的组件的配置",text:"2.3 compileFile 读取页面、组件的配置，并递归读取依赖的组件的配置",depth:3},{id:"24-readconfig-读取配置",text:"2.4 readConfig 读取配置",depth:3},{id:"241-requirewithesbuild",text:"2.4.1 requireWithEsbuild",depth:4},{id:"242-getmoduledefaultexport-处理模块默认导出",text:"2.4.2 getModuleDefaultExport 处理模块默认导出",depth:4},{id:"243-readpageconfig-读取页面配置",text:"2.4.3 readPageConfig 读取页面配置",depth:4},{id:"244-readsfcpageconfig",text:"2.4.4 readSFCPageConfig",depth:4},{id:"3-getpages-获取页面信息",text:"3. getPages 获取页面信息",depth:2},{id:"4-getpagesconfig-读取页面及其依赖的组件的配置",text:"4. getPagesConfig 读取页面及其依赖的组件的配置",depth:2},{id:"5-getdarkmode-收集-dark-mode-配置中的文件",text:"5. getDarkMode 收集 dark mode 配置中的文件",depth:2},{id:"6-getconfigfiles-往-thisdependencies-中新增或修改所有-config-配置模块",text:"6. getConfigFiles 往 this.dependencies 中新增或修改所有 config 配置模块",depth:2},{id:"7-addentries-在-thisdependencies-中新增或修改-app模板组件页面组件等资源模块",text:"7. addEntries 在 this.dependencies 中新增或修改 app、模板组件、页面、组件等资源模块",depth:2},{id:"71-addentry-在-thisdependencies-中新增或修改模块",text:"7.1 addEntry 在 this.dependencies 中新增或修改模块",depth:3},{id:"8-总结",text:"8. 总结",depth:2}],title:"Taro 源码揭秘：11. Taro 项目开发编译速度太慢，怎么办？写个简单插件按需编译",headingTitle:"Taro 源码揭秘：11. Taro 项目开发编译速度太慢，怎么办？写个简单插件按需编译",frontmatter:{highlight:"darcula",theme:"smartblue"}}}}]);