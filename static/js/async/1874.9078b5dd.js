"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["1874"],{18500:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var a=r(52676),i=r(40453),s=r(20713);let o=r.p+"static/image/taro-webpack.f2577a1e.png",t=r.p+"static/svg/apply.5aa4f4c2.svg",l=r.p+"static/image/mini-plugin-before-run.9d630087.png",c=r.p+"static/image/mini-plugin-after-run.31ed851c.png";function p(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",input:"input",pre:"pre",strong:"strong",img:"img",h3:"h3",hr:"hr"},(0,i.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"taro-源码揭秘10-taro-到底是怎样转换成小程序文件的",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘10-taro-到底是怎样转换成小程序文件的",children:"#"}),"Taro 源码揭秘：10. Taro 到底是怎样转换成小程序文件的？"]}),"\n",(0,a.jsx)(s.Z,{defaultLocale:"zh-CN"}),"\n",(0,a.jsxs)(e.h2,{id:"1-前言",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,a.jsxs)(e.p,{children:["大家好，我是",(0,a.jsx)(e.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,a.jsx)(e.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,a.jsxs)(e.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,a.jsx)(e.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,a.jsx)(e.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,a.jsxs)(e.p,{children:["截至目前（",(0,a.jsx)(e.code,{children:"2024-12-26"}),"），目前最新是 ",(0,a.jsx)(e.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.8",rel:"noopener noreferrer",target:"_blank",children:(0,a.jsx)(e.code,{children:"4.0.8"})}),"，官方",(0,a.jsx)(e.code,{children:"4.0"}),"正式版本的介绍文章暂未发布。官方之前发过",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。"]}),"\n",(0,a.jsxs)(e.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,a.jsx)(e.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,a.jsx)(e.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,a.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。\n第 5-7 篇讲述的是运行时相关的 Events、API、request 等。\n第 10 篇接着继续追随第 4 篇和第 8、9 篇的脚步，分析 TaroMiniPlugin webpack 的插件实现。"}),"\n",(0,a.jsxs)(e.p,{children:["关于克隆项目、环境准备、如何调试代码等，参考",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第一篇文章-准备工作、调试"}),"。后续文章基本不再过多赘述。"]}),"\n",(0,a.jsx)(e.p,{children:"学完本文，你将学到："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"1. Taro 到底是怎样转换成小程序的？\n2. 熟悉 webpack 核心库 tapable 事件机制\n3. 对 webpack 自定义插件和 compiler 钩子等有比较深刻的认识\n4. 对 webpack 自定义 loader 等有比较深刻的认识\n等等\n"})}),"\n",(0,a.jsx)(e.p,{children:"我们先来看 TaroMiniPlugin 结构"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"// packages/taro-webpack5-runner/src/plugins/MiniPlugin.ts\nexport default class TaroMiniPlugin {\n	constructor(options: ITaroMiniPluginOptions) {\n		this.options = {};\n	}\n	// 插件入口\n	apply(compiler) {}\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"在 webpack.config.js 配置 TaroMiniPlugin。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"// webpack.config.js\nexport default {\n	entry: {},\n	output: {},\n	plugins: [\n		new TaroMiniPlugin({\n			// 配置项\n		}),\n	],\n};\n"})}),"\n",(0,a.jsxs)(e.p,{children:["我们来看",(0,a.jsx)(e.a,{href:"https://webpack.docschina.org/contribute/writing-a-plugin/",rel:"noopener noreferrer",target:"_blank",children:"文档：webpack 自定义插件"})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"创建插件"})}),"\n",(0,a.jsx)(e.p,{children:"webpack 插件由以下组成："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"一个 JavaScript 命名函数或 JavaScript 类。"}),"\n",(0,a.jsx)(e.li,{children:"在插件函数的 prototype 上定义一个 apply 方法。"}),"\n",(0,a.jsx)(e.li,{children:"指定一个绑定到 webpack 自身的事件钩子。"}),"\n",(0,a.jsx)(e.li,{children:"处理 webpack 内部实例的特定数据。"}),"\n",(0,a.jsx)(e.li,{children:"功能完成后调用 webpack 提供的回调。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"我们再来看下 webpack 源码中对于插件的处理。就能够更清晰的理解文档的意思。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'// lib/webpack.js\n// https://github.com/webpack/webpack/blob/main/lib/webpack.js#L75-L84\nif (Array.isArray(options.plugins)) {\n	for (const plugin of options.plugins) {\n		if (typeof plugin === "function") {\n			plugin.call(compiler, compiler);\n		} else if (plugin) {\n			plugin.apply(compiler);\n		}\n	}\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"TaroMiniPlugin"})," 插件的主要作用就是把 ",(0,a.jsx)(e.code,{children:"Taro"})," 项目转换成小程序项目。如下图所示："]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"taro-webpack",src:o})}),"\n",(0,a.jsx)(e.p,{children:"本文我们来分析其实现和原理。"}),"\n",(0,a.jsxs)(e.h2,{id:"2-插件属性",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-插件属性",children:"#"}),"2. 插件属性"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'export default class TaroMiniPlugin {\n	/** 插件配置选项 */\n	options: IOptions;\n	// Webpack 编译上下文\n	context: string;\n	/** app 入口文件路径 */\n	appEntry: string;\n	/** app config 配置内容 */\n	appConfig: AppConfig;\n	/** app、页面、组件的配置集合 */\n	filesConfig: IMiniFilesConfig = {};\n	//  是否处于 watch 模式\n	isWatch = false;\n	/** 页面列表 */\n	pages = new Set<IComponent>();\n	// 组件集合\n	components = new Set<IComponent>();\n	/** 新的混合原生编译模式 newBlended 模式下，需要单独编译成原生代码的 component 的Map */\n	nativeComponents = new Map<string, IComponent>();\n	/** tabbar icon 图片路径列表 */\n	tabBarIcons = new Set<string>();\n	//  预渲染页面集合\n	prerenderPages = new Set<string>();\n	// 依赖集合\n	dependencies = new Map<string, TaroSingleEntryDependency>();\n	// 加载块插件实例。\n	loadChunksPlugin: TaroLoadChunksPlugin;\n	// 主题位置\n	themeLocation: string;\n	// 页面 loader 名称\n	pageLoaderName = "@tarojs/taro-loader/lib/page";\n	// 独立包集合\n	independentPackages = new Map<string, IndependentPackage>();\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Taro 项目 - 入口文件"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'// src/app.ts\nimport { PropsWithChildren } from "react";\nimport { useLaunch } from "@tarojs/taro";\nimport "./app.less";\n\nfunction App({ children }: PropsWithChildren<any>) {\n	useLaunch(() => {\n		console.log("App launched.");\n	});\n	// children 是将要会渲染的页面\n	return children;\n}\n\nexport default App;\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Taro 项目 - 入口配置"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'// src/app.config.ts\nexport default defineAppConfig({\n	pages: ["pages/index/index"],\n	window: {\n		backgroundTextStyle: "light",\n		navigationBarBackgroundColor: "#fff",\n		navigationBarTitleText: "WeChat",\n		navigationBarTextStyle: "black",\n	},\n});\n'})}),"\n",(0,a.jsxs)(e.h2,{id:"3-插件入口-apply-函数",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-插件入口-apply-函数",children:"#"}),"3. 插件入口 apply 函数"]}),"\n",(0,a.jsx)(e.p,{children:"我们来看插件入口 apply 函数的流程。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"export default class TaroMiniPlugin {\n	// 插件入口\n	apply(compiler: Compiler) {\n		this.context = compiler.context;\n		this.appEntry = this.getAppEntry(compiler);\n\n		const {\n			commonChunks,\n			combination,\n			framework,\n			isBuildPlugin,\n			newBlended,\n		} = this.options;\n\n		// 省略若干代码...\n\n		/** build mode */\n		compiler.hooks.run.tapAsync();\n\n		/** watch mode */\n		compiler.hooks.watchRun.tapAsync();\n\n		/** compilation.addEntry */\n		compiler.hooks.make.tapAsync();\n\n		compiler.hooks.compilation.tap();\n\n		compiler.hooks.afterEmit.tapAsync();\n\n		new TaroNormalModulesPlugin(onParseCreateElement).apply(compiler);\n\n		newBlended && this.addLoadChunksPlugin(compiler);\n	}\n}\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.a,{href:"https://github.com/webpack/tapable",rel:"noopener noreferrer",target:"_blank",children:"tapable"})," 事件机制"]}),"\n",(0,a.jsx)(e.p,{children:"tap 是监听注册事件、call 是执行事件"}),"\n",(0,a.jsxs)(e.p,{children:["和第5篇类似 ",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"compiler.hooks.run.tapAsync(); 开始编译"}),"\n",(0,a.jsx)(e.li,{children:"compiler.hooks.watchRun.tapAsync(); 开始编译（监听模式）"}),"\n",(0,a.jsx)(e.li,{children:"compiler.hooks.make.tapAsync(); 从 entry 开始递归的分析依赖，对每个依赖模块进行 build"}),"\n",(0,a.jsx)(e.li,{children:"compiler.hooks.compilation.tap();"}),"\n",(0,a.jsx)(e.li,{children:"compiler.hooks.afterEmit.tapAsync(); 输出文件到目录（之后）"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"插件入口 apply 函数的执行过程如下图所示：\n有个大概印象即可，后文继续看具体代码实现。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"TaroMiniPlugin webpack 插件 apply 方法",src:t})}),"\n",(0,a.jsxs)(e.h2,{id:"4-注册-compilerhooksrun-钩子",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-注册-compilerhooksrun-钩子",children:"#"}),"4. 注册 compiler.hooks.run 钩子"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"const PLUGIN_NAME = 'TaroMiniPlugin'\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"/** build mode */\ncompiler.hooks.run.tapAsync(\n	PLUGIN_NAME,\n	this.tryAsync<Compiler>(async (compiler) => {\n		await this.run(compiler);\n		new TaroLoadChunksPlugin({\n			commonChunks: commonChunks,\n			isBuildPlugin,\n			addChunkPages,\n			pages: this.pages,\n			framework: framework,\n		}).apply(compiler);\n	})\n);\n"})}),"\n",(0,a.jsx)(e.p,{children:"tapAsync\n当我们用 tapAsync 方法来绑定插件时，必须调用函数的最后一个参数 callback 指定的回调函数。"}),"\n",(0,a.jsxs)(e.p,{children:["所以封装了一个 ",(0,a.jsx)(e.code,{children:"tryAsync"})," 方法。"]}),"\n",(0,a.jsxs)(e.h3,{id:"41-tryasync-函数---自动驱动-tapasync",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#41-tryasync-函数---自动驱动-tapasync",children:"#"}),"4.1 tryAsync 函数 - 自动驱动 tapAsync"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"/**\n * 自动驱动 tapAsync\n */\ntryAsync<T extends Compiler | Compilation> (fn: (target: T) => Promise<any>) {\n    return async (arg: T, callback: any) => {\n      try {\n        await fn(arg)\n        callback()\n      } catch (err) {\n        callback(err)\n      }\n    }\n}\n"})}),"\n",(0,a.jsxs)(e.p,{children:["调试源码。本文就不赘述了，分别是",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7378363694939783178#heading-1",rel:"noopener noreferrer",target:"_blank",children:"第 1 篇 taro init"}),"和",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7403193330271682612#heading-2",rel:"noopener noreferrer",target:"_blank",children:"第 4 篇 npm run dev:weapp"}),"详细讲述过。"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"before-run",src:l})}),"\n",(0,a.jsxs)(e.h3,{id:"42-run-函数---分析-app-入口文件搜集页面组件信息",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#42-run-函数---分析-app-入口文件搜集页面组件信息",children:"#"}),"4.2 run 函数 - 分析 app 入口文件，搜集页面、组件信息"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"/**\n * 分析 app 入口文件，搜集页面、组件信息，\n * 往 this.dependencies 中添加资源模块\n */\nasync run (compiler: Compiler) {\n	if (this.options.isBuildPlugin) {\n		this.getPluginFiles()\n		this.getConfigFiles(compiler)\n	} else {\n		this.appConfig = await this.getAppConfig()\n		this.getPages()\n		this.getPagesConfig()\n		this.getDarkMode()\n		this.getConfigFiles(compiler)\n		this.addEntries()\n	}\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"after-run",src:c})}),"\n",(0,a.jsxs)(e.h2,{id:"5-注册-compilerhookswatchrun-钩子",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-注册-compilerhookswatchrun-钩子",children:"#"}),"5. 注册 compiler.hooks.watchRun 钩子"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"/** watch mode */\ncompiler.hooks.watchRun.tapAsync(\n	PLUGIN_NAME,\n	this.tryAsync<Compiler>(async (compiler) => {\n		const changedFiles = this.getChangedFiles(compiler);\n		if (changedFiles && changedFiles?.size > 0) {\n			this.isWatch = true;\n		}\n		await this.run(compiler);\n		if (!this.loadChunksPlugin) {\n			this.loadChunksPlugin = new TaroLoadChunksPlugin({\n				commonChunks: commonChunks,\n				isBuildPlugin,\n				addChunkPages,\n				pages: this.pages,\n				framework: framework,\n			});\n			this.loadChunksPlugin.apply(compiler);\n		}\n	})\n);\n"})}),"\n",(0,a.jsxs)(e.h2,{id:"6-注册-compilerhooksmake-钩子",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6-注册-compilerhooksmake-钩子",children:"#"}),"6. 注册 compiler.hooks.make 钩子"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"/** compilation.addEntry */\ncompiler.hooks.make.tapAsync(\n	PLUGIN_NAME,\n	this.tryAsync<Compilation>(async (compilation) => {\n		const dependencies = this.dependencies;\n		const promises: Promise<null>[] = [];\n		this.compileIndependentPages(\n			compiler,\n			compilation,\n			dependencies,\n			promises\n		);\n		dependencies.forEach((dep) => {\n			promises.push(\n				new Promise<null>((resolve, reject) => {\n					compilation.addEntry(\n						this.options.sourceDir,\n						dep,\n						{\n							name: dep.name,\n							...dep.options,\n						},\n						(err) => (err ? reject(err) : resolve(null))\n					);\n				})\n			);\n		});\n		await Promise.all(promises);\n		await onCompilerMake?.(compilation, compiler, this);\n	})\n);\n"})}),"\n",(0,a.jsxs)(e.p,{children:["遍历收集好的页面 ",(0,a.jsx)(e.code,{children:"dependencies"})," 页面依赖，",(0,a.jsx)(e.code,{children:"addEntry"})," 添加入口，也就是说是多入口编译文件。调用开发者传入的 onCompilerMake 钩子函数。"]}),"\n",(0,a.jsxs)(e.h2,{id:"7-注册-compilerhookscompilation-钩子",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7-注册-compilerhookscompilation-钩子",children:"#"}),"7. 注册 compiler.hooks.compilation 钩子"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"compiler.hooks.compilation.tap(\n	PLUGIN_NAME,\n	(compilation, { normalModuleFactory }) => {\n		/** For Webpack compilation get factory from compilation.dependencyFactories by denpendence's constructor */\n		compilation.dependencyFactories.set(\n			EntryDependency,\n			normalModuleFactory\n		);\n		compilation.dependencyFactories.set(\n			TaroSingleEntryDependency as any,\n			normalModuleFactory\n		);\n\n		/**\n		 * webpack NormalModule 在 runLoaders 真正解析资源的前一刻，\n		 * 往 NormalModule.loaders 中插入对应的 Taro Loader\n		 */\n		compiler.webpack.NormalModule.getCompilationHooks(\n			compilation\n		).loader.tap(\n			PLUGIN_NAME,\n			(_loaderContext, module: /** TaroNormalModule */ any) => {\n				// 拆开放在下方讲述\n			}\n		);\n\n		const {\n			PROCESS_ASSETS_STAGE_ADDITIONAL,\n			PROCESS_ASSETS_STAGE_OPTIMIZE,\n			PROCESS_ASSETS_STAGE_REPORT,\n		} = compiler.webpack.Compilation;\n\n		// 拆开放在下方讲述\n		compilation.hooks.processAssets.tapAsync();\n	}\n);\n"})}),"\n",(0,a.jsxs)(e.h3,{id:"71-compilerwebpacknormalmodulegetcompilationhookscompilationloadertap",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#71-compilerwebpacknormalmodulegetcompilationhookscompilationloadertap",children:"#"}),"7.1 compiler.webpack.NormalModule.getCompilationHooks(compilation).loader.tap"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'/**\n * webpack NormalModule 在 runLoaders 真正解析资源的前一刻，\n * 往 NormalModule.loaders 中插入对应的 Taro Loader\n */\ncompiler.webpack.NormalModule.getCompilationHooks(compilation).loader.tap(\n	PLUGIN_NAME,\n	(_loaderContext, module: /** TaroNormalModule */ any) => {\n		const { framework, loaderMeta, pxTransformConfig } = this.options;\n\n		if (module.miniType === META_TYPE.ENTRY) {\n			const loaderName = "@tarojs/taro-loader";\n			if (!isLoaderExist(module.loaders, loaderName)) {\n				module.loaders.unshift({\n					loader: loaderName,\n					options: {\n						// 省略参数 ...\n					},\n				});\n			}\n		} else if (module.miniType === META_TYPE.PAGE) {\n			let isIndependent = false;\n			this.independentPackages.forEach(({ pages }) => {\n				if (pages.includes(module.resource)) {\n					isIndependent = true;\n				}\n			});\n			const isNewBlended = this.nativeComponents.has(module.name);\n			const loaderName =\n				isNewBlended || isBuildPlugin\n					? "@tarojs/taro-loader/lib/native-component"\n					: isIndependent\n					? "@tarojs/taro-loader/lib/independentPage"\n					: this.pageLoaderName;\n\n			if (!isLoaderExist(module.loaders, loaderName)) {\n				module.loaders.unshift({\n					loader: loaderName,\n					options: {\n						// 省略参数 ...\n					},\n				});\n			}\n		} else if (module.miniType === META_TYPE.COMPONENT) {\n			const loaderName = isBuildPlugin\n				? "@tarojs/taro-loader/lib/native-component"\n				: "@tarojs/taro-loader/lib/component";\n			if (!isLoaderExist(module.loaders, loaderName)) {\n				module.loaders.unshift({\n					loader: loaderName,\n					options: {\n						// 省略参数 ...\n					},\n				});\n			}\n		}\n	}\n);\n'})}),"\n",(0,a.jsx)(e.p,{children:"webpack NormalModule 在 runLoaders 真正解析资源的前一刻，\n往 NormalModule.loaders 中插入对应的 Taro Loader"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"入口文件使用 @tarojs/taro-loader"}),"\n",(0,a.jsx)(e.li,{children:"页面使用 @tarojs/taro-loader/lib/page"}),"\n",(0,a.jsx)(e.li,{children:"原生组件使用 @tarojs/taro-loader/lib/native-component"}),"\n",(0,a.jsx)(e.li,{children:"组件使用 @tarojs/taro-loader/lib/component"}),"\n",(0,a.jsx)(e.li,{children:"独立分包使用 @tarojs/taro-loader/lib/independentPage"}),"\n"]}),"\n",(0,a.jsxs)(e.h3,{id:"72-注册-compilationhooksprocessassets-钩子",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#72-注册-compilationhooksprocessassets-钩子",children:"#"}),"7.2 注册 compilation.hooks.processAssets 钩子"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'const {\n	PROCESS_ASSETS_STAGE_ADDITIONAL,\n	PROCESS_ASSETS_STAGE_OPTIMIZE,\n	PROCESS_ASSETS_STAGE_REPORT,\n} = compiler.webpack.Compilation;\ncompilation.hooks.processAssets.tapAsync(\n	{\n		name: PLUGIN_NAME,\n		stage: PROCESS_ASSETS_STAGE_ADDITIONAL,\n	},\n	this.tryAsync<any>(async () => {\n		// 如果是子编译器，证明是编译独立分包，进行单独的处理\n		if ((compilation as any).__tag === CHILD_COMPILER_TAG) {\n			await this.generateIndependentMiniFiles(compilation, compiler);\n		} else {\n			await this.generateMiniFiles(compilation, compiler);\n		}\n	})\n);\ncompilation.hooks.processAssets.tapAsync(\n	{\n		name: PLUGIN_NAME,\n		// 删除 assets 的相关操作放在触发时机较后的 Stage，避免过早删除出现的一些问题，#13988\n		// Stage 触发顺序：https://webpack.js.org/api/compilation-hooks/#list-of-asset-processing-stages\n		stage: PROCESS_ASSETS_STAGE_OPTIMIZE,\n	},\n	this.tryAsync<any>(async () => {\n		await this.optimizeMiniFiles(compilation, compiler);\n	})\n);\n\ncompilation.hooks.processAssets.tapAsync(\n	{\n		name: PLUGIN_NAME,\n		// 该 stage 是最后执行的，确保 taro 暴露给用户的钩子 modifyBuildAssets 在内部处理完 assets 之后再调用\n		stage: PROCESS_ASSETS_STAGE_REPORT,\n	},\n	this.tryAsync<any>(async () => {\n		if (typeof modifyBuildAssets === "function") {\n			await modifyBuildAssets(compilation.assets, this);\n		}\n	})\n);\n'})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"在 PROCESS_ASSETS_STAGE_ADDITIONAL 阶段，如果是子编译器，证明是编译独立分包，进行单独的处理，否则生成小程序文件"}),"\n",(0,a.jsx)(e.li,{children:"在 PROCESS_ASSETS_STAGE_OPTIMIZE 阶段，优化小程序文件"}),"\n",(0,a.jsx)(e.li,{children:"在 PROCESS_ASSETS_STAGE_REPORT 阶段，调用开发者传入的自定义的钩子 modifyBuildAssets 函数 修改编译产物"}),"\n"]}),"\n",(0,a.jsxs)(e.h2,{id:"8-注册-compilerhooksafteremit-钩子",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#8-注册-compilerhooksafteremit-钩子",children:"#"}),"8. 注册 compiler.hooks.afterEmit 钩子"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:"compiler.hooks.afterEmit.tapAsync(\n	PLUGIN_NAME,\n	this.tryAsync<Compilation>(async (compilation) => {\n		await this.addTarBarFilesToDependencies(compilation);\n	})\n);\n"})}),"\n",(0,a.jsx)(e.p,{children:"生成文件之后，添加 tabbar 文件到依赖中。"}),"\n",(0,a.jsxs)(e.h2,{id:"9-总结",children:[(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9-总结",children:"#"}),"9. 总结"]}),"\n",(0,a.jsxs)(e.p,{children:["最后我们来总结一下，",(0,a.jsx)(e.code,{children:"TaroMiniPlugin"})," 是 webpack 插件。"]}),"\n",(0,a.jsx)(e.p,{children:"本文我们主要是通过调试源码，分析了插件入口 apply 函数。"}),"\n",(0,a.jsxs)(e.p,{children:["其主要实现是读取入口文件、入口配置，把页面、页面配置和组件等收集起来。\n然后交给 ",(0,a.jsx)(e.code,{children:"webpack"})," 处理（对应的 ",(0,a.jsx)(e.code,{children:"taro-loader"}),"）。\n最后输出对应平台的小程序文件（template、css、json 等）。"]}),"\n",(0,a.jsx)(e.p,{children:"我们学习了 webpack 插件的编写和 tapable 的作用。知道了 TaroMiniPlugin 原理。"}),"\n",(0,a.jsx)(e.p,{children:"启发：Taro 是非常知名的跨端框架，我们在使用它，享受它带来便利的同时，有余力也可以多为其做出一些贡献。比如帮忙解答一些 issue 或者提 pr 修改 bug 等。\n在这个过程，我们会不断学习，促使我们去解决问题，带来的好处则是不断拓展知识深度和知识广度。"}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论"}),"。"]}),"\n",(0,a.jsxs)(e.p,{children:["作者：常以",(0,a.jsx)(e.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,a.jsx)(e.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,a.jsx)(e.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,a.jsx)(e.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,a.jsxs)(e.p,{children:["最后可以持续关注我",(0,a.jsx)(e.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,a.jsx)(e.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,a.jsx)(e.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,a.jsxs)(e.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,a.jsx)(e.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,a.jsx)(e.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(p,n)})):p(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["taro%2Fmini-plugin%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-插件属性",text:"2. 插件属性",depth:2},{id:"3-插件入口-apply-函数",text:"3. 插件入口 apply 函数",depth:2},{id:"4-注册-compilerhooksrun-钩子",text:"4. 注册 compiler.hooks.run 钩子",depth:2},{id:"41-tryasync-函数---自动驱动-tapasync",text:"4.1 tryAsync 函数 - 自动驱动 tapAsync",depth:3},{id:"42-run-函数---分析-app-入口文件搜集页面组件信息",text:"4.2 run 函数 - 分析 app 入口文件，搜集页面、组件信息",depth:3},{id:"5-注册-compilerhookswatchrun-钩子",text:"5. 注册 compiler.hooks.watchRun 钩子",depth:2},{id:"6-注册-compilerhooksmake-钩子",text:"6. 注册 compiler.hooks.make 钩子",depth:2},{id:"7-注册-compilerhookscompilation-钩子",text:"7. 注册 compiler.hooks.compilation 钩子",depth:2},{id:"71-compilerwebpacknormalmodulegetcompilationhookscompilationloadertap",text:"7.1 compiler.webpack.NormalModule.getCompilationHooks(compilation).loader.tap",depth:3},{id:"72-注册-compilationhooksprocessassets-钩子",text:"7.2 注册 compilation.hooks.processAssets 钩子",depth:3},{id:"8-注册-compilerhooksafteremit-钩子",text:"8. 注册 compiler.hooks.afterEmit 钩子",depth:2},{id:"9-总结",text:"9. 总结",depth:2}],title:"Taro 源码揭秘：10. Taro 到底是怎样转换成小程序文件的？",headingTitle:"Taro 源码揭秘：10. Taro 到底是怎样转换成小程序文件的？",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(n,e,r){r.d(e,{Z:()=>l});var a=r(52676),i=r(75271),s=r(92815);r(18544);let o={"zh-CN":n=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${n.minutes>=1?`${Math.ceil(n.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function t(n,e,r){let a=Object.keys(o).includes(e)?e:r;return o[a](n)}let l=n=>{let{defaultLocale:e="en-US"}=n,r=(0,s.Vi)().page.readingTimeData,o=(0,s.Jr)(),l=(0,s.e7)(),[c,p]=(0,i.useState)(t(r,o,e));return(0,i.useEffect)(()=>{p(t(r,o,e))},[o,r]),(0,a.jsx)("span",{"data-dark":String(l),className:"rp-reading-time",children:c})}}}]);