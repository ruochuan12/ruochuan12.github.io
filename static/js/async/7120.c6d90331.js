"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["7120"],{60332:function(e,n,r){e.exports=r.p+"static/image/wechat-official-accounts-mini.44481959.png"},51486:function(e,n,r){e.exports=r.p+"static/image/demo-chain-map-result-debugger.c317ea7e.png"},88151:function(e,n,r){e.exports=r.p+"static/image/demo-chain-map-result.1e64cf2b.png"},78623:function(e,n,r){e.exports=r.p+"static/image/lodash-v4.17.15-LazyWrapper.prototype.5bd4ec8d.png"},55973:function(e,n,r){e.exports=r.p+"static/image/lodash-v4.17.15-lodash.prototype-mixin.b55f4fcf.png"},92603:function(e,n,r){e.exports=r.p+"static/image/lodash-v4.17.15-prototype.3235d92c.png"},22398:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var a=r(52676),s=r(40453),t=r(20713),o=r(92603),i=r(55973),c=r(51486),d=r(88151),l=r(78623),h=r(60332);function p(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",strong:"strong",blockquote:"blockquote",pre:"pre",h3:"h3",img:"img",h4:"h4"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"学习-lodash--源码整体架构打造属于自己的函数式编程类库",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#学习-lodash--源码整体架构打造属于自己的函数式编程类库",children:"#"}),"学习 lodash  源码整体架构，打造属于自己的函数式编程类库"]}),"\n",(0,a.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,a.jsxs)(n.h2,{id:"前言",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"}),"前言"]}),"\n",(0,a.jsxs)(n.p,{children:["这是",(0,a.jsx)(n.code,{children:"学习源码整体架构系列"}),"第三篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。文章学习的是打包整合后的代码，不是实际仓库中的拆分的代码。"]}),"\n",(0,a.jsxs)(n.p,{children:["上上篇文章写了",(0,a.jsx)(n.code,{children:"jQuery源码整体架构"}),"，",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5d39d2cbf265da1bc23fbd42",rel:"noopener noreferrer",target:"_blank",children:"学习 jQuery 源码整体架构，打造属于自己的 js 类库"})]}),"\n",(0,a.jsxs)(n.p,{children:["上一篇文章写了",(0,a.jsx)(n.code,{children:"underscore源码整体架构"}),"，",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5d4bf94de51d453bb13b65dc",rel:"noopener noreferrer",target:"_blank",children:"学习 underscore 源码整体架构，打造属于自己的函数式编程类库"})]}),"\n",(0,a.jsx)(n.p,{children:"感兴趣的读者可以点击阅读。"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"underscore"}),"源码分析的文章比较多，而",(0,a.jsx)(n.code,{children:"lodash"}),"源码分析的文章比较少。原因之一可能是由于",(0,a.jsx)(n.code,{children:"lodash"}),"源码行数太多。注释加起来一万多行。"]}),"\n",(0,a.jsxs)(n.p,{children:["分析",(0,a.jsx)(n.code,{children:"lodash"}),"整体代码结构的文章比较少，笔者利用谷歌、必应、",(0,a.jsx)(n.code,{children:"github"}),"等搜索都没有找到，可能是找的方式不对。于是打算自己写一篇。平常开发大多数人都会使用",(0,a.jsx)(n.code,{children:"lodash"}),"，而且都或多或少知道，",(0,a.jsx)(n.code,{children:"lodash"}),"比",(0,a.jsx)(n.code,{children:"underscore"}),"性能好，性能好的主要原因是使用了惰性求值这一特性。"]}),"\n",(0,a.jsxs)(n.p,{children:["本文章学习的",(0,a.jsx)(n.code,{children:"lodash"}),"的版本是：",(0,a.jsx)(n.code,{children:"v4.17.15"}),"。",(0,a.jsx)(n.code,{children:"unpkg.com"}),"地址 ",(0,a.jsx)(n.a,{href:"https://unpkg.com/lodash@4.17.15/lodash.js",rel:"noopener noreferrer",target:"_blank",children:"https://unpkg.com/lodash@4.17.15/lodash.js"})]}),"\n",(0,a.jsx)(n.p,{children:"文章篇幅可能比较长，可以先收藏再看。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"导读："})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["文章主要学习了",(0,a.jsx)(n.code,{children:"runInContext()"})," 导出",(0,a.jsx)(n.code,{children:"_"}),"  ",(0,a.jsx)(n.code,{children:"lodash"}),"函数使用",(0,a.jsx)(n.code,{children:"baseCreate"}),"方法原型继承",(0,a.jsx)(n.code,{children:"LodashWrapper"}),"和",(0,a.jsx)(n.code,{children:"LazyWrapper"}),"，",(0,a.jsx)(n.code,{children:"mixin"}),"挂载方法到",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"、后文用结合例子解释",(0,a.jsx)(n.code,{children:"lodash.prototype.value(wrapperValue)"}),"和",(0,a.jsx)(n.code,{children:"Lazy.prototype.value(lazyValue)"}),"惰性求值的源码具体实现。"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"匿名函数执行",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#匿名函数执行",children:"#"}),"匿名函数执行"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:";(function() {\n\n}.call(this));\n"})}),"\n",(0,a.jsx)(n.p,{children:"暴露 lodash"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"var _ = runInContext();\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"runincontext-函数",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#runincontext-函数",children:"#"}),"runInContext 函数"]}),"\n",(0,a.jsx)(n.p,{children:"这里的简版源码，只关注函数入口和返回值。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"var runInContext = (function runInContext(context) {\n	// 浏览器中处理context为window\n	// ...\n	function lodash(value) {}{\n		// ...\n		return new LodashWrapper(value);\n	}\n	// ...\n	return lodash;\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["可以看到申明了一个",(0,a.jsx)(n.code,{children:"runInContext"}),"函数。里面有一个",(0,a.jsx)(n.code,{children:"lodash"}),"函数，最后处理返回这个",(0,a.jsx)(n.code,{children:"lodash"}),"函数。"]}),"\n",(0,a.jsxs)(n.p,{children:["再看",(0,a.jsx)(n.code,{children:"lodash"}),"函数中的返回值 ",(0,a.jsx)(n.code,{children:"new LodashWrapper(value)"}),"。"]}),"\n",(0,a.jsxs)(n.h3,{id:"lodashwrapper-函数",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lodashwrapper-函数",children:"#"}),"LodashWrapper 函数"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function LodashWrapper(value, chainAll) {\n	this.__wrapped__ = value;\n	this.__actions__ = [];\n	this.__chain__ = !!chainAll;\n	this.__index__ = 0;\n	this.__values__ = undefined;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"设置了这些属性："}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"__wrapped__"}),"：存放参数",(0,a.jsx)(n.code,{children:"value"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"__actions__"}),"：存放待执行的函数体",(0,a.jsx)(n.code,{children:"func"}),"， 函数参数 ",(0,a.jsx)(n.code,{children:"args"}),"，函数执行的",(0,a.jsx)(n.code,{children:"this"})," 指向 ",(0,a.jsx)(n.code,{children:"thisArg"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"__chain__"}),"、",(0,a.jsx)(n.code,{children:"undefined"}),"两次取反转成布尔值",(0,a.jsx)(n.code,{children:"false"}),"，不支持链式调用。和",(0,a.jsx)(n.code,{children:"underscore"}),"一样，默认是不支持链式调用的。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"__index__"}),"：索引值 默认 0。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"__values__"}),"：主要",(0,a.jsx)(n.code,{children:"clone"}),"时使用。"]}),"\n",(0,a.jsxs)(n.p,{children:["接着往下搜索源码，",(0,a.jsx)(n.code,{children:"LodashWrapper"}),"，\n会发现这两行代码。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"LodashWrapper.prototype = baseCreate(baseLodash.prototype);\nLodashWrapper.prototype.constructor = LodashWrapper;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["接着往上找",(0,a.jsx)(n.code,{children:"baseCreate、baseLodash"}),"这两个函数。"]}),"\n",(0,a.jsxs)(n.h3,{id:"basecreate-原型继承",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#basecreate-原型继承",children:"#"}),"baseCreate 原型继承"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"//  立即执行匿名函数\n// 返回一个函数，用于设置原型 可以理解为是 __proto__\nvar baseCreate = (function() {\n	// 这句放在函数外，是为了不用每次调用baseCreate都重复申明 object\n	// underscore 源码中，把这句放在开头就申明了一个空函数 `Ctor`\n	function object() {}\n	return function(proto) {\n		// 如果传入的参数不是object也不是function 是null\n		// 则返回空对象。\n		if (!isObject(proto)) {\n			return {};\n		}\n		// 如果支持Object.create方法，则返回 Object.create\n		if (objectCreate) {\n			// Object.create\n			return objectCreate(proto);\n		}\n		// 如果不支持Object.create 用 ployfill new\n		object.prototype = proto;\n		var result = new object;\n		// 还原 prototype\n		object.prototype = undefined;\n		return result;\n	};\n}());\n\n// 空函数\nfunction baseLodash() {\n	// No operation performed.\n}\n\n// Ensure wrappers are instances of `baseLodash`.\nlodash.prototype = baseLodash.prototype;\n// 为什么会有这一句？因为上一句把lodash.prototype.construtor 设置为Object了。这一句修正constructor\nlodash.prototype.constructor = lodash;\n\nLodashWrapper.prototype = baseCreate(baseLodash.prototype);\nLodashWrapper.prototype.constructor = LodashWrapper;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["笔者画了一张图，表示这个关系。\n",(0,a.jsx)(n.img,{alt:"lodash 原型关系图",src:o})]}),"\n",(0,a.jsxs)(n.h4,{id:"衍生的-isobject-函数",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#衍生的-isobject-函数",children:"#"}),"衍生的 isObject 函数"]}),"\n",(0,a.jsxs)(n.p,{children:["判断",(0,a.jsx)(n.code,{children:"typeof value"}),"不等于",(0,a.jsx)(n.code,{children:"null"}),"，并且是",(0,a.jsx)(n.code,{children:"object"}),"或者",(0,a.jsx)(n.code,{children:"function"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function isObject(value) {\n	var type = typeof value;\n	return value != null && (type == 'object' || type == 'function');\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"objectcreate-用法举例",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectcreate-用法举例",children:"#"}),"Object.create() 用法举例"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"})," 之前这篇文章写过的一段。"]}),"\n",(0,a.jsxs)(n.p,{children:["笔者之前整理的一篇文章中也有讲过，可以翻看",(0,a.jsx)(n.a,{href:"https://segmentfault.com/a/1190000010753942",rel:"noopener noreferrer",target:"_blank",children:"JavaScript 对象所有API解析"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create",rel:"noopener noreferrer",target:"_blank",children:"MDN Object.create()"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Object.create(proto, [propertiesObject])"}),"\n方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是",(0,a.jsx)(n.code,{children:"undefined"}),"）。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"var anotherObject = {\n    name: '若川'\n};\nvar myObject = Object.create(anotherObject, {\n    age: {\n        value：18,\n    },\n});\n// 获得它的原型\nObject.getPrototypeOf(anotherObject) === Object.prototype; // true 说明anotherObject的原型是Object.prototype\nObject.getPrototypeOf(myObject); // {name: \"若川\"} // 说明myObject的原型是{name: \"若川\"}\nmyObject.hasOwnProperty('name'); // false; 说明name是原型上的。\nmyObject.hasOwnProperty('age'); // true 说明age是自身的\nmyObject.name; // '若川'\nmyObject.age; // 18;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["对于不支持",(0,a.jsx)(n.code,{children:"ES5"}),"的浏览器，",(0,a.jsx)(n.code,{children:"MDN"}),"上提供了",(0,a.jsx)(n.code,{children:"ployfill"}),"方案。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"if (typeof Object.create !== \"function\") {\n    Object.create = function (proto, propertiesObject) {\n        if (typeof proto !== 'object' && typeof proto !== 'function') {\n            throw new TypeError('Object prototype may only be an Object: ' + proto);\n        } else if (proto === null) {\n            throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n        }\n\n        if (typeof propertiesObject != 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\");\n\n        function F() {}\n        F.prototype = proto;\n        return new F();\n    };\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"lodash"}),"上有很多方法和属性，但在",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"也有很多与",(0,a.jsx)(n.code,{children:"lodash"}),"上相同的方法。肯定不是在",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"上重新写一遍。而是通过",(0,a.jsx)(n.code,{children:"mixin"}),"挂载的。"]}),"\n",(0,a.jsxs)(n.h2,{id:"mixin",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin",children:"#"}),"mixin"]}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-具体用法",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-具体用法",children:"#"}),"mixin 具体用法"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"_.mixin([object=lodash], source, [options={}])\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"添加来源对象自身的所有可枚举函数属性到目标对象。 如果 object 是个函数，那么函数方法将被添加到原型链上。"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"注意: 使用 _.runInContext 来创建原始的 lodash 函数来避免修改造成的冲突。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"添加版本"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"0.1.0"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"参数"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"[object=lodash] (Function|Object): 目标对象。"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"source (Object): 来源对象。"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"[options={}] (Object): 选项对象。"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"[options.chain=true] (boolean): 是否开启链式操作。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"返回"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"(*): 返回 object."}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-源码",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-源码",children:"#"}),"mixin 源码"]}),"\n",(0,a.jsx)(n.p,{children:"mixin源码，后文注释解析"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function mixin(object, source, options) {\n	var props = keys(source),\n		methodNames = baseFunctions(source, props);\n\n	if (options == null &&\n		!(isObject(source) && (methodNames.length || !props.length))) {\n		options = source;\n		source = object;\n		object = this;\n		methodNames = baseFunctions(source, keys(source));\n	}\n	var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n		isFunc = isFunction(object);\n\n	arrayEach(methodNames, function(methodName) {\n		var func = source[methodName];\n		object[methodName] = func;\n		if (isFunc) {\n			object.prototype[methodName] = function() {\n				var chainAll = this.__chain__;\n				if (chain || chainAll) {\n					var result = object(this.__wrapped__),\n						actions = result.__actions__ = copyArray(this.__actions__);\n\n					actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n					result.__chain__ = chainAll;\n					return result;\n				}\n				return func.apply(object, arrayPush([this.value()], arguments));\n			};\n		}\n	});\n\n	return object;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"接下来先看衍生的函数。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"其实看到具体定义的函数代码就大概知道这个函数的功能。为了不影响主线，导致文章篇幅过长。具体源码在这里就不展开。"})}),"\n",(0,a.jsx)(n.p,{children:"感兴趣的读者可以自行看这些函数衍生的其他函数的源码。"}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-衍生的函数-keys",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-衍生的函数-keys",children:"#"}),"mixin 衍生的函数 keys"]}),"\n",(0,a.jsxs)(n.p,{children:["在 ",(0,a.jsx)(n.code,{children:"mixin"})," 函数中 其实最终调用的就是 ",(0,a.jsx)(n.code,{children:"Object.keys"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function keys(object) {\n	return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-衍生的函数-basefunctions",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-衍生的函数-basefunctions",children:"#"}),"mixin 衍生的函数 baseFunctions"]}),"\n",(0,a.jsx)(n.p,{children:"返回函数数组集合"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function baseFunctions(object, props) {\n	return arrayFilter(props, function(key) {\n		return isFunction(object[key]);\n	});\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-衍生的函数-isfunction",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-衍生的函数-isfunction",children:"#"}),"mixin 衍生的函数 isFunction"]}),"\n",(0,a.jsx)(n.p,{children:"判断参数是否是函数"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function isFunction(value) {\n	if (!isObject(value)) {\n		return false;\n	}\n	// The use of `Object#toString` avoids issues with the `typeof` operator\n	// in Safari 9 which returns 'object' for typed arrays and other constructors.\n	var tag = baseGetTag(value);\n	return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-衍生的函数-arrayeach",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-衍生的函数-arrayeach",children:"#"}),"mixin 衍生的函数 arrayEach"]}),"\n",(0,a.jsx)(n.p,{children:"类似 [].forEarch"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function arrayEach(array, iteratee) {\n	var index = -1,\n		length = array == null ? 0 : array.length;\n\n	while (++index < length) {\n		if (iteratee(array[index], index, array) === false) {\n			break;\n		}\n	}\n	return array;\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-衍生的函数-arraypush",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-衍生的函数-arraypush",children:"#"}),"mixin 衍生的函数 arrayPush"]}),"\n",(0,a.jsx)(n.p,{children:"类似 [].push"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function arrayPush(array, values) {\n	var index = -1,\n		length = values.length,\n		offset = array.length;\n\n	while (++index < length) {\n	array[offset + index] = values[index];\n	}\n	return array;\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-衍生的函数-copyarray",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-衍生的函数-copyarray",children:"#"}),"mixin 衍生的函数 copyArray"]}),"\n",(0,a.jsx)(n.p,{children:"拷贝数组"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function copyArray(source, array) {\n	var index = -1,\n		length = source.length;\n\n	array || (array = Array(length));\n	while (++index < length) {\n		array[index] = source[index];\n	}\n	return array;\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"mixin-源码解析",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-源码解析",children:"#"}),"mixin 源码解析"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"lodash"})," 源码中两次调用 ",(0,a.jsx)(n.code,{children:"mixin"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Add methods that return wrapped values in chain sequences.\nlodash.after = after;\n// code ... 等 153 个支持链式调用的方法\n\n// Add methods to `lodash.prototype`.\n// 把lodash上的静态方法赋值到 lodash.prototype 上\nmixin(lodash, lodash);\n\n// Add methods that return unwrapped values in chain sequences.\nlodash.add = add;\n// code ... 等 152 个不支持链式调用的方法\n\n\n// 这里其实就是过滤 after 等支持链式调用的方法，获取到 lodash 上的 add 等 添加到lodash.prototype 上。\nmixin(lodash, (function() {\n	var source = {};\n	// baseForOwn 这里其实就是遍历lodash上的静态方法，执行回调函数\n	baseForOwn(lodash, function(func, methodName) {\n		// 第一次 mixin 调用了所以赋值到了lodash.prototype\n		// 所以这里用 Object.hasOwnProperty 排除不在lodash.prototype 上的方法。也就是 add 等 152 个不支持链式调用的方法。\n		if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n			source[methodName] = func;\n		}\n	});\n	return source;\n// 最后一个参数options 特意注明不支持链式调用\n}()), { 'chain': false });\n"})}),"\n",(0,a.jsxs)(n.p,{children:["结合两次调用",(0,a.jsx)(n.code,{children:"mixin"})," 代入到源码解析如下\nmixin源码及注释"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function mixin(object, source, options) {\n	// source 对象中可以枚举的属性\n	var props = keys(source),\n		// source 对象中的方法名称数组\n		methodNames = baseFunctions(source, props);\n\n	if (options == null &&\n		!(isObject(source) && (methodNames.length || !props.length))) {\n		// 如果 options 没传为 undefined  undefined == null 为true\n		// 且 如果source 不为 对象或者不是函数\n		// 且 source对象的函数函数长度 或者 source 对象的属性长度不为0\n		// 把 options 赋值为 source\n		options = source;\n		// 把 source 赋值为 object\n		source = object;\n		// 把 object 赋值为 this 也就是 _ (lodash)\n		object = this;\n		// 获取到所有的方法名称数组\n		methodNames = baseFunctions(source, keys(source));\n	}\n	// 是否支持 链式调用\n	// options  不是对象或者不是函数，是null或者其他值\n	// 判断options是否是对象或者函数，如果不是或者函数则不会执行 'chain' in options 也就不会报错\n	//  且 chain 在 options的对象或者原型链中\n	// 知识点 in [MDN in :  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in\n	// 如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。\n\n	// 或者 options.chain 转布尔值\n	var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n		// object 是函数\n		isFunc = isFunction(object);\n\n	// 循环 方法名称数组\n	arrayEach(methodNames, function(methodName) {\n		// 函数本身\n		var func = source[methodName];\n		// object 通常是 lodash  也赋值这个函数。\n		object[methodName] = func;\n		if (isFunc) {\n			// 如果object是函数 赋值到  object prototype  上，通常是lodash\n			object.prototype[methodName] = function() {\n				// 实例上的__chain__ 属性 是否支持链式调用\n				// 这里的 this 是 new LodashWrapper 实例 类似如下\n				/**\n				 {\n					__actions__: [],\n					__chain__: true\n					__index__: 0\n					__values__: undefined\n					__wrapped__: []\n				 }\n				 **/\n\n				var chainAll = this.__chain__;\n				// options 中的 chain 属性 是否支持链式调用\n				// 两者有一个符合链式调用  执行下面的代码\n				if (chain || chainAll) {\n					// 通常是 lodash\n					var result = object(this.__wrapped__),\n					// 复制 实例上的 __action__ 到 result.__action__ 和 action 上\n					actions = result.__actions__ = copyArray(this.__actions__);\n\n					// action 添加 函数 和 args 和 this 指向，延迟计算调用。\n					actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n					//实例上的__chain__ 属性  赋值给 result 的 属性 __chain__\n					result.__chain__ = chainAll;\n					// 最后返回这个实例\n					return result;\n				}\n\n				// 都不支持链式调用。直接调用\n				// 把当前实例的 value 和 arguments 对象 传递给 func 函数作为参数调用。返回调用结果。\n				return func.apply(object, arrayPush([this.value()], arguments));\n			};\n		}\n	});\n\n	// 最后返回对象 object\n	return object;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["小结：简单说就是把",(0,a.jsx)(n.code,{children:"lodash"}),"上的静态方法赋值到",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"上。分两次第一次是支持链式调用（",(0,a.jsx)(n.code,{children:"lodash.after"}),"等 ",(0,a.jsx)(n.code,{children:"153 "}),"个支持链式调用的方法），第二次是不支持链式调用的方法（",(0,a.jsx)(n.code,{children:"lodash.add"}),"等",(0,a.jsx)(n.code,{children:"152"}),"个不支持链式调用的方法）。"]}),"\n",(0,a.jsxs)(n.h2,{id:"lodash-究竟在_和_prototype挂载了多少方法和属性",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lodash-究竟在_和_prototype挂载了多少方法和属性",children:"#"}),"lodash 究竟在_和_.prototype挂载了多少方法和属性"]}),"\n",(0,a.jsxs)(n.p,{children:["再来看下",(0,a.jsx)(n.code,{children:"lodash"}),"究竟挂载在",(0,a.jsx)(n.code,{children:"_"}),"函数对象上有多少静态方法和属性，和挂载",(0,a.jsx)(n.code,{children:"_.prototype"}),"上有多少方法和属性。"]}),"\n",(0,a.jsxs)(n.p,{children:["使用",(0,a.jsx)(n.code,{children:"for in"}),"循环一试便知。看如下代码："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'var staticMethods = [];\nvar staticProperty = [];\nfor(var name in _){\n	if(typeof _[name] === \'function\'){\n		staticMethods.push(name);\n	}\n	else{\n		staticProperty.push(name);\n	}\n}\nconsole.log(staticProperty); // ["templateSettings", "VERSION"] 2个\nconsole.log(staticMethods); // ["after", "ary", "assign", "assignIn", "assignInWith", ...] 305个\n'})}),"\n",(0,a.jsxs)(n.p,{children:["其实就是上文提及的 ",(0,a.jsx)(n.code,{children:"lodash.after"})," 等",(0,a.jsx)(n.code,{children:"153"}),"个支持链式调用的函数 、",(0,a.jsx)(n.code,{children:"lodash.add"})," 等 ",(0,a.jsx)(n.code,{children:"152"}),"不支持链式调用的函数赋值而来。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'var prototypeMethods = [];\nvar prototypeProperty = [];\nfor(var name in _.prototype){\n	if(typeof _.prototype[name] === \'function\'){\n		prototypeMethods.push(name);\n	}\n	else{\n		prototypeProperty.push(name);\n	}\n}\nconsole.log(prototypeProperty); // []\nconsole.log(prototypeMethods); // ["after", "all", "allKeys", "any", "assign", ...] 317个\n'})}),"\n",(0,a.jsxs)(n.p,{children:["相比",(0,a.jsx)(n.code,{children:"lodash"}),"上的静态方法多了",(0,a.jsx)(n.code,{children:"12"}),"个，说明除了 ",(0,a.jsx)(n.code,{children:"mixin"})," 外，还有",(0,a.jsx)(n.code,{children:"12"}),"个其他形式赋值而来。"]}),"\n",(0,a.jsxs)(n.p,{children:["支持链式调用的方法最后返回是实例对象，获取最后的处理的结果值，最后需要调用",(0,a.jsx)(n.code,{children:"value"}),"方法。"]}),"\n",(0,a.jsxs)(n.p,{children:["笔者画了一张表示",(0,a.jsx)(n.code,{children:"lodash"}),"的方法和属性挂载关系图。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"lodash的方法和属性挂载关系图",src:i})}),"\n",(0,a.jsxs)(n.h2,{id:"请出贯穿下文的简单的例子",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#请出贯穿下文的简单的例子",children:"#"}),"请出贯穿下文的简单的例子"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"var result = _.chain([1, 2, 3, 4, 5])\n.map(el => {\n	console.log(el); // 1, 2, 3\n	return el + 1;\n})\n.take(3)\n.value();\n// lodash中这里的`map`仅执行了`3`次。\n// 具体功能也很简单 数组 1-5 加一，最后获取其中三个值。\nconsole.log('result:', result);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["也就是说这里",(0,a.jsx)(n.code,{children:"lodash"}),"聪明的知道了最后需要几个值，就执行几次",(0,a.jsx)(n.code,{children:"map"}),"循环，对于很大的数组，提升性能很有帮助。"]}),"\n而",(0,a.jsx)(n.code,{children:"underscore"}),"执行这段代码其中",(0,a.jsx)(n.code,{children:"map"}),"执行了5次。\n如果是平常实现该功能也简单。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"var result = [1, 2, 3, 4, 5].map(el => el + 1).slice(0, 3);\nconsole.log('result:', result);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["而相比",(0,a.jsx)(n.code,{children:"lodash"}),"这里的",(0,a.jsx)(n.code,{children:"map"}),"执行了",(0,a.jsx)(n.code,{children:"5"}),"次。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// 不使用 map、slice\nvar result = [];\nvar arr = [1, 2, 3, 4, 5];\nfor (var i = 0; i < 3; i++){\n	result[i] = arr[i] + 1;\n}\nconsole.log(result, 'result');\n"})}),"\n",(0,a.jsxs)(n.p,{children:["简单说这里的",(0,a.jsx)(n.code,{children:"map"}),"方法，添加 ",(0,a.jsx)(n.code,{children:"LazyWrapper"})," 的方法到 ",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"存储下来，最后调用 ",(0,a.jsx)(n.code,{children:"value"}),"时再调用。\n具体看下文源码实现。"]}),"\n",(0,a.jsxs)(n.h2,{id:"添加lazywrapper-的方法到lodashprototype",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加lazywrapper-的方法到lodashprototype",children:"#"}),"添加",(0,a.jsx)(n.code,{children:"LazyWrapper"})," 的方法到",(0,a.jsx)(n.code,{children:"lodash.prototype"})]}),"\n",(0,a.jsxs)(n.p,{children:["主要是如下方法添加到到 ",(0,a.jsx)(n.code,{children:"lodash.prototype"})," 原型上。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'// "constructor"\n["drop", "dropRight", "take", "takeRight", "filter", "map", "takeWhile", "head", "last", "initial", "tail", "compact", "find", "findLast", "invokeMap", "reject", "slice", "takeRightWhile", "toArray", "clone", "reverse", "value"]\n'})}),"\n",(0,a.jsx)(n.p,{children:"具体源码及注释"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Add `LazyWrapper` methods to `lodash.prototype`.\n// baseForOwn 这里其实就是遍历LazyWrapper.prototype上的方法，执行回调函数\nbaseForOwn(LazyWrapper.prototype, function(func, methodName) {\n	// 检测函数名称是否是迭代器也就是循环\n	var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n		// 检测函数名称是否head和last\n		// 顺便提一下 ()这个是捕获分组 而加上 ?:  则是非捕获分组 也就是说不用于其他操作\n		isTaker = /^(?:head|last)$/.test(methodName),\n		// lodashFunc 是 根据 isTaker 组合 takeRight take methodName\n		lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n		// 根据isTaker 和 是 find 判断结果是否 包装\n		retUnwrapped = isTaker || /^find/.test(methodName);\n\n	// 如果不存在这个函数，就不往下执行\n	if (!lodashFunc) {\n		return;\n	}\n	// 把 lodash.prototype 方法赋值到lodash.prototype\n	lodash.prototype[methodName] = function() {\n		// 取实例中的__wrapped__ 值 例子中则是 [1,2,3,4,5]\n		var value = this.__wrapped__,\n			// 如果是head和last 方法 isTaker 返回 [1], 否则是arguments对象\n			args = isTaker ? [1] : arguments,\n			// 如果value 是LayeWrapper的实例\n			isLazy = value instanceof LazyWrapper,\n			// 迭代器 循环\n			iteratee = args[0],\n			// 使用useLazy isLazy value或者是数组\n			useLazy = isLazy || isArray(value);\n\n		var interceptor = function(value) {\n			// 函数执行 value args 组合成数组参数\n			var result = lodashFunc.apply(lodash, arrayPush([value], args));\n			// 如果是 head 和 last (isTaker) 支持链式调用 返回结果的第一个参数 否则 返回result\n			return (isTaker && chainAll) ? result[0] : result;\n		};\n\n		// useLazy true 并且 函数checkIteratee 且迭代器是函数，且迭代器参数个数不等于1\n		if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n			// Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n			// useLazy 赋值为 false\n			// isLazy 赋值为 false\n			isLazy = useLazy = false;\n		}\n		// 取实例上的 __chain__\n		var chainAll = this.__chain__,\n			// 存储的待执行的函数 __actions__ 二次取反是布尔值 也就是等于0或者大于0两种结果\n			isHybrid = !!this.__actions__.length,\n			// 是否不包装 用结果是否不包装 且 不支持链式调用\n			isUnwrapped = retUnwrapped && !chainAll,\n			// 是否仅Lazy 用isLazy 和 存储的函数\n			onlyLazy = isLazy && !isHybrid;\n\n		// 结果不包装 且 useLazy 为 true\n		if (!retUnwrapped && useLazy) {\n			// 实例 new LazyWrapper 这里的this 是 new LodashWrapper()\n			value = onlyLazy ? value : new LazyWrapper(this);\n			// result 执行函数结果\n			var result = func.apply(value, args);\n\n			/*\n			*\n			// _.thru(value, interceptor)\n			// 这个方法类似 _.tap， 除了它返回 interceptor 的返回结果。该方法的目的是\"传递\" 值到一个方法链序列以取代中间结果。\n			_([1, 2, 3])\n			.tap(function(array) {\n				// 改变传入的数组\n				array.pop();\n			})\n			.reverse()\n			.value();\n			// => [2, 1]\n			*/\n\n			// thisArg 指向undefined 或者null 非严格模式下是指向window，严格模式是undefined 或者nll\n			result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n			// 返回实例 lodashWrapper\n			return new LodashWrapper(result, chainAll);\n		}\n		// 不包装 且 onlyLazy 为 true\n		if (isUnwrapped && onlyLazy) {\n			// 执行函数\n			return func.apply(this, args);\n		}\n		// 上面都没有执行，执行到这里了\n		// 执行 thru 函数，回调函数 是 interceptor\n		result = this.thru(interceptor);\n		return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n	};\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["小结一下，写了这么多注释，简单说：其实就是用",(0,a.jsx)(n.code,{children:"LazyWrapper.prototype"})," 改写原先在",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"的函数，判断函数是否需要使用惰性求值，需要时再调用。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"读者可以断点调试一下，善用断点进入函数功能，对着注释看，可能会更加清晰。"})}),"\n",(0,a.jsx)(n.p,{children:"断点调试的部分截图"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"例子的chain和map执行后的debugger截图",src:c}),"\n",(0,a.jsx)(n.img,{alt:"例子的chain和map执行后的结果截图",src:d})]}),"\n",(0,a.jsxs)(n.p,{children:["链式调用最后都是返回实例对象，实际的处理数据的函数都没有调用，而是被存储存储下来了，最后调用",(0,a.jsx)(n.code,{children:"value"}),"方法，才执行这些函数。"]}),"\n",(0,a.jsxs)(n.h2,{id:"lodashprototypevalue-即-wrappervalue",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lodashprototypevalue-即-wrappervalue",children:"#"}),"lodash.prototype.value 即 wrapperValue"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function baseWrapperValue(value, actions) {\n	var result = value;\n	// 如果是lazyWrapper的实例，则调用LazyWrapper.prototype.value 方法，也就是 lazyValue 方法\n	if (result instanceof LazyWrapper) {\n		result = result.value();\n	}\n	// 类似 [].reduce()，把上一个函数返回结果作为参数传递给下一个函数\n	return arrayReduce(actions, function(result, action) {\n		return action.func.apply(action.thisArg, arrayPush([result], action.args));\n	}, result);\n}\nfunction wrapperValue() {\n	return baseWrapperValue(this.__wrapped__, this.__actions__);\n}\nlodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["如果是惰性求值，则调用的是 ",(0,a.jsx)(n.code,{children:"LazyWrapper.prototype.value"})," 即 ",(0,a.jsx)(n.code,{children:"lazyValue"}),"。"]}),"\n",(0,a.jsxs)(n.h2,{id:"lazywrapperprototypevalue-即-lazyvalue-惰性求值",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lazywrapperprototypevalue-即-lazyvalue-惰性求值",children:"#"}),"LazyWrapper.prototype.value 即 lazyValue 惰性求值"]}),"\n",(0,a.jsx)(n.p,{children:"lazyValue源码及注释"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function LazyWrapper(value) {\n	// 参数 value\n	this.__wrapped__ = value;\n	// 执行的函数\n	this.__actions__ = [];\n	this.__dir__ = 1;\n	// 过滤\n	this.__filtered__ = false;\n	// 存储迭代器函数\n	this.__iteratees__ = [];\n	// 默认最大取值个数\n	this.__takeCount__ = MAX_ARRAY_LENGTH;\n	// 具体取值多少个，存储函数和类型\n	this.__views__ = [];\n}\n/**\n* Extracts the unwrapped value from its lazy wrapper.\n*\n* @private\n* @name value\n* @memberOf LazyWrapper\n* @returns {*} Returns the unwrapped value.\n*/\nfunction lazyValue() {\n	// this.__wrapped__ 是 new LodashWrapper 实例 所以执行.value 获取原始值\n	var array = this.__wrapped__.value(),\n		//\n		dir = this.__dir__,\n		// 是否是函数\n		isArr = isArray(array),\n		// 是否从右边开始\n		isRight = dir < 0,\n		// 数组的长度。如果不是数组，则是0\n		arrLength = isArr ? array.length : 0,\n		// 获取 take(3) 上述例子中 则是 start: 0，end: 3\n		view = getView(0, arrLength, this.__views__),\n		start = view.start,\n		end = view.end,\n		// 长度 3\n		length = end - start,\n		// 如果是是从右开始\n		index = isRight ? end : (start - 1),\n		// 存储的迭代器数组\n		iteratees = this.__iteratees__,\n		// 迭代器数组长度\n		iterLength = iteratees.length,\n		// 结果resIndex\n		resIndex = 0,\n		// 最后获取几个值，也就是 3\n		takeCount = nativeMin(length, this.__takeCount__);\n\n	// 如果不是数组，或者 不是从右开始 并且 参数数组长度等于take的长度 takeCount等于长度\n	// 则直接调用 baseWrapperValue 不需要\n	if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n		return baseWrapperValue(array, this.__actions__);\n	}\n	var result = [];\n\n	// 标签语句 label\n	// MDN label 链接\n	// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label\n	// 标记语句可以和 break 或 continue 语句一起使用。标记就是在一条语句前面加个可以引用的标识符（identifier）。\n	outer:\n	while (length-- && resIndex < takeCount) {\n		index += dir;\n\n		var iterIndex = -1,\n			// 数组第一项\n			value = array[index];\n\n		while (++iterIndex < iterLength) {\n			// 迭代器数组 {iteratee: function{}, typy: 2}\n			var data = iteratees[iterIndex],\n				iteratee = data.iteratee,\n				type = data.type,\n				// 结果 迭代器执行结果\n				computed = iteratee(value);\n\n			if (type == LAZY_MAP_FLAG) {\n				// 如果 type 是 map 类型，结果 computed 赋值给value\n				value = computed;\n			} else if (!computed) {\n				if (type == LAZY_FILTER_FLAG) {\n					// 退出当前这次循环，进行下一次循环\n					continue outer;\n				} else {\n					// 退出整个循环\n					break outer;\n				}\n			}\n		}\n		// 最终数组\n		result[resIndex++] = value;\n	}\n	// 返回数组 例子中则是 [2, 3, 4]\n	return result;\n}\n// Ensure `LazyWrapper` is an instance of `baseLodash`.\nLazyWrapper.prototype = baseCreate(baseLodash.prototype);\nLazyWrapper.prototype.constructor = LazyWrapper;\n\nLazyWrapper.prototype.value = lazyValue;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["笔者画了一张 ",(0,a.jsx)(n.code,{children:"lodash"}),"和",(0,a.jsx)(n.code,{children:"LazyWrapper"}),"的关系图来表示。\n",(0,a.jsx)(n.img,{alt:"lodash和LazyWrapper的关系图",src:l})]}),"\n",(0,a.jsxs)(n.p,{children:["小结：",(0,a.jsx)(n.code,{children:"lazyValue"}),"简单说实现的功能就是把之前记录的需要执行几次，把记录存储的函数执行几次，不会有多少项数据就执行多少次，而是根据需要几项，执行几项。\n也就是说以下这个例子中，",(0,a.jsx)(n.code,{children:"map"}),"函数只会执行",(0,a.jsx)(n.code,{children:"3"}),"次。如果没有用惰性求值，那么",(0,a.jsx)(n.code,{children:"map"}),"函数会执行",(0,a.jsx)(n.code,{children:"5"}),"次。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"var result = _.chain([1, 2, 3, 4, 5])\n.map(el => el + 1)\n.take(3)\n.value();\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,a.jsx)(n.p,{children:"行文至此，基本接近尾声，最后总结一下。"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["文章主要学习了",(0,a.jsx)(n.code,{children:"runInContext()"})," 导出",(0,a.jsx)(n.code,{children:"_"}),"  ",(0,a.jsx)(n.code,{children:"lodash"}),"函数使用",(0,a.jsx)(n.code,{children:"baseCreate"}),"方法原型继承",(0,a.jsx)(n.code,{children:"LodashWrapper"}),"和",(0,a.jsx)(n.code,{children:"LazyWrapper"}),"，",(0,a.jsx)(n.code,{children:"mixin"}),"挂载方法到",(0,a.jsx)(n.code,{children:"lodash.prototype"}),"、后文用结合例子解释",(0,a.jsx)(n.code,{children:"lodash.prototype.value(wrapperValue)"}),"和",(0,a.jsx)(n.code,{children:"Lazy.prototype.value(lazyValue)"}),"惰性求值的源码具体实现。"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["分享一个只知道函数名找源码定位函数申明位置的",(0,a.jsx)(n.code,{children:"VSCode"})," 技巧"]}),"：",(0,a.jsx)(n.code,{children:"Ctrl + p"}),"。输入 ",(0,a.jsx)(n.code,{children:"@functionName"})," 定位函数",(0,a.jsx)(n.code,{children:"functionName"}),"在源码文件中的具体位置。如果知道调用位置，那直接按",(0,a.jsx)(n.code,{children:"alt+鼠标左键"}),"即可跳转到函数申明的位置。"]}),"\n",(0,a.jsx)(n.p,{children:"如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持。万分感谢。"}),"\n",(0,a.jsxs)(n.h2,{id:"推荐阅读",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#推荐阅读",children:"#"}),"推荐阅读"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/lodash/lodash",rel:"noopener noreferrer",target:"_blank",children:"lodash github仓库"}),"\n",(0,a.jsx)(n.a,{href:"https://lodash.com/docs/4.17.15",rel:"noopener noreferrer",target:"_blank",children:"lodash 官方文档"}),"\n",(0,a.jsx)(n.a,{href:"https://lodashjs.com/",rel:"noopener noreferrer",target:"_blank",children:"lodash 中文文档"}),"\n",(0,a.jsx)(n.a,{href:"http://blog.zollty.com/b/archive/create-a-front-end-tool-library.html",rel:"noopener noreferrer",target:"_blank",children:"打造一个类似于lodash的前端工具库"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5b784baf51882542ed141a84",rel:"noopener noreferrer",target:"_blank",children:"惰性求值——lodash源码解读"}),"\n",(0,a.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/24138694",rel:"noopener noreferrer",target:"_blank",children:"luobo tang：lazy.js 惰性求值实现分析"}),"\n",(0,a.jsx)(n.a,{href:"https://github.com/dtao/lazy.js",rel:"noopener noreferrer",target:"_blank",children:"lazy.js github 仓库"}),"\n",(0,a.jsxs)(n.a,{href:"https://unpkg.com/lodash@4.17.15/lodash.js",rel:"noopener noreferrer",target:"_blank",children:["本文章学习的",(0,a.jsx)(n.code,{children:"lodash"}),"的版本",(0,a.jsx)(n.code,{children:"v4.17.15"})," ",(0,a.jsx)(n.code,{children:"unpkg.com"}),"链接"]})]}),"\n",(0,a.jsxs)(n.h2,{id:"笔者往期文章",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔者往期文章",children:"#"}),"笔者往期文章"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://juejin.im/post/5d4bf94de51d453bb13b65dc",rel:"noopener noreferrer",target:"_blank",children:"学习 underscore 源码整体架构，打造属于自己的函数式编程类库"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5d39d2cbf265da1bc23fbd42",rel:"noopener noreferrer",target:"_blank",children:"学习 jQuery 源码整体架构，打造属于自己的 js 类库"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5c433e216fb9a049c15f841b",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的继承"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5c0c87b35188252e8966c78a",rel:"noopener noreferrer",target:"_blank",children:"面试官问：JS的this指向"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5bf6c79bf265da6142738b29",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的call和apply方法"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5bec4183f265da616b1044d7",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的bind方法"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5bde7c926fb9a049f66b8b52",rel:"noopener noreferrer",target:"_blank",children:"面试官问：能否模拟实现JS的new操作符"}),"\n",(0,a.jsx)(n.a,{href:"https://juejin.im/post/5b86732451882542af1c8082",rel:"noopener noreferrer",target:"_blank",children:"前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并"})]}),"\n",(0,a.jsxs)(n.h2,{id:"关于",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于",children:"#"}),"关于"]}),"\n",(0,a.jsxs)(n.p,{children:["作者：常以",(0,a.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。","\n",(0,a.jsx)(n.a,{href:"https://ruochuan12.github.io/",rel:"noopener noreferrer",target:"_blank",children:"个人博客-若川"}),"，使用",(0,a.jsx)(n.code,{children:"vuepress"}),"重构了，阅读体验可能更好些","\n",(0,a.jsx)(n.a,{href:"https://juejin.im/user/1415826704971918/posts",rel:"noopener noreferrer",target:"_blank",children:"掘金专栏"}),"，欢迎关注~","\n",(0,a.jsxs)(n.a,{href:"https://segmentfault.com/blog/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:[(0,a.jsx)(n.code,{children:"segmentfault"}),"前端视野专栏"]}),"，欢迎关注~","\n",(0,a.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/lxchuan12",rel:"noopener noreferrer",target:"_blank",children:"知乎前端视野专栏"}),"，欢迎关注~","\n",(0,a.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，相关源码和资源都放在这里，求个",(0,a.jsx)(n.code,{children:"star"}),"^_^~"]}),"\n",(0,a.jsxs)(n.h2,{id:"微信公众号--若川视野",children:[(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微信公众号--若川视野",children:"#"}),"微信公众号  若川视野"]}),"\n",(0,a.jsxs)(n.p,{children:["可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ",(0,a.jsx)(n.code,{children:"ruochuan12"}),"，注明来源，拉您进【前端视野交流群】。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"若川视野",src:h})})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(p,e)})):p(e)}let j=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["lodash%2FREADME.all.md"]={toc:[{id:"前言",text:"前言",depth:2},{id:"匿名函数执行",text:"匿名函数执行",depth:2},{id:"runincontext-函数",text:"runInContext 函数",depth:2},{id:"lodashwrapper-函数",text:"LodashWrapper 函数",depth:3},{id:"basecreate-原型继承",text:"baseCreate 原型继承",depth:3},{id:"衍生的-isobject-函数",text:"衍生的 isObject 函数",depth:4},{id:"objectcreate-用法举例",text:"Object.create() 用法举例",depth:3},{id:"mixin",text:"mixin",depth:2},{id:"mixin-具体用法",text:"mixin 具体用法",depth:3},{id:"mixin-源码",text:"mixin 源码",depth:3},{id:"mixin-衍生的函数-keys",text:"mixin 衍生的函数 keys",depth:3},{id:"mixin-衍生的函数-basefunctions",text:"mixin 衍生的函数 baseFunctions",depth:3},{id:"mixin-衍生的函数-isfunction",text:"mixin 衍生的函数 isFunction",depth:3},{id:"mixin-衍生的函数-arrayeach",text:"mixin 衍生的函数 arrayEach",depth:3},{id:"mixin-衍生的函数-arraypush",text:"mixin 衍生的函数 arrayPush",depth:3},{id:"mixin-衍生的函数-copyarray",text:"mixin 衍生的函数 copyArray",depth:3},{id:"mixin-源码解析",text:"mixin 源码解析",depth:3},{id:"lodash-究竟在_和_prototype挂载了多少方法和属性",text:"lodash 究竟在_和_.prototype挂载了多少方法和属性",depth:2},{id:"请出贯穿下文的简单的例子",text:"请出贯穿下文的简单的例子",depth:2},{id:"添加lazywrapper-的方法到lodashprototype",text:"添加`LazyWrapper` 的方法到`lodash.prototype`",depth:2},{id:"lodashprototypevalue-即-wrappervalue",text:"lodash.prototype.value 即 wrapperValue",depth:2},{id:"lazywrapperprototypevalue-即-lazyvalue-惰性求值",text:"LazyWrapper.prototype.value 即 lazyValue 惰性求值",depth:2},{id:"总结",text:"总结",depth:2},{id:"推荐阅读",text:"推荐阅读",depth:2},{id:"笔者往期文章",text:"笔者往期文章",depth:2},{id:"关于",text:"关于",depth:2},{id:"微信公众号--若川视野",text:"微信公众号  若川视野",depth:2}],title:"学习 lodash  源码整体架构，打造属于自己的函数式编程类库",headingTitle:"学习 lodash  源码整体架构，打造属于自己的函数式编程类库",frontmatter:{}}},20713:function(e,n,r){r.d(n,{Z:()=>c});var a=r(52676),s=r(75271),t=r(92815);r(18544);let o={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function i(e,n,r){let a=Object.keys(o).includes(n)?n:r;return o[a](e)}let c=e=>{let{defaultLocale:n="en-US"}=e,r=(0,t.Vi)().page.readingTimeData,o=(0,t.Jr)(),c=(0,t.e7)(),[d,l]=(0,s.useState)(i(r,o,n));return(0,s.useEffect)(()=>{l(i(r,o,n))},[o,r]),(0,a.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:d})}}}]);