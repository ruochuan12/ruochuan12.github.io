"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([["3584"],{40632:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var s=t(52676),r=t(40453),a=t(20713);let c=t.p+"static/image/events-debugger.b396f0ce.png",o=t.p+"static/svg/callbacks.ab9e24a4.svg";function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",input:"input",pre:"pre",h3:"h3",blockquote:"blockquote",strong:"strong",img:"img",hr:"hr"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"taro-源码揭秘5高手都在用的发布订阅机制-events-在-taro-中是如何实现的",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#taro-源码揭秘5高手都在用的发布订阅机制-events-在-taro-中是如何实现的",children:"#"}),"Taro 源码揭秘：5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"]}),"\n",(0,s.jsx)(a.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"}),"1. 前言"]}),"\n",(0,s.jsxs)(n.p,{children:["大家好，我是",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]}),"\n",(0,s.jsxs)(n.p,{children:["截至目前（",(0,s.jsx)(n.code,{children:"2024-08-18"}),"），",(0,s.jsxs)(n.a,{href:"https://github.com/NervJS/taro/releases/tag/v4.0.3",rel:"noopener noreferrer",target:"_blank",children:[(0,s.jsx)(n.code,{children:"taro 4.0"})," 正式版已经发布"]}),"，目前最新是 ",(0,s.jsx)(n.code,{children:"4.0.4"}),"，官方",(0,s.jsx)(n.code,{children:"4.0"}),"正式版本的介绍文章暂未发布。官方之前发过",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7330792655125463067",rel:"noopener noreferrer",target:"_blank",children:"Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["计划写一个 Taro 源码揭秘系列，博客地址：",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io/taro",rel:"noopener noreferrer",target:"_blank",children:"https://ruochuan12.github.io/taro"})," 可以加入书签，持续关注",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"若川"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7378363694939783178",rel:"noopener noreferrer",target:"_blank",children:"1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7380195796208205824",rel:"noopener noreferrer",target:"_blank",children:"2. 揭开整个架构的插件系统的秘密"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7390335741586931738",rel:"noopener noreferrer",target:"_blank",children:"3. 每次创建新的 taro 项目（taro init）的背后原理是什么"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403193330271682612",rel:"noopener noreferrer",target:"_blank",children:"4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7403915119448915977",rel:"noopener noreferrer",target:"_blank",children:"5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7407648740926291968",rel:"noopener noreferrer",target:"_blank",children:"6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7415911762128797696",rel:"noopener noreferrer",target:"_blank",children:"7. Taro.request 和请求响应拦截器是如何实现的"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7434175547784020031",rel:"noopener noreferrer",target:"_blank",children:"8. Taro 是如何使用 webpack 打包构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7439743635161710604",rel:"noopener noreferrer",target:"_blank",children:"9. Taro 是如何生成 webpack 配置进行构建小程序的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7452329275561279529",rel:"noopener noreferrer",target:"_blank",children:"10. Taro 到底是怎样转换成小程序文件的？"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","等等"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。第 5 篇我们来讲些相对简单的，Taro 是如何实现发布订阅机制 Events 的。"}),"\n",(0,s.jsx)(n.p,{children:"学完本文，你将学到："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"1. 了解发布订阅机制\n2. 了解 taro 一些 npm 包的作用，寻找到 Events 源码\n3. Taro 源码中发布订阅机制 Events 是如何实现的\n等等\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"2-taro-消息机制",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-taro-消息机制",children:"#"}),"2. Taro 消息机制"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://taro-docs.jd.com/docs/next/apis/about/events",rel:"noopener noreferrer",target:"_blank",children:"Taro 消息机制"}),"文档上，",(0,s.jsx)(n.code,{children:"Taro"})," 提供了消息机制 ",(0,s.jsx)(n.code,{children:"Events"}),"，用来实现组件间通信。我们来学习下如何实现的。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Taro"})," 提供了 ",(0,s.jsx)(n.code,{children:"Taro.Events"})," 来实现消息机制，使用时需要实例化它，如下"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import Taro, { Events } from '@tarojs/taro'\n\nconst events = new Events()\n\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) => {\n  // doSth\n})\n\n// 监听同个事件，同时绑定多个 handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n\n// 取消监听一个事件\nevents.off('eventName')\n\n// 取消监听一个事件某个 handler\nevents.off('eventName', handler1)\n\n// 取消监听所有事件\nevents.off()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同时 ",(0,s.jsx)(n.code,{children:"Taro"})," 还提供了一个全局消息中心 ",(0,s.jsx)(n.code,{children:"Taro.eventCenter"})," 以供使用，它是 ",(0,s.jsx)(n.code,{children:"Taro.Events"})," 的实例"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Vue2"})," 中也有类似的事件 ",(0,s.jsx)(n.code,{children:"events api"})," ",(0,s.jsx)(n.code,{children:"$on"}),"、",(0,s.jsx)(n.code,{children:"$off"}),"、",(0,s.jsx)(n.code,{children:"$once"}),"、",(0,s.jsx)(n.code,{children:"$emit"}),"，不过 ",(0,s.jsx)(n.code,{children:"Vue3"})," 移除了。\n",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vue/blob/main/src/core/instance/events.ts",rel:"noopener noreferrer",target:"_blank",children:"vue2 events"})]}),"\n",(0,s.jsxs)(n.p,{children:["也有一些 ",(0,s.jsx)(n.code,{children:"npm"})," 包，如：",(0,s.jsx)(n.a,{href:"https://github.com/developit/mitt/blob/main/src/index.ts",rel:"noopener noreferrer",target:"_blank",children:"mitt"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/scottcorgan/tiny-emitter/blob/master/index.js",rel:"noopener noreferrer",target:"_blank",children:"tiny-emitter"})]}),"\n",(0,s.jsxs)(n.p,{children:["源码共读也有一期",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7084984303943155719",rel:"noopener noreferrer",target:"_blank",children:"第8期 | mitt、tiny-emitter 发布订阅"})]}),"\n",(0,s.jsxs)(n.h2,{id:"3-根据文档使用实现-events",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-根据文档使用实现-events",children:"#"}),"3. 根据文档使用实现 Events"]}),"\n",(0,s.jsx)(n.p,{children:"文档中，主要有如下几个需求点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"监听同个事件，同时绑定多个 handler"}),"\n",(0,s.jsx)(n.li,{children:"触发事件，传入多个参数"}),"\n",(0,s.jsx)(n.li,{children:"取消监听一个事件某个 handler"}),"\n",(0,s.jsx)(n.li,{children:"取消监听所有事件"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以先自行实现一个符合要求的 ",(0,s.jsx)(n.code,{children:"Events"})," 类，然后再去 ",(0,s.jsx)(n.code,{children:"Taro"})," 源码中寻找实现，最后可以对比各自的实现优缺点。"]}),"\n",(0,s.jsxs)(n.h3,{id:"31-初步实现-events",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-初步实现-events",children:"#"}),"3.1 初步实现 Events"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Events {\n	constructor(){\n        this.callbacks = [];\n    }\n	on(eventName, callback){\n        this.callbacks.push({\n            eventName,\n            callback,\n        });\n    }\n	off(){}\n	trigger(){}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们用 ",(0,s.jsx)(n.code,{children:"callbacks"})," 数组来存储事件，",(0,s.jsx)(n.code,{children:"push"})," 方法用来添加事件，支持多个同名的 ",(0,s.jsx)(n.code,{children:"eventName"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"32-off-方法实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-off-方法实现",children:"#"}),"3.2 off 方法实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"off(eventName, callback){\n	this.callbacks = this.callbacks.filter((item) => {\n		if(typeof eventName === 'string'){\n			if(typeof callback === 'function'){\n				return !(item.eventName === eventName && item.callback === callback);\n			}\n			return item.eventName !== eventName;\n		}\n		return false;\n	});\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"off"})," 方法用来取消监听事件，如果传入 ",(0,s.jsx)(n.code,{children:"eventName"})," 参数，则取消监听该事件，如果还传入了特定的 ",(0,s.jsx)(n.code,{children:"handler"}),"，则只取消监听这个 ",(0,s.jsx)(n.code,{children:"handler"}),"。否则取消所有事件。"]}),"\n",(0,s.jsxs)(n.h3,{id:"33-trigger-方法实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-trigger-方法实现",children:"#"}),"3.3 trigger 方法实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"trigger(eventName, ...args){\n	this.callbacks.forEach((item) => {\n		if(item.eventName === eventName){\n			item.callback(...args);\n		}\n	});\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"trigger"})," 传入 ",(0,s.jsx)(n.code,{children:"eventName"})," 和参数，遍历所有事件，如果 ",(0,s.jsx)(n.code,{children:"eventName"})," 匹配，则执行 ",(0,s.jsx)(n.code,{children:"handler"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://code.juejin.cn/pen/7404393720948195354",rel:"noopener noreferrer",target:"_blank",children:"Taro events 自行实现所有代码 demo，可打开调试运行"})}),"\n",(0,s.jsxs)(n.h2,{id:"4-在茫茫源码中寻找-class-events-实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-在茫茫源码中寻找-class-events-实现",children:"#"}),"4. 在茫茫源码中寻找 class Events 实现"]}),"\n",(0,s.jsx)(n.p,{children:"文档示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import Taro, { Events } from '@tarojs/taro'\n\nconst events = new Events()\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@tarojs/taro"})," 对应的源码路径是 ",(0,s.jsx)(n.code,{children:"taro/packages/taro"})]}),"\n",(0,s.jsxs)(n.h3,{id:"41-tarojstaro-暴露者开发者的-taro-核心-api",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-tarojstaro-暴露者开发者的-taro-核心-api",children:"#"}),"4.1 @tarojs/taro 暴露者开发者的 Taro 核心 API"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["暴露给应用开发者的 Taro 核心 API。包含以下小程序端入口文件 ",(0,s.jsx)(n.code,{children:"index.js"})," 等。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { hooks } = require('@tarojs/runtime')\nconst taro = require('@tarojs/api').default\n\nif (hooks.isExist('initNativeApi')) {\n  hooks.call('initNativeApi', taro)\n}\n\nmodule.exports = taro\nmodule.exports.default = module.exports\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@tarojs/api"})," 对应的源码路径是 ",(0,s.jsx)(n.code,{children:"taro/packages/taro-api"})]}),"\n",(0,s.jsxs)(n.h3,{id:"42-tarojsapi-所有端的公有-api",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-tarojsapi-所有端的公有-api",children:"#"}),"4.2 @tarojs/api 所有端的公有 API"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["暴露给 @tarojs/taro 的所有端的公有 API。",(0,s.jsx)(n.code,{children:"@tarojs/api"})," 会跨 node/浏览器/小程序/React Native 使用，不得使用/包含平台特有特性。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["入口文件：",(0,s.jsx)(n.code,{children:"packages/taro-api/src/index.ts"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// packages/taro-api/src/index.ts\n/* eslint-disable camelcase */\nimport { Current, eventCenter, Events, getCurrentInstance, nextTick, options } from '@tarojs/runtime'\n\n// 省略若干代码\n\nconst Taro: Record<string, unknown> = {\n  // 省略若干代码\n  Current, getCurrentInstance, options, nextTick, eventCenter, Events,\n}\n\n// 省略若干代码\n\nexport default Taro\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个文件代码不多，省略了一部分。默认导出",(0,s.jsx)(n.code,{children:"Taro"}),"，其中 ",(0,s.jsx)(n.code,{children:"eventCenter,Events"}),"是从 ",(0,s.jsx)(n.code,{children:"@tarojs/runtime"})," 引入的。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@tarojs/runtime"})," 对应的源码路径是 ",(0,s.jsx)(n.code,{children:"taro/packages/taro-runtime"})]}),"\n",(0,s.jsxs)(n.h3,{id:"43-tarojsruntime-taro-运行时",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-tarojsruntime-taro-运行时",children:"#"}),"4.3 @tarojs/runtime Taro 运行时"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Taro 运行时。在小程序端连接框架（DSL）渲染机制到小程序渲染机制，连接小程序路由和生命周期到框架对应的生命周期。在 H5/RN 端连接小程序生命周期",(0,s.jsx)(n.strong,{children:"规范"}),"到框架生命周期。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Events ",(0,s.jsx)(n.a,{href:"https://nervjs.github.io/taro/docs/apis/about/events.html#docsNav",rel:"noopener noreferrer",target:"_blank",children:"Taro 消息机制"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-runtime/src/index.ts\nexport * from './emitter/emitter'\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-runtime/src/emitter/emitter.ts\nimport { Events, hooks } from '@tarojs/shared'\n\nconst eventCenter = hooks.call('getEventCenter', Events)!\n\nexport type EventsType = typeof Events\nexport { eventCenter, Events }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@tarojs/shared"})," 对应的源码路径是 ",(0,s.jsx)(n.code,{children:"taro/packages/shared"})]}),"\n",(0,s.jsxs)(n.h3,{id:"44-tarojsshared-内部使用的-utils",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#44-tarojsshared-内部使用的-utils",children:"#"}),"4.4 @tarojs/shared 内部使用的 utils"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Taro 内部使用的 utils。包含了常用的类型判断、错误断言、组件类型/声明/参数等。",(0,s.jsx)(n.code,{children:"@tarojs/shared"})," 会跨 node/浏览器/小程序/React Native 使用，不得使用平台特有特性。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"引入此包的必须采用 ES6 引用单个模块语法，且打包配置 external 不得包括此包。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// packages/shared/src/index.ts\n// Events 导出的位置\nexport * from './event-emitter'\n// hooks 导出的位置\nexport * from './runtime-hooks'\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"5-class-events-的具体实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-class-events-的具体实现",children:"#"}),"5. class Events 的具体实现"]}),"\n",(0,s.jsxs)(n.p,{children:["终于在 ",(0,s.jsx)(n.code,{children:"packages/shared/src/event-emitter.ts"})," 找到了 ",(0,s.jsx)(n.code,{children:"class Events"})," 的实现代码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/event-emitter.ts\ntype EventName = string | symbol\ntype EventCallbacks = Record<EventName, Record<'next' | 'tail', unknown>>\n\nexport class Events {\n  protected callbacks?: EventCallbacks\n  static eventSplitter = ',' // Note: Harmony ACE API 8 开发板不支持使用正则 split 字符串 /\\s+/\n\n  constructor (opts?) {\n    this.callbacks = opts?.callbacks ?? {}\n  }\n  // 省略这几个方法具体实现，拆分到下方讲述\n  on(){}\n  once(){}\n  off(){}\n  trigger(){}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"eventSplitter"})," 事件分割符 ",(0,s.jsx)(n.code,{children:","}),"。\n",(0,s.jsx)(n.code,{children:"callbacks"})," 对象存储事件名和回调函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"51-on-事件监听",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-on-事件监听",children:"#"}),"5.1 on 事件监听"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"on (eventName: EventName, callback: (...args: any[]) => void, context?: any): this {\n	let event: EventName | undefined, tail, _eventName: EventName[]\n	// 如果没传 callback 函数，则直接返回 this\n	if (!callback) {\n		return this\n	}\n	// 支持 symbol 事件名写法\n	// 也支持 事件名1,事件名2,事件名3 的写法\n	if (typeof eventName === 'symbol') {\n		_eventName = [eventName]\n	} else {\n		// 事件名1,事件名2,事件名3 分割成数组\n		_eventName = eventName.split(Events.eventSplitter)\n	}\n	this.callbacks ||= {}\n	const calls = this.callbacks\n	// 遍历事件名数组\n	while ((event = _eventName.shift())) {\n		const list = calls[event]\n		const node: any = list ? list.tail : {}\n		node.next = tail = {}\n		node.context = context\n		node.callback = callback\n		calls[event] = {\n			tail,\n			next: list ? list.next : node\n		}\n	}\n	// return this 支持链式调用\n	return this\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里可能有点抽象，我们举个例子调试下："}),"\n",(0,s.jsxs)(n.p,{children:["我们直接找到打包后的代码，路径：",(0,s.jsx)(n.code,{children:"taro/packages/shared/dist/event-emitter.js"}),"，注释",(0,s.jsx)(n.code,{children:"// export { Events };"}),"，追加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function fn1(){}\nfunction fn2(){}\nfunction fn3(){}\nfunction fn4(){}\nconst events = new Events()\n.on('eventName1', fn1)\n.on('eventName1', fn2)\n.on('eventName1', fn3)\n.on('eventName2', fn4);\n\nconsole.log(events.callbacks);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["打开终端，新建 ",(0,s.jsx)(n.code,{children:"JavaScript Debug Terminal"})," 调试，运行："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node packages/shared/dist/event-emitter.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["调试截图如下：\n",(0,s.jsx)(n.img,{alt:"调试 events",src:c})]}),"\n",(0,s.jsxs)(n.p,{children:["复制监视的 ",(0,s.jsx)(n.code,{children:"events.callbacks"})," 的值，它的对象存储如下结构："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  eventName1: {\n    tail: {\n    },\n    next: {\n      next: {\n        next: {\n          next: {\n          },\n          context: undefined,\n          callback: function fn3(){},\n        },\n        context: undefined,\n        callback: function fn2(){},\n      },\n      context: undefined,\n      callback: function fn1(){},\n    },\n  },\n  eventName2: {\n    tail: {\n    },\n    next: {\n      next: {\n      },\n      context: undefined,\n      callback: function fn4(){},\n    },\n  },\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"events callbacks 结构图",src:o})}),"\n",(0,s.jsxs)(n.p,{children:["也就是链表形式。同名的事件名，会追加到链表的 ",(0,s.jsx)(n.code,{children:"next"})," 节点。所以同名的事件名，可以触发多个 ",(0,s.jsx)(n.code,{children:"callback"})," 函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"52-once-事件监听只执行一次",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-once-事件监听只执行一次",children:"#"}),"5.2 once 事件监听只执行一次"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"once (events: EventName, callback: (...r: any[]) => void, context?: any): this {\n	const wrapper = (...args: any[]) => {\n		callback.apply(this, args)\n		this.off(events, wrapper, context)\n	}\n\n	// 执行一次后，调用 off 方法移除事件\n	this.on(events, wrapper, context)\n\n	return this\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["执行一遍后，调用 ",(0,s.jsx)(n.code,{children:"off"})," 方法移除事件。"]}),"\n",(0,s.jsxs)(n.h3,{id:"53-off-事件移除",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53-off-事件移除",children:"#"}),"5.3 off 事件移除"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"off (events?: EventName, callback?: (...args: any[]) => void, context?: any) {\n	let event: EventName | undefined, calls: EventCallbacks | undefined, _events: EventName[]\n	if (!(calls = this.callbacks)) {\n		return this\n	}\n	if (!(events || callback || context)) {\n		delete this.callbacks\n		return this\n	}\n	// 如果是 symbol 事件名，组成数组\n	if (typeof events === 'symbol') {\n		_events = [events]\n	} else {\n		// 事件名1,事件名2,事件名3 分割成数组\n		// 没有传事件名，则移除所有事件\n		_events = events ? events.split(Events.eventSplitter) : Object.keys(calls)\n	}\n	// 遍历事件名数组\n	while ((event = _events.shift())) {\n		let node: any = calls[event]\n		// 删除事件对象\n		delete calls[event]\n		if (!node || !(callback || context)) {\n			// 删除，进行下一次循环\n			continue\n		}\n		const tail = node.tail\n		while ((node = node.next) !== tail) {\n			const cb = node.callback\n			const ctx = node.context\n			if ((callback && cb !== callback) || (context && ctx !== context)) {\n				this.on(event, cb, ctx)\n			}\n		}\n	}\n	return this\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"54-trigger-事件触发",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#54-trigger-事件触发",children:"#"}),"5.4 trigger 事件触发"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"trigger (events: EventName, ...args: any[]) {\n	let event: EventName | undefined, node, calls: EventCallbacks | undefined, _events: EventName[]\n	// callbacks 对象不存在，则直接返回 this\n	if (!(calls = this.callbacks)) {\n		return this\n	}\n	// 如果是 symbol 事件名，组成数组 [events]\n	if (typeof events === 'symbol') {\n		_events = [events]\n	} else {\n		// 事件名1,事件名2,事件名3 分割成数组\n		_events = events.split(Events.eventSplitter)\n	}\n	// 遍历事件名数组\n	// 遍历链表，依次执行回调函数\n	while ((event = _events.shift())) {\n		if ((node = calls[event])) {\n			const tail = node.tail\n			while ((node = node.next) !== tail) {\n				node.callback.apply(node.context || this, args)\n			}\n		}\n	}\n	return this\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"遍历链表，依次执行回调函数。\ntail 结尾作为判断，到末尾了，终止遍历。"}),"\n",(0,s.jsxs)(n.p,{children:["接着我们来学习 ",(0,s.jsx)(n.code,{children:"eventCenter"})," 全局消息中心的实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"6-eventcenter-全局消息中心",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-eventcenter-全局消息中心",children:"#"}),"6. eventCenter 全局消息中心"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/taro-runtime/src/emitter/emitter.ts\nimport { Events, hooks } from '@tarojs/shared'\nconst eventCenter = hooks.call('getEventCenter', Events)!\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"7-hooks",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-hooks",children:"#"}),"7. hooks"]}),"\n",(0,s.jsxs)(n.p,{children:["根据上文的信息，我们可以找到 ",(0,s.jsx)(n.code,{children:"hooks"})," 对象的代码位置是 ",(0,s.jsx)(n.code,{children:"packages/shared/src/runtime-hooks.ts"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// packages/shared/src/runtime-hooks.ts\nimport { Events } from './event-emitter'\nimport { isFunction } from './is'\n\nimport type { Shortcuts } from './template'\n\n// Note: @tarojs/runtime 不依赖 @tarojs/taro, 所以不能改为从 @tarojs/taro 引入 (可能导致循环依赖)\ntype TFunc = (...args: any[]) => any\n\n// hook 类型\nexport enum HOOK_TYPE {\n  SINGLE,\n  MULTI,\n  WATERFALL\n}\n\n// hook 对象\ninterface Hook {\n  type: HOOK_TYPE\n  initial?: TFunc | null\n}\n\n// Node 对象\ninterface Node {\n  next: Node\n  context?: any\n  callback?: TFunc\n}\n\n// TaroHook 函数\nexport function TaroHook (type: HOOK_TYPE, initial?: TFunc): Hook {\n  return {\n    type,\n    initial: initial || null\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这段代码声明了一些 ",(0,s.jsx)(n.code,{children:"TS"})," 接口和类型等，",(0,s.jsx)(n.code,{children:"TaroHook"})," 函数返回一个 ",(0,s.jsx)(n.code,{children:"Hook"})," 对象。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/runtime-hooks.ts\ntype ITaroHooks = {\n  /** 小程序端 App、Page 构造对象的生命周期方法名称 */\n  getMiniLifecycle: (defaultConfig: MiniLifecycle) => MiniLifecycle\n  // 省略若干代码\n  /** 解决支付宝小程序分包时全局作用域不一致的问题 */\n  getEventCenter: (EventsClass: typeof Events) => Events\n  // 省略若干代码\n  initNativeApi: (taro: Record<string, any>) => void\n}\n\nexport const hooks = new TaroHooks<ITaroHooks>({\n  getMiniLifecycle: TaroHook(HOOK_TYPE.SINGLE, defaultConfig => defaultConfig),\n  // 省略若干代码\n  getEventCenter: TaroHook(HOOK_TYPE.SINGLE, Events => new Events()),\n  // 省略若干代码\n  initNativeApi: TaroHook(HOOK_TYPE.MULTI),\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hooks"})," 对象是 ",(0,s.jsx)(n.code,{children:"TaroHooks"})," 的实例对象。",(0,s.jsx)(n.code,{children:"TaroHooks"})," 继承自 ",(0,s.jsx)(n.code,{children:"Events"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们来看 ",(0,s.jsx)(n.code,{children:"TaroHooks"})," 的具体实现"]}),"\n",(0,s.jsxs)(n.h2,{id:"8-class-tarohooks-的具体实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-class-tarohooks-的具体实现",children:"#"}),"8. class TaroHooks 的具体实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// packages/shared/src/runtime-hooks.ts\nexport class TaroHooks<T extends Record<string, TFunc> = any> extends Events {\n  hooks: Record<keyof T, Hook>\n\n  constructor (hooks: Record<keyof T, Hook>, opts?) {\n    super(opts)\n	// 初始化 hooks 对象\n	/**\n	 *\n	{\n		getMiniLifecycle,\n		getEventCenter: {\n			type: 0,\n			initial: (Events) => new Events(),\n		},\n		initNativeApi,\n		省略了一些其他hooks\n	}\n\n	 *\n	 */\n    this.hooks = hooks\n	// 遍历 hooks 对象，\n	// 如果 initial 是函数，调用 this.on 方法，监听事件\n	// getEventCenter 的 type 是 SINGLE， initial 是函数 (Events) => new Events()\n    for (const hookName in hooks) {\n      const { initial } = hooks[hookName]\n      if (isFunction(initial)) {\n        this.on(hookName, initial)\n      }\n    }\n  }\n\n  private tapOneOrMany<K extends Extract<keyof T, string>> (hookName: K, callback: T[K] | T[K][]) {\n	// 列表，变量\n    const list = isFunction(callback) ? [callback] : callback\n    list.forEach(cb => this.on(hookName, cb))\n  }\n  //   省略tap、call方法，拆开到下方讲述\n  isExist (hookName: string) {\n    return Boolean(this.callbacks?.[hookName])\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"81-tap-方法---监听事件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#81-tap-方法---监听事件",children:"#"}),"8.1 tap 方法 - 监听事件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tap<K extends Extract<keyof T, string>> (hookName: K, callback: T[K] | T[K][]) {\n    const hooks = this.hooks\n    const { type, initial } = hooks[hookName]\n    if (type === HOOK_TYPE.SINGLE) {\n	  // 单个类型的hook，则取消监听事件，重新监听事件\n      this.off(hookName)\n      this.on(hookName, isFunction(callback) ? callback : callback[callback.length - 1])\n    } else {\n	  // 不是，则取消监听指定回调函数的事件，重新监听一个或多个事件\n      initial && this.off(hookName, initial)\n      this.tapOneOrMany(hookName, callback)\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tap"})," 方法是监听事件，",(0,s.jsx)(n.code,{children:"hook"}),"类型是",(0,s.jsx)(n.code,{children:"SINGLE"}),"类型时，直接取消，重新监听。不是",(0,s.jsx)(n.code,{children:"SINGLE"}),"类型时，则取消监听指定回调函数的事件，重新监听一个或多个事件。"]}),"\n",(0,s.jsxs)(n.h3,{id:"82-call-方法---触发事件",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#82-call-方法---触发事件",children:"#"}),"8.2 call 方法 - 触发事件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"call<K extends Extract<keyof T, string>> (hookName: K, ...rest: Parameters<T[K]>): ReturnType<T[K]> | undefined {\n	// 获取 hooks 对象\n	// call('getEventCenter', Events);\n    const hook = this.hooks[hookName]\n    if (!hook) return\n\n    const { type } = hook\n\n    // Events 对象 中的事件名称、回调函数等对象\n    const calls = this.callbacks\n    if (!calls) return\n\n    const list = calls[hookName] as { tail: Node, next: Node }\n\n    if (list) {\n      const tail = list.tail\n      let node: Node = list.next\n      let args = rest\n      let res\n\n	  // 遍历链表，依次执行回调函数\n	  //  判断条件，节点不等于列表的末尾\n      while (node !== tail) {\n        res = node.callback?.apply(node.context || this, args)\n		// 如果是 waterfall，则 args 是 [res]\n        if (type === HOOK_TYPE.WATERFALL) {\n          const params: any = [res]\n          args = params\n        }\n        node = node.next\n      }\n      return res\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因为 ",(0,s.jsx)(n.code,{children:"TaroHooks"})," 是继承自 ",(0,s.jsx)(n.code,{children:"Events"}),"，所以 ",(0,s.jsx)(n.code,{children:"call"})," 实现和 ",(0,s.jsx)(n.code,{children:"Events"})," 的 ",(0,s.jsx)(n.code,{children:"trigger"})," 触发事件类似。\n都是遍历链表，依次执行回调函数。还有一个判断，就是 ",(0,s.jsx)(n.code,{children:"type"})," 是 ",(0,s.jsx)(n.code,{children:"HOOK_TYPE.WATERFALL"})," 的时候，将返回值作为参数传给下一个回调。"]}),"\n",(0,s.jsx)(n.p,{children:"换句话说"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 调用 call 方法，触发事件\nimport { Events, hooks } from '@tarojs/shared'\nconst eventCenter = hooks.call('getEventCenter', Events)!\n/**\n *\n	getEventCenter: {\n		type: 0,\n		initial: (Events) => new Events(),\n	}\n *\n */\n"})}),"\n",(0,s.jsx)(n.p,{children:"简化之后，其实就是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const events = new Events();\nevents.on('getEventCenter', (Events) => new Events())\nevents.trigger('getEventCenter', Events));\n\nconst eventCenter = new Events();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["单从 ",(0,s.jsx)(n.code,{children:"getEventCenter"})," 函数来看，好像有些多此一举，为啥要这样写呢？可能是为了修复多个平台的bug。暂时不知道好处是啥，知道的读者朋友也可以反馈告知。"]}),"\n",(0,s.jsxs)(n.h2,{id:"9-总结",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-总结",children:"#"}),"9. 总结"]}),"\n",(0,s.jsxs)(n.p,{children:["我们通过文档",(0,s.jsx)(n.a,{href:"https://taro-docs.jd.com/docs/next/apis/about/events",rel:"noopener noreferrer",target:"_blank",children:"Taro 消息机制"}),"，了解到 ",(0,s.jsx)(n.code,{children:"Taro"})," 提供了",(0,s.jsx)(n.code,{children:"Events"})," 和 ",(0,s.jsx)(n.code,{children:"Taro.eventCenter"})," 对象，用于发布订阅。我们根据文档也实现了。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们在茫茫源码中，寻找 ",(0,s.jsx)(n.code,{children:"class Events"})," 的实现，依次在 ",(0,s.jsx)(n.code,{children:"@tarojs/taro"})," => ",(0,s.jsx)(n.code,{children:"@tarojs/api"})," => ",(0,s.jsx)(n.code,{children:"@tarojs/runtime"})," => ",(0,s.jsx)(n.code,{children:"@tarojs/shared"})," 层层查找，我们终于在 ",(0,s.jsx)(n.code,{children:"packages/shared/src/event-emitter.ts"})," 找到了 ",(0,s.jsx)(n.code,{children:"class Events"})," 的实现代码。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"class Events"})," 用链表存储事件，实现了 ",(0,s.jsx)(n.code,{children:"on、once、off、trigger"})," 等方法，用于发布订阅。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Taro.eventCenter"})," 对象其实也是 ",(0,s.jsx)(n.code,{children:"class Events"})," 的实例，只不过绕了一圈，用 ",(0,s.jsx)(n.code,{children:"TaroHooks"})," 实例 ",(0,s.jsx)(n.code,{children:"hooks.call('getEventCenter', Events)"})," 来获取。"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["作者：常以",(0,s.jsx)(n.strong,{children:"若川"}),"为名混迹于江湖。所知甚少，唯善学。",(0,s.jsx)(n.a,{href:"https://ruochuan12.github.io",rel:"noopener noreferrer",target:"_blank",children:"若川的博客"}),"，",(0,s.jsx)(n.a,{href:"https://github.com/ruochuan12/blog",rel:"noopener noreferrer",target:"_blank",children:"github blog"}),"，可以点个 ",(0,s.jsx)(n.code,{children:"star"})," 鼓励下持续创作。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后可以持续关注我",(0,s.jsx)(n.a,{href:"https://juejin.cn/user/1415826704971918",rel:"noopener noreferrer",target:"_blank",children:"@若川"}),"，欢迎关注我的",(0,s.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/MacNfeTPODNMLLFdzrULow",rel:"noopener noreferrer",target:"_blank",children:"公众号：若川视野"}),"。从 2021 年 8 月起，我持续组织了好几年的",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7079706017579139102",rel:"noopener noreferrer",target:"_blank",children:"每周大家一起学习 200 行左右的源码共读活动"}),"，感兴趣的可以",(0,s.jsxs)(n.a,{href:"https://juejin.cn/pin/7217386885793595453",rel:"noopener noreferrer",target:"_blank",children:["点此扫码加我微信 ",(0,s.jsx)(n.code,{children:"ruochuan02"})," 参与"]}),"。另外，想学源码，极力推荐关注我写的专栏",(0,s.jsx)(n.a,{href:"https://juejin.cn/column/6960551178908205093",rel:"noopener noreferrer",target:"_blank",children:"《学习源码整体架构系列》"}),"，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["taro%2Fevents%2Findex.md"]={toc:[{id:"1-前言",text:"1. 前言",depth:2},{id:"2-taro-消息机制",text:"2. Taro 消息机制",depth:2},{id:"3-根据文档使用实现-events",text:"3. 根据文档使用实现 Events",depth:2},{id:"31-初步实现-events",text:"3.1 初步实现 Events",depth:3},{id:"32-off-方法实现",text:"3.2 off 方法实现",depth:3},{id:"33-trigger-方法实现",text:"3.3 trigger 方法实现",depth:3},{id:"4-在茫茫源码中寻找-class-events-实现",text:"4. 在茫茫源码中寻找 class Events 实现",depth:2},{id:"41-tarojstaro-暴露者开发者的-taro-核心-api",text:"4.1 @tarojs/taro 暴露者开发者的 Taro 核心 API",depth:3},{id:"42-tarojsapi-所有端的公有-api",text:"4.2 @tarojs/api 所有端的公有 API",depth:3},{id:"43-tarojsruntime-taro-运行时",text:"4.3 @tarojs/runtime Taro 运行时",depth:3},{id:"44-tarojsshared-内部使用的-utils",text:"4.4 @tarojs/shared 内部使用的 utils",depth:3},{id:"5-class-events-的具体实现",text:"5. class Events 的具体实现",depth:2},{id:"51-on-事件监听",text:"5.1 on 事件监听",depth:3},{id:"52-once-事件监听只执行一次",text:"5.2 once 事件监听只执行一次",depth:3},{id:"53-off-事件移除",text:"5.3 off 事件移除",depth:3},{id:"54-trigger-事件触发",text:"5.4 trigger 事件触发",depth:3},{id:"6-eventcenter-全局消息中心",text:"6. eventCenter 全局消息中心",depth:2},{id:"7-hooks",text:"7. hooks",depth:2},{id:"8-class-tarohooks-的具体实现",text:"8. class TaroHooks 的具体实现",depth:2},{id:"81-tap-方法---监听事件",text:"8.1 tap 方法 - 监听事件",depth:3},{id:"82-call-方法---触发事件",text:"8.2 call 方法 - 触发事件",depth:3},{id:"9-总结",text:"9. 总结",depth:2}],title:"Taro 源码揭秘：5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？",headingTitle:"Taro 源码揭秘：5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？",frontmatter:{highlight:"darcula",theme:"smartblue"}}},20713:function(e,n,t){t.d(n,{Z:()=>i});var s=t(52676),r=t(75271),a=t(92815);t(18544);let c={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function o(e,n,t){let s=Object.keys(c).includes(n)?n:t;return c[s](e)}let i=e=>{let{defaultLocale:n="en-US"}=e,t=(0,a.Vi)().page.readingTimeData,c=(0,a.Jr)(),i=(0,a.e7)(),[l,d]=(0,r.useState)(o(t,c,n));return(0,r.useEffect)(()=>{d(o(t,c,n))},[c,t]),(0,s.jsx)("span",{"data-dark":String(i),className:"rp-reading-time",children:l})}}}]);